<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Rush to Amazon 9]]></title>
      <url>https://nbPeterWang.github.io/%20/2020/01/06/Rush-to-Amazon-9/</url>
      <content type="html"><![CDATA[<h3 id="759-Employee-Free-Time"><a href="#759-Employee-Free-Time" class="headerlink" title="759. Employee Free Time"></a>759. Employee Free Time</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">lass Solution &#123;</span><br><span class="line">    public List&lt;Interval&gt; employeeFreeTime(List&lt;List&lt;Interval&gt;&gt; schedule) &#123;</span><br><span class="line">        int totalMeetings = 0;</span><br><span class="line">        for(List&lt;Interval&gt; x : schedule) &#123;</span><br><span class="line">            totalMeetings += x.size();</span><br><span class="line">        &#125;</span><br><span class="line">        int[] start = new int[totalMeetings];</span><br><span class="line">        int[] end = new int[totalMeetings];  </span><br><span class="line">        int i=0;</span><br><span class="line">        for(List&lt;Interval&gt; a : schedule) &#123;</span><br><span class="line">            for(Interval b : a) &#123;</span><br><span class="line">                start[i] = b.start;</span><br><span class="line">                end[i] = b.end;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(start);</span><br><span class="line">        Arrays.sort(end);</span><br><span class="line">        List&lt;Interval&gt; temp = new ArrayList&lt;Interval&gt;();</span><br><span class="line">        for(int k=1; k&lt;totalMeetings; k++) &#123;</span><br><span class="line">            if(start[k] &gt; end[k-1]) &#123;</span><br><span class="line">                temp.add(new Interval(end[k-1], start[k]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int size = temp.size();</span><br><span class="line">        </span><br><span class="line">        List&lt;Interval&gt; result = new ArrayList&lt;Interval&gt;();</span><br><span class="line">        for(int d=0; d&lt;size; d++) &#123;</span><br><span class="line">            result.add(temp.get(d));</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Using arrayList to store the temporary free time.<br>Itâ€™s O(nlogn).</p>
<h3 id="140-Word-Break-II"><a href="#140-Word-Break-II" class="headerlink" title="140. Word Break II"></a>140. Word Break II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    int maxLen = Integer.MIN_VALUE;//Used to record the longest length of word in the dict</span><br><span class="line">    public List&lt;String&gt; wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        // Corner case</span><br><span class="line">        if(wordDict.size() == 0) &#123;</span><br><span class="line">            return new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        //Used to prune recursion tree!!!</span><br><span class="line">        for (String str: wordDict) &#123;</span><br><span class="line">            maxLen = Math.max(maxLen, str.length());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Map&lt;Integer, List&lt;String&gt;&gt; memo = new HashMap&lt;&gt;();</span><br><span class="line">        return dfs(s, new HashSet&lt;&gt;(wordDict), 0, memo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> //   s = &quot;catsanddog&quot;</span><br><span class="line">//wordDict = [&quot;cat&quot;, &quot;cats&quot;, &quot;and&quot;, &quot;sand&quot;, &quot;dog&quot;]</span><br><span class="line">    </span><br><span class="line">    private List&lt;String&gt; dfs(String s, Set&lt;String&gt; wordDictSet, int start, Map&lt;Integer, List&lt;String&gt;&gt; memo) &#123;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        // Base case:</span><br><span class="line">        if(start == s.length()) &#123;</span><br><span class="line">            res.add(&quot;&quot;);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        if(memo.get(start) != null) &#123;</span><br><span class="line">            return memo.get(start);</span><br><span class="line">        &#125;</span><br><span class="line">      </span><br><span class="line">        for(int end = start + 1; end &lt;= s.length(); end++) &#123;</span><br><span class="line">            //If the prefix&apos;s length is more than maxLen, we could directly break!!!!!</span><br><span class="line">            if (end - start &gt; maxLen) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">            String prefix = s.substring(start, end);</span><br><span class="line">            if(wordDictSet.contains(prefix)) &#123;</span><br><span class="line">               List&lt;String&gt; list = dfs(s, wordDictSet, end, memo);</span><br><span class="line"></span><br><span class="line">               if(list.size() == 0) &#123;</span><br><span class="line">                   continue;</span><br><span class="line">               &#125; else if(list.get(0) == &quot;&quot;) &#123;</span><br><span class="line">                   res.add(prefix);</span><br><span class="line">               &#125; else &#123;</span><br><span class="line">                  for(String word: list) &#123;</span><br><span class="line">                      res.add(prefix + &quot; &quot; + word);</span><br><span class="line">                  &#125; </span><br><span class="line">               &#125;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;    </span><br><span class="line">        memo.put(start, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using memorized dfs.</p>
<h3 id="866-Prime-Palindrome"><a href="#866-Prime-Palindrome" class="headerlink" title="866. Prime Palindrome"></a>866. Prime Palindrome</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int primePalindrome(int N) &#123;</span><br><span class="line">        if (N == 1 || N == 2) return 2;</span><br><span class="line">        if (N % 2 == 0) N++;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (isPalindrome(N) &amp;&amp; isPrime(N)) return N;</span><br><span class="line">            N += 2;</span><br><span class="line">            if (10_000_000 &lt; N &amp;&amp; N &lt; 100_000_000)</span><br><span class="line">                N = 100_000_001;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean isPalindrome(int n) &#123;</span><br><span class="line">        if (n % 10 == 0 &amp;&amp; n != 0) return false;</span><br><span class="line">        int n1 = 0;</span><br><span class="line">        while (n &gt; n1) &#123;</span><br><span class="line">            n1 = n1 * 10 + (n % 10);</span><br><span class="line">            n /= 10;</span><br><span class="line">        &#125;</span><br><span class="line">        return n1 == n || n == n1 / 10;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private boolean isPrime(int n) &#123;</span><br><span class="line">        int end = (int)Math.sqrt(n);</span><br><span class="line">        for (int i = 3; i &lt;= end; i += 2) &#123;</span><br><span class="line">            if (n % i == 0) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1268-Search-Suggestions-System"><a href="#1268-Search-Suggestions-System" class="headerlink" title="1268. Search Suggestions System"></a>1268. Search Suggestions System</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; suggestedProducts(String[] products, String searchWord) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res=new ArrayList&lt;&gt;();</span><br><span class="line">        List&lt;String&gt; curRes=Arrays.asList(products);</span><br><span class="line">        Collections.sort(curRes);</span><br><span class="line">        int l=0;</span><br><span class="line">        int r=products.length-1;</span><br><span class="line">        for(int i=0;i&lt;searchWord.length();i++)&#123;</span><br><span class="line">            </span><br><span class="line">            &lt;!-- //Input: products = [&quot;mobile&quot;,&quot;mouse&quot;,&quot;moneypot&quot;,&quot;monitor&quot;,&quot;mousepad&quot;], searchWord = &quot;mouse&quot;</span><br><span class="line">Output: [</span><br><span class="line">[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],</span><br><span class="line">[&quot;mobile&quot;,&quot;moneypot&quot;,&quot;monitor&quot;],</span><br><span class="line">[&quot;mouse&quot;,&quot;mousepad&quot;],</span><br><span class="line">[&quot;mouse&quot;,&quot;mousepad&quot;],</span><br><span class="line">[&quot;mouse&quot;,&quot;mousepad&quot;]</span><br><span class="line">] --&gt;</span><br><span class="line">            char c=searchWord.charAt(i);</span><br><span class="line">            while(l&lt;=r)&#123;</span><br><span class="line">                </span><br><span class="line">                if(curRes.get(r).length()&lt;=i||curRes.get(r).charAt(i)!=c) r--;</span><br><span class="line">                if(curRes.get(l).length()&lt;=i||curRes.get(l).charAt(i)!=c) l++;</span><br><span class="line">                if(l&lt;=r&amp;&amp;curRes.get(r).charAt(i)==c&amp;&amp;curRes.get(l).charAt(i)==c)&#123;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            List&lt;String&gt; temp=new ArrayList&lt;&gt;();</span><br><span class="line">            if(r&lt;l)&#123;</span><br><span class="line">                res.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else if(r-l&lt;3)&#123;</span><br><span class="line">                temp=curRes.subList(l,r+1);</span><br><span class="line">                res.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                temp=curRes.subList(l,l+3);</span><br><span class="line">                res.add(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>First we sort, then just using temp list to store every sublist.</p>
<h3 id="1102-Path-With-Maximum-Minimum-Value"><a href="#1102-Path-With-Maximum-Minimum-Value" class="headerlink" title="1102. Path With Maximum Minimum Value"></a>1102. Path With Maximum Minimum Value</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int maximumMinimumPath(int[][] A) &#123;</span><br><span class="line">        int row = A.length;</span><br><span class="line">        int col = A[0].length;</span><br><span class="line">        int l = 1;</span><br><span class="line">        int h = Math.min(A[0][0], A[row - 1][col - 1]) + 1;</span><br><span class="line">        int[] dir = &#123;0, 1, 0, -1, 0&#125;;</span><br><span class="line"></span><br><span class="line">        while (l &lt; h) &#123;</span><br><span class="line">            int mid = l+(h-l)/2;</span><br><span class="line">            boolean[][] visited = new boolean[row][col];</span><br><span class="line">            if (isValid(A, visited, mid, 0, 0, row, col, dir)) &#123;</span><br><span class="line">                l = mid + 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                h = mid;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return l - 1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private boolean isValid(int[][] A, boolean[][] visited, int mid, int i, int j, int row, int col, int[] dir) &#123;</span><br><span class="line">        visited[i][j] = true;</span><br><span class="line">        if (i == row - 1 &amp;&amp; j == col - 1) &#123;</span><br><span class="line">            return true;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int k = 0; k &lt; 4; k++) &#123;</span><br><span class="line">            int ni = i + dir[k];</span><br><span class="line">            int nj = j + dir[k + 1];</span><br><span class="line">            if (ni &gt;= 0 &amp;&amp; ni &lt; row &amp;&amp; nj &gt;= 0 &amp;&amp; nj &lt; col &amp;&amp; !visited[ni][nj] &amp;&amp; A[ni][nj] &gt;= mid) &#123;</span><br><span class="line">                if (isValid(A, visited, mid, ni, nj, row, col, dir)) &#123;</span><br><span class="line">                    return true;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using binary search and dfs.</p>
<h3 id="1152-Analyze-User-Website-Visit-Pattern"><a href="#1152-Analyze-User-Website-Visit-Pattern" class="headerlink" title="1152. Analyze User Website Visit Pattern"></a>1152. Analyze User Website Visit Pattern</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; mostVisitedPattern(String[] username, int[] timestamp, String[] website) &#123;</span><br><span class="line">        Map&lt;String,TreeMap&lt;Integer,String&gt;&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        for(int i=0;i&lt;username.length;++i)&#123;</span><br><span class="line">            if(!map.containsKey(username[i]))&#123;</span><br><span class="line">                TreeMap&lt;Integer,String&gt; tree = new TreeMap&lt;&gt;();</span><br><span class="line">                tree.put(timestamp[i],website[i]);</span><br><span class="line">                map.put(username[i],tree);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">               TreeMap&lt;Integer,String&gt; tree = map.get(username[i]);</span><br><span class="line">                tree.put(timestamp[i],website[i]);</span><br><span class="line">                map.put(username[i],tree);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        int max = Integer.MIN_VALUE;</span><br><span class="line">        String ans = &quot;&quot;;</span><br><span class="line">        HashMap&lt;String,Integer&gt; seq = new HashMap&lt;&gt;();</span><br><span class="line">        for(String x:map.keySet())&#123;</span><br><span class="line">            TreeMap&lt;Integer,String&gt; tree = map.get(x);</span><br><span class="line">            HashSet&lt;String&gt; set = new HashSet&lt;String&gt;();</span><br><span class="line">            List&lt;String&gt; temp = new ArrayList&lt;&gt;();</span><br><span class="line">            for(Integer y:tree.keySet())  temp.add(tree.get(y));</span><br><span class="line">            for(int i=0;i&lt;temp.size()-2;++i)&#123;</span><br><span class="line">                String app1 = temp.get(i) + &quot; &quot;;</span><br><span class="line">                for(int j=i+1;j&lt;temp.size()-1;++j)&#123;</span><br><span class="line">                    String app2 = temp.get(j) + &quot; &quot;;</span><br><span class="line">                    for(int k=j+1;k&lt;temp.size();++k)&#123;</span><br><span class="line">                        String app3 = temp.get(k);</span><br><span class="line">                        String app = app1 + app2 + app3;</span><br><span class="line">                        if(set.contains(app)) continue;</span><br><span class="line">                        set.add(app);</span><br><span class="line">                        seq.put(app,seq.getOrDefault(app,0)+1);</span><br><span class="line">                        if(seq.get(app)&gt;max)&#123;</span><br><span class="line">                            max = seq.get(app);</span><br><span class="line">                            ans = app;</span><br><span class="line">                        &#125;else if(seq.get(app)==max &amp;&amp; ans.compareTo(app)&gt;0)&#123;</span><br><span class="line">                            ans = app;</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return Arrays.asList(ans.split(&quot; &quot;));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
        
        <tags>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Rush to Amazon 8]]></title>
      <url>https://nbPeterWang.github.io/%20/2020/01/05/Rush-to-Amazon-8/</url>
      <content type="html"><![CDATA[<h3 id="99-Recover-Binary-Search-Tree"><a href="#99-Recover-Binary-Search-Tree" class="headerlink" title="99. Recover Binary Search Tree"></a>99. Recover Binary Search Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    TreeNode x = null, y = null, pred = null;</span><br><span class="line">    </span><br><span class="line">    public void recoverTree(TreeNode root) &#123;</span><br><span class="line">        </span><br><span class="line">        findTwoSwapped(root);</span><br><span class="line">        swap(x, y);</span><br><span class="line">    &#125;</span><br><span class="line">    public void swap(TreeNode a, TreeNode b)&#123;</span><br><span class="line">        int tmp = a.val;</span><br><span class="line">        a.val = b.val;</span><br><span class="line">        b.val = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void findTwoSwapped(TreeNode root)&#123;</span><br><span class="line">        if (root == null) return;</span><br><span class="line">        findTwoSwapped(root.left);</span><br><span class="line">        if (pred != null &amp;&amp; root.val &lt; pred.val)&#123;</span><br><span class="line">           y = root;</span><br><span class="line">           if (x == null) x = pred;</span><br><span class="line">            else return;</span><br><span class="line">        &#125;</span><br><span class="line">        pred = root;</span><br><span class="line">        findTwoSwapped(root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Using inorder recursion to find the two swapped node, then swap.</p>
<h3 id="980-Unique-Paths-III"><a href="#980-Unique-Paths-III" class="headerlink" title="980. Unique Paths III"></a>980. Unique Paths III</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">int res = 0, empty = 1, sx, sy, ex, ey;</span><br><span class="line">   public int uniquePathsIII(int[][] grid) &#123;</span><br><span class="line">       int m = grid.length, n = grid[0].length;</span><br><span class="line">       for (int i = 0; i &lt; m; ++i) &#123;</span><br><span class="line">           for (int j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">               if (grid[i][j] == 0) empty++;</span><br><span class="line">               else if (grid[i][j] == 1) &#123;</span><br><span class="line">                   sx = i;</span><br><span class="line">                   sy = j;</span><br><span class="line">               &#125; else if (grid[i][j] == 2) &#123;</span><br><span class="line">                   ex = i;</span><br><span class="line">                   ey = j;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       dfs(grid, sx, sy);</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public void dfs(int[][] grid, int x, int y) &#123;</span><br><span class="line">       if (x &lt; 0 || x &gt;= grid.length || y &lt; 0 || y &gt;= grid[0].length || grid[x][y] &lt; 0)</span><br><span class="line">           return;</span><br><span class="line">       if (x == ex &amp;&amp; y == ey) &#123;</span><br><span class="line">           if (empty == 0) res++;</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       grid[x][y] = -2;</span><br><span class="line">       empty--;</span><br><span class="line">       dfs(grid, x + 1, y);</span><br><span class="line">       dfs(grid, x - 1, y);</span><br><span class="line">       dfs(grid, x, y + 1);</span><br><span class="line">       dfs(grid, x, y - 1);</span><br><span class="line">       grid[x][y] = 0;</span><br><span class="line">       empty++;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>using brute force dfs.</p>
<h3 id="545-Boundary-of-Binary-Tree"><a href="#545-Boundary-of-Binary-Tree" class="headerlink" title="545. Boundary of Binary Tree"></a>545. Boundary of Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Integer&gt; nodes = new ArrayList&lt;&gt;(1000);</span><br><span class="line">public List&lt;Integer&gt; boundaryOfBinaryTree(TreeNode root) &#123;</span><br><span class="line">    </span><br><span class="line">    if(root == null) return nodes;</span><br><span class="line"></span><br><span class="line">    nodes.add(root.val);</span><br><span class="line">    leftBoundary(root.left);</span><br><span class="line">    leaves(root.left);</span><br><span class="line">    leaves(root.right);</span><br><span class="line">    rightBoundary(root.right);</span><br><span class="line">    </span><br><span class="line">    return nodes;</span><br><span class="line">&#125;</span><br><span class="line">public void leftBoundary(TreeNode root) &#123;</span><br><span class="line">    if(root == null || (root.left == null &amp;&amp; root.right == null)) return;</span><br><span class="line">    nodes.add(root.val);</span><br><span class="line">    if(root.left == null) leftBoundary(root.right);</span><br><span class="line">    else leftBoundary(root.left);</span><br><span class="line">&#125;</span><br><span class="line">public void rightBoundary(TreeNode root) &#123;</span><br><span class="line">    if(root == null || (root.right == null &amp;&amp; root.left == null)) return;</span><br><span class="line">    if(root.right == null)rightBoundary(root.left);</span><br><span class="line">    else rightBoundary(root.right);</span><br><span class="line">    nodes.add(root.val); // add after child visit(reverse)</span><br><span class="line">&#125;</span><br><span class="line">public void leaves(TreeNode root) &#123;</span><br><span class="line">    if(root == null) return;</span><br><span class="line">    if(root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">        nodes.add(root.val);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    leaves(root.left);</span><br><span class="line">    leaves(root.right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="1167-Minimum-Cost-to-Connect-Sticks"><a href="#1167-Minimum-Cost-to-Connect-Sticks" class="headerlink" title="1167. Minimum Cost to Connect Sticks"></a>1167. Minimum Cost to Connect Sticks</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">//min-heap</span><br><span class="line">  public int connectSticks(int[] sticks) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        //add all elements to the min heap</span><br><span class="line">        PriorityQueue&lt;Integer&gt; pq = new PriorityQueue();</span><br><span class="line">        for (int s : sticks)</span><br><span class="line">            pq.add(s);</span><br><span class="line">        </span><br><span class="line">        //iterate over all elements in the heap</span><br><span class="line">        while (pq.size() &gt; 1) &#123;</span><br><span class="line">            int cost = pq.poll() + pq.poll();</span><br><span class="line">            res += cost;</span><br><span class="line">            pq.add(cost);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//</span><br><span class="line">class Solution &#123;</span><br><span class="line">     int left = 0, right = 0, numSticks, numResults = 0, num;</span><br><span class="line">    // Gets the minimum from InputSet and ResultSet</span><br><span class="line">    private boolean getMin(int[] sticks) &#123;</span><br><span class="line">        // check if there are numbers available from InputSet and ResultSet</span><br><span class="line">        boolean f = right &lt; numSticks, s = left &lt; numResults;</span><br><span class="line">        // If number is available from both sets, choose the smallest</span><br><span class="line">        if (f &amp;&amp; s) num = (sticks[left] &lt;= sticks[right]) ? sticks[left++] : sticks[right++];</span><br><span class="line">        // If number is available from InputSet only</span><br><span class="line">        else if (f) num = sticks[right++];</span><br><span class="line">        // If number is available from ResultSet only</span><br><span class="line">        else if (s) num = sticks[left++];</span><br><span class="line">        return f || s; // Returns result saying if we could find a number from any one of the Sets.</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int connectSticks(int[] sticks) &#123;</span><br><span class="line">        numSticks = sticks.length;</span><br><span class="line">        Arrays.sort(sticks); // Initial sort</span><br><span class="line">        int result = 0, first, second; // Result and place holders to get the smallest two numbers.</span><br><span class="line">        // Continue till you can get two numbers every time from the Sets.</span><br><span class="line">        while (true) &#123;</span><br><span class="line">            if (!getMin(sticks)) break;</span><br><span class="line">            first = num;</span><br><span class="line">            if (!getMin(sticks)) break;</span><br><span class="line">            second = num;</span><br><span class="line">            result += sticks[numResults++] = first + second; // Store the sum back in the ResultSet</span><br><span class="line">        &#125;</span><br><span class="line">        return result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using the min heap.</p>
<p>###<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public int mergeStones(int[] stones, int K) &#123;</span><br><span class="line">       int n = stones.length;</span><br><span class="line">       if((n - 1) % (K - 1) != 0)  return -1;</span><br><span class="line">       int[][] f = new int[n][n];</span><br><span class="line">       int[] pre = new int[n + 1];</span><br><span class="line">       for(int i = 1; i &lt;= n; i++)&#123;</span><br><span class="line">           pre[i] = pre[i - 1] + stones[i - 1];</span><br><span class="line">       &#125;</span><br><span class="line">      </span><br><span class="line">       return search(0, n - 1, f, pre, K);</span><br><span class="line">   &#125;</span><br><span class="line">   private int search(int x, int y, int[][] f, int[] pre, int K)&#123;</span><br><span class="line">       int len = y - x + 1;</span><br><span class="line">       if(len &lt; K) return 0;</span><br><span class="line">       if(f[x][y] != 0)   return f[x][y];</span><br><span class="line">       f[x][y] = Integer.MAX_VALUE;</span><br><span class="line">       for(int mid = x; mid &lt; y; mid += K - 1)&#123;</span><br><span class="line">           f[x][y] = Math.min(f[x][y], search(x, mid, f, pre, K) + search(mid + 1, y, f, pre, K));</span><br><span class="line">       &#125;</span><br><span class="line">       if((y - x) % (K - 1) == 0)  f[x][y] += pre[y + 1] - pre[x];</span><br><span class="line">       return f[x][y];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>using recursion dp.<br>increase the speed.</p>
]]></content>
      
        
        <tags>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Rush to Amazon 7]]></title>
      <url>https://nbPeterWang.github.io/%20/2020/01/02/Rush-to-Amazon-7/</url>
      <content type="html"><![CDATA[<h3 id="126-Word-Ladder-II"><a href="#126-Word-Ladder-II" class="headerlink" title="126   Word Ladder II"></a>126   Word Ladder II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;List&lt;String&gt;&gt; findLadders(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">        List&lt;List&lt;String&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; words = new HashSet&lt;&gt;(wordList);</span><br><span class="line">        if(!words.contains(endWord)) return res;</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); // current word and nexts</span><br><span class="line">        Set&lt;String&gt; startSet = new HashSet&lt;&gt;();</span><br><span class="line">        Set&lt;String&gt; endSet = new HashSet&lt;&gt;();</span><br><span class="line">        startSet.add(beginWord);</span><br><span class="line">        endSet.add(endWord);</span><br><span class="line">        </span><br><span class="line">        bfs(startSet, map, words, endSet, false);</span><br><span class="line">        </span><br><span class="line">        List&lt;String&gt; list = new ArrayList&lt;&gt;();</span><br><span class="line">        list.add(beginWord);</span><br><span class="line">        dfs(res, list, endWord, beginWord, map);</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void dfs(List&lt;List&lt;String&gt;&gt; res, List&lt;String&gt; list, String endWord, String curword, Map&lt;String, List&lt;String&gt;&gt; map) &#123;</span><br><span class="line">        if(curword.equals(endWord)) &#123;</span><br><span class="line">            res.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if(map.get(curword) == null) return;</span><br><span class="line">        for(String next : map.get(curword)) &#123;</span><br><span class="line">            list.add(next);</span><br><span class="line">            dfs(res, list, endWord, next, map);</span><br><span class="line">            list.remove(list.size() - 1);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void bfs(Set&lt;String&gt; startSet, Map&lt;String, List&lt;String&gt;&gt; map, Set&lt;String&gt; words, Set&lt;String&gt; endSet, boolean reverse) &#123;</span><br><span class="line">        if (startSet.size() == 0) return;</span><br><span class="line">        </span><br><span class="line">        if (startSet.size() &gt; endSet.size()) &#123;</span><br><span class="line">            bfs(endSet, map, words, startSet, !reverse);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        Set&lt;String&gt; nextLevelSet = new HashSet&lt;&gt;();</span><br><span class="line">        boolean finish = false;</span><br><span class="line">        words.removeAll(startSet);</span><br><span class="line">        </span><br><span class="line">        for (String word : startSet) &#123;</span><br><span class="line">            char[] curword = word.toCharArray();</span><br><span class="line">            for (int i = 0; i &lt; curword.length; i++) &#123;</span><br><span class="line">                char oldchar = curword[i];</span><br><span class="line">                for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++) &#123;</span><br><span class="line">                    curword[i] = c;</span><br><span class="line">                    String word_after = new String(curword);</span><br><span class="line">                    </span><br><span class="line">                    if (words.contains(word_after)) &#123;</span><br><span class="line">                        if(endSet.contains(word_after)) &#123;</span><br><span class="line">                            finish = true;</span><br><span class="line">                        &#125;</span><br><span class="line">                        else &#123;</span><br><span class="line">                            nextLevelSet.add(word_after);</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        String key = reverse ? word_after : word;</span><br><span class="line">                        String value = reverse ? word : word_after;</span><br><span class="line">                        </span><br><span class="line">                        if(map.get(key) == null) &#123;</span><br><span class="line">                            map.put(key, new ArrayList&lt;&gt;());</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                        map.get(key).add(value);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                curword[i] = oldchar;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if(finish == false) &#123;</span><br><span class="line">            bfs(nextLevelSet, map, words, endSet, reverse);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>using bfs to find the shortest distance, use DFS to output paths with the same distance.</p>
<h3 id="103-Binary-Tree-Zigzag-Level-Order-Traversal"><a href="#103-Binary-Tree-Zigzag-Level-Order-Traversal" class="headerlink" title="103  Binary Tree Zigzag Level Order Traversal"></a>103  Binary Tree Zigzag Level Order Traversal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; zigzagLevelOrder(TreeNode root) &#123;</span><br><span class="line">        if (root == null) &#123;</span><br><span class="line">      return new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; results = new ArrayList&lt;List&lt;Integer&gt;&gt;();</span><br><span class="line"></span><br><span class="line">    // add the root element with a delimiter to kick off the BFS loop</span><br><span class="line">    LinkedList&lt;TreeNode&gt; node_queue = new LinkedList&lt;TreeNode&gt;();</span><br><span class="line">    node_queue.addLast(root);</span><br><span class="line">    node_queue.addLast(null);</span><br><span class="line"></span><br><span class="line">    LinkedList&lt;Integer&gt; level_list = new LinkedList&lt;Integer&gt;();</span><br><span class="line">    boolean is_order_left = true;</span><br><span class="line"></span><br><span class="line">    while (node_queue.size() &gt; 0) &#123;</span><br><span class="line">      TreeNode curr_node = node_queue.pollFirst();</span><br><span class="line">      if (curr_node != null) &#123;</span><br><span class="line">        if (is_order_left)</span><br><span class="line">          level_list.addLast(curr_node.val);</span><br><span class="line">        else</span><br><span class="line">          level_list.addFirst(curr_node.val);</span><br><span class="line"></span><br><span class="line">        if (curr_node.left != null)</span><br><span class="line">          node_queue.addLast(curr_node.left);</span><br><span class="line">        if (curr_node.right != null)</span><br><span class="line">          node_queue.addLast(curr_node.right);</span><br><span class="line"></span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        // we finish the scan of one level</span><br><span class="line">        results.add(level_list);</span><br><span class="line">        level_list = new LinkedList&lt;Integer&gt;();</span><br><span class="line">        // prepare for the next level</span><br><span class="line">        if (node_queue.size() &gt; 0)</span><br><span class="line">          node_queue.addLast(null);</span><br><span class="line">        is_order_left = !is_order_left;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return results;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>using bfs. One list node queue to record node list. One level_list to record every level.</p>
<h3 id="472-Concatenated-Words"><a href="#472-Concatenated-Words" class="headerlink" title="472   Concatenated Words"></a>472   Concatenated Words</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public List&lt;String&gt; findAllConcatenatedWordsInADict(String[] words) &#123;</span><br><span class="line">        </span><br><span class="line">        Set&lt;String&gt; hset=new HashSet&lt;&gt;(10000);</span><br><span class="line">        List&lt;String&gt; l=new ArrayList&lt;&gt;();</span><br><span class="line">        int min=Integer.MAX_VALUE;</span><br><span class="line">        for(String s:words)&#123;</span><br><span class="line">            if(s.length()==0) continue;</span><br><span class="line">            hset.add(s);</span><br><span class="line">            min=Math.min(min,s.length());</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        for(String s:words)&#123;</span><br><span class="line">            if(check(hset,s,0,min)) l.add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return l;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public boolean check(Set&lt;String&gt; hset,String w,int start,int min)&#123;</span><br><span class="line">        </span><br><span class="line">        for(int i=start+min; i&lt;=w.length()-min;i++)&#123;</span><br><span class="line">            if(hset.contains(w.substring(start,i)) &amp;&amp;(hset.contains(w.substring(i)) ||</span><br><span class="line">                                                     check(hset,w,i,min))) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using set.</p>
<h3 id="957-Prison-Cells-After-N-Days"><a href="#957-Prison-Cells-After-N-Days" class="headerlink" title="957  Prison Cells After N Days"></a>957  Prison Cells After N Days</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] prisonAfterNDays(int[] cells, int N) &#123;</span><br><span class="line">        N = N % 14;</span><br><span class="line">        if (N == 0) &#123;</span><br><span class="line">            N = 14;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; N; i++) &#123;</span><br><span class="line">            cells = nextDay(cells);</span><br><span class="line">        &#125;</span><br><span class="line">        return cells;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int[] nextDay(int[] cells) &#123;</span><br><span class="line">        int[] res = new int[8];</span><br><span class="line">        for (int i = 1; i &lt;= 6; i++) &#123;</span><br><span class="line">            res[i] = 1 - (cells[i - 1] ^ cells[i + 1]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>14 is the magic number!</p>
<h3 id="456-132-Pattern"><a href="#456-132-Pattern" class="headerlink" title="456  132 Pattern"></a>456  132 Pattern</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Solution &#123;</span><br><span class="line">    public boolean find132pattern(int[] nums) &#123;</span><br><span class="line">        if (nums.length &lt; 3)</span><br><span class="line">            return false;</span><br><span class="line">        int[] min = new int[nums.length];</span><br><span class="line">        min[0] = nums[0];</span><br><span class="line">        for (int i = 1; i &lt; nums.length; i++)</span><br><span class="line">            min[i] = Math.min(min[i - 1], nums[i]);</span><br><span class="line">        for (int j = nums.length - 1, k = nums.length; j &gt;= 0; j--) &#123;</span><br><span class="line">            if (nums[j] &gt; min[j]) &#123;</span><br><span class="line">                while (k &lt; nums.length &amp;&amp; nums[k] &lt;= min[j])</span><br><span class="line">                    k++;</span><br><span class="line">                if (k &lt; nums.length &amp;&amp; nums[k] &lt; nums[j])</span><br><span class="line">                    return true;</span><br><span class="line">                nums[--k] = nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using array as a stack.</p>
]]></content>
      
        
        <tags>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Rush to Amazon 6]]></title>
      <url>https://nbPeterWang.github.io/%20/2020/01/01/Rush-to-Amazon-6/</url>
      <content type="html"><![CDATA[<h3 id="348-Design-Tic-Tac-Toe"><a href="#348-Design-Tic-Tac-Toe" class="headerlink" title="348   Design Tic-Tac-Toe"></a>348   Design Tic-Tac-Toe</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">public class TicTacToe &#123;</span><br><span class="line">private int[] rows;</span><br><span class="line">private int[] cols;</span><br><span class="line">private int diagonal;</span><br><span class="line">private int antiDiagonal;</span><br><span class="line"></span><br><span class="line">/** Initialize your data structure here. */</span><br><span class="line">public TicTacToe(int n) &#123;</span><br><span class="line">    rows = new int[n];</span><br><span class="line">    cols = new int[n];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/** Player &#123;player&#125; makes a move at (&#123;row&#125;, &#123;col&#125;).</span><br><span class="line">    @param row The row of the board.</span><br><span class="line">    @param col The column of the board.</span><br><span class="line">    @param player The player, can be either 1 or 2.</span><br><span class="line">    @return The current winning condition, can be either:</span><br><span class="line">            0: No one wins.</span><br><span class="line">            1: Player 1 wins.</span><br><span class="line">            2: Player 2 wins. */</span><br><span class="line">public int move(int row, int col, int player) &#123;</span><br><span class="line">    int toAdd = player == 1 ? 1 : -1;</span><br><span class="line">    </span><br><span class="line">    rows[row] += toAdd;</span><br><span class="line">    cols[col] += toAdd;</span><br><span class="line">    if (row == col)</span><br><span class="line">    &#123;</span><br><span class="line">        diagonal += toAdd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    if (col == (cols.length - row - 1))</span><br><span class="line">    &#123;</span><br><span class="line">        antiDiagonal += toAdd;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int size = rows.length;</span><br><span class="line">    if (Math.abs(rows[row]) == size ||</span><br><span class="line">        Math.abs(cols[col]) == size ||</span><br><span class="line">        Math.abs(diagonal) == size  ||</span><br><span class="line">        Math.abs(antiDiagonal) == size)</span><br><span class="line">    &#123;</span><br><span class="line">        return player;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>To keep track of which player, I add one for Player1 and -1 for Player2. There are two additional variables to keep track of the count of the diagonals. Each time a player places a piece we just need to check the count of that row, column, diagonal and anti-diagonal.</p>
<h3 id="772-Basic-Calculator-III"><a href="#772-Basic-Calculator-III" class="headerlink" title="772  Basic Calculator III"></a>772  Basic Calculator III</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public int calculate(String s) &#123;</span><br><span class="line">       if(s == null || s.length() == 0) return 0;</span><br><span class="line">       return usingRecur(s, new int[]&#123;0&#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   private int usingRecur(String s, int[] i) &#123;</span><br><span class="line">       int num = 0, res = 0, prev = 0;</span><br><span class="line">       char sign = &apos;+&apos;;</span><br><span class="line">       while(i[0] &lt; s.length()) &#123;</span><br><span class="line">           char c = s.charAt(i[0]++);</span><br><span class="line">           if     (c == &apos; &apos;) continue;</span><br><span class="line">           else if(c == &apos;(&apos;) num = usingRecur(s, i);</span><br><span class="line">           else if(c == &apos;)&apos;) break;</span><br><span class="line">           else if(Character.isDigit(c)) num = num*10+(c-&apos;0&apos;);</span><br><span class="line">           else &#123;</span><br><span class="line">               if(sign == &apos;+&apos; || sign == &apos;-&apos;) res += prev;</span><br><span class="line">               prev = eval(sign, num, prev);</span><br><span class="line">               sign = c;</span><br><span class="line">               num  = 0;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       if(sign == &apos;+&apos; || sign == &apos;-&apos;) res += prev;</span><br><span class="line">       prev = eval(sign, num, prev);</span><br><span class="line">       return res+prev;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   private int eval(char sign, int num, int prev) &#123;</span><br><span class="line">       if     (sign == &apos;+&apos;) prev = num;</span><br><span class="line">       else if(sign == &apos;-&apos;) prev = -num;</span><br><span class="line">       else if(sign == &apos;*&apos;) prev *= num;</span><br><span class="line">       else if(sign == &apos;/&apos;) prev /= num;</span><br><span class="line">       return prev;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>usings stack or recursion.</p>
<h3 id="819-Most-Common-Word"><a href="#819-Most-Common-Word" class="headerlink" title="819  Most Common Word"></a>819  Most Common Word</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public String mostCommonWord(String paragraph, String[] banned) &#123;</span><br><span class="line"></span><br><span class="line">        // for cases that end with a letter only. e.g. &quot;Bob&quot;</span><br><span class="line">        paragraph += &quot;.&quot;;</span><br><span class="line"></span><br><span class="line">        Set&lt;String&gt; bannedSet = new HashSet&lt;&gt;();</span><br><span class="line">        for (String word : banned) bannedSet.add(word);</span><br><span class="line">        </span><br><span class="line">        Map&lt;String, Integer&gt; count = new HashMap&lt;&gt;();</span><br><span class="line">        StringBuilder word = new StringBuilder();</span><br><span class="line">        String ans = &quot;&quot;;</span><br><span class="line">        int freq = 0;</span><br><span class="line"></span><br><span class="line">        for (char c : paragraph.toCharArray()) &#123;</span><br><span class="line">            if (Character.isLetter(c)) &#123;</span><br><span class="line">                word.append(Character.toLowerCase(c));</span><br><span class="line">            &#125; else if (word.length() &gt; 0) &#123;</span><br><span class="line">                String finalWord = word.toString();</span><br><span class="line">                if (!bannedSet.contains(finalWord)) &#123;</span><br><span class="line">                    count.put(finalWord, count.getOrDefault(finalWord, 0) + 1);</span><br><span class="line">                    if (count.get(finalWord) &gt; freq) &#123;</span><br><span class="line">                        ans = finalWord;</span><br><span class="line">                        freq = count.get(finalWord);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                word = new StringBuilder();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="994-Rotting-Oranges"><a href="#994-Rotting-Oranges" class="headerlink" title="994   Rotting Oranges"></a>994   Rotting Oranges</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int orangesRotting(int[][] grid) &#123;</span><br><span class="line">      int d = 0, fresh = 0;</span><br><span class="line">      for (int i = 0; i &lt; grid.length; ++i) &#123;</span><br><span class="line">          for (int j = 0; j &lt; grid[i].length; ++j) &#123;</span><br><span class="line">          if (grid[i][j] == 1) fresh += 1;</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    </span><br><span class="line">      for (int old_fresh = fresh; fresh &gt; 0; ++d, old_fresh = fresh) &#123;</span><br><span class="line">          for (int i = 0; i &lt; grid.length; ++i) &#123;</span><br><span class="line">              for (int j = 0; j &lt; grid[i].length; ++j) &#123;</span><br><span class="line">                if (grid[i][j] == d + 2) &#123;</span><br><span class="line">                  fresh -= rot(grid, i - 1, j, d) + rot(grid, i + 1, j, d) + rot(grid, i, j - 1, d) + rot(grid, i, j + 1, d);</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            if (old_fresh == fresh) return -1;</span><br><span class="line">          &#125;</span><br><span class="line">      return d;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private int rot(int[][] grid, int i, int j, int d) &#123;</span><br><span class="line">      if (i &lt; 0 || j &lt; 0 || i &gt;= grid.length || j &gt;= grid[0].length || grid[i][j] != 1) return 0;</span><br><span class="line">      grid[i][j] = d + 3;</span><br><span class="line">      return 1;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>using BFS, rot every </p>
<h3 id="347-Top-K-Frequent-Elements"><a href="#347-Top-K-Frequent-Elements" class="headerlink" title="347  Top K Frequent Elements"></a>347  Top K Frequent Elements</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; topKFrequent(int[] nums, int k) &#123;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt;[] bucket = new List[nums.length + 1];</span><br><span class="line">Map&lt;Integer, Integer&gt; frequencyMap = new HashMap&lt;Integer, Integer&gt;();</span><br><span class="line"></span><br><span class="line">for (int n : nums) &#123;</span><br><span class="line">	frequencyMap.put(n, frequencyMap.getOrDefault(n, 0) + 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">for (int key : frequencyMap.keySet()) &#123;</span><br><span class="line">	int frequency = frequencyMap.get(key);</span><br><span class="line">	if (bucket[frequency] == null) &#123;</span><br><span class="line">		bucket[frequency] = new ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line">	bucket[frequency].add(key);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">List&lt;Integer&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">for (int pos = bucket.length - 1; pos &gt;= 0 &amp;&amp; res.size() &lt; k; pos--) &#123;</span><br><span class="line">	if (bucket[pos] != null) &#123;</span><br><span class="line">		res.addAll(bucket[pos]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">return res.subList(0,k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using bucket sort.</p>
]]></content>
      
        
        <tags>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Rush to Amazon 5]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/12/30/Rush-to-Amazon-5/</url>
      <content type="html"><![CDATA[<h3 id="295-Find-Median-from-Data-Stream"><a href="#295-Find-Median-from-Data-Stream" class="headerlink" title="295  Find Median from Data Stream"></a>295  Find Median from Data Stream</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br></pre></td><td class="code"><pre><span class="line">class MedianFinder &#123;</span><br><span class="line"></span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    private Queue&lt;Long&gt; small = new PriorityQueue(),</span><br><span class="line">                        large = new PriorityQueue();</span><br><span class="line"></span><br><span class="line">    public void addNum(int num) &#123;</span><br><span class="line">        large.add((long) num);</span><br><span class="line">        small.add(-large.poll());</span><br><span class="line">        if (large.size() &lt; small.size())</span><br><span class="line">            large.add(-small.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double findMedian() &#123;</span><br><span class="line">        return large.size() &gt; small.size()</span><br><span class="line">               ? large.peek()</span><br><span class="line">               : (large.peek() - small.peek()) / 2.0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class MedianFinder &#123;</span><br><span class="line">    class TreeNode&#123;</span><br><span class="line">        int val;</span><br><span class="line">        TreeNode parent,left,right;</span><br><span class="line">        TreeNode(int val, TreeNode p)&#123;</span><br><span class="line">            this.val=val;</span><br><span class="line">            this.parent=p;</span><br><span class="line">            left=null;</span><br><span class="line">            right=null;</span><br><span class="line">        &#125;</span><br><span class="line">        void add(int num)&#123;</span><br><span class="line">            if(num&gt;=val)&#123;</span><br><span class="line">                if(right==null)</span><br><span class="line">                    right=new TreeNode(num,this);</span><br><span class="line">                else</span><br><span class="line">                    right.add(num);</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                if(left==null)</span><br><span class="line">                    left=new TreeNode(num,this);</span><br><span class="line">                else</span><br><span class="line">                    left.add(num);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode next()&#123;</span><br><span class="line">            TreeNode ret;</span><br><span class="line">            if(right!=null)&#123;</span><br><span class="line">                ret=right;</span><br><span class="line">                while(ret.left!=null)</span><br><span class="line">                    ret=ret.left;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ret=this;</span><br><span class="line">                while(ret.parent.right==ret)</span><br><span class="line">                    ret=ret.parent;</span><br><span class="line">                ret=ret.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode prev()&#123;</span><br><span class="line">            TreeNode ret;</span><br><span class="line">            if(left!=null)&#123;</span><br><span class="line">                ret=left;</span><br><span class="line">                while(ret.right!=null)</span><br><span class="line">                    ret=ret.right;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                ret=this;</span><br><span class="line">                while(ret.parent.left==ret)</span><br><span class="line">                    ret=ret.parent;</span><br><span class="line">                ret=ret.parent;</span><br><span class="line">            &#125;</span><br><span class="line">            return ret;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int n;</span><br><span class="line">    TreeNode root, curr;</span><br><span class="line">    // Adds a number into the data structure.</span><br><span class="line">    public void addNum(int num) &#123;</span><br><span class="line">        if(root==null)&#123;</span><br><span class="line">            root = new TreeNode(num,null);</span><br><span class="line">            curr=root;</span><br><span class="line">            n=1;</span><br><span class="line">        &#125;else&#123;</span><br><span class="line">            root.add(num);</span><br><span class="line">            n++;</span><br><span class="line">            if(n%2==1)&#123;</span><br><span class="line">                if(curr.val&lt;=num)</span><br><span class="line">                    curr=curr.next();</span><br><span class="line">            &#125;else</span><br><span class="line">                if(curr.val&gt;num)</span><br><span class="line">                    curr=curr.prev();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // Returns the median of current data stream</span><br><span class="line">    public double findMedian() &#123;</span><br><span class="line">        if(n%2==0)&#123;</span><br><span class="line">            return ((double)curr.next().val+curr.val)/2;</span><br><span class="line">        &#125;else</span><br><span class="line">            return curr.val;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">//BST version</span><br></pre></td></tr></table></figure>
<p>Max-heap small has the smaller half of the numbers.<br>Min-heap large has the larger half of the numbers. getting the median takes O(1) time. And adding a number takes O(log n) time.<br><a id="more"></a></p>
<h3 id="572-Subtree-of-Another-Tree"><a href="#572-Subtree-of-Another-Tree" class="headerlink" title="572  Subtree of Another Tree"></a>572  Subtree of Another Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">  public boolean isSubtree(TreeNode s, TreeNode t) &#123;</span><br><span class="line">    return dfsUtility(s, t, false);</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public boolean dfsUtility(TreeNode s, TreeNode t, boolean matched) &#123;</span><br><span class="line">    if (s == null &amp;&amp; t == null) &#123;</span><br><span class="line">      return true;</span><br><span class="line">    &#125; else if (s == null || t == null) &#123;</span><br><span class="line">      return false;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      boolean hasMatch = false;</span><br><span class="line">      </span><br><span class="line">      if (s.val == t.val) &#123;</span><br><span class="line">        hasMatch = dfsUtility(s.left, t.left, true) &amp;&amp; dfsUtility(s.right, t.right, true);</span><br><span class="line">              </span><br><span class="line">        if (!hasMatch) &#123;</span><br><span class="line">          hasMatch = dfsUtility(s.left, t, false) || dfsUtility(s.right, t, false);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; else if (!matched) &#123;</span><br><span class="line">        hasMatch = dfsUtility(s.left, t, matched) || dfsUtility(s.right, t, matched);</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      return hasMatch;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using DFS &amp; memo. If</p>
<h3 id="341-Flatten-Nested-List-Iterator"><a href="#341-Flatten-Nested-List-Iterator" class="headerlink" title="341  Flatten Nested List Iterator"></a>341  Flatten Nested List Iterator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public class NestedIterator implements Iterator&lt;Integer&gt; &#123;</span><br><span class="line">    Queue&lt;Integer&gt; q;</span><br><span class="line">    public NestedIterator(List&lt;NestedInteger&gt; nestedList) &#123;</span><br><span class="line">        q = new LinkedList();</span><br><span class="line">        generateQueue(nestedList);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void generateQueue(List&lt;NestedInteger&gt; ns) &#123;</span><br><span class="line">        for (NestedInteger n : ns) &#123;</span><br><span class="line">            if (n.isInteger()) q.add(n.getInteger());</span><br><span class="line">            else &#123;</span><br><span class="line">                generateQueue(n.getList());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public Integer next() &#123;</span><br><span class="line">        if (!q.isEmpty()) return q.poll();</span><br><span class="line">        </span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return !q.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using queue.</p>
<h3 id="692-Top-K-Frequent-Words"><a href="#692-Top-K-Frequent-Words" class="headerlink" title="692  Top K Frequent Words"></a>692  Top K Frequent Words</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; topKFrequent(String[] words, int k) &#123;</span><br><span class="line">       Map&lt;String, Integer&gt; count = new HashMap();</span><br><span class="line">       for (String word: words) &#123;</span><br><span class="line">           count.put(word, count.getOrDefault(word, 0) + 1);</span><br><span class="line">       &#125;</span><br><span class="line">       PriorityQueue&lt;String&gt; heap = new PriorityQueue&lt;String&gt;(</span><br><span class="line">               (w1, w2) -&gt; count.get(w1).equals(count.get(w2)) ?</span><br><span class="line">               w2.compareTo(w1) : count.get(w1) - count.get(w2) );</span><br><span class="line"></span><br><span class="line">       for (String word: count.keySet()) &#123;</span><br><span class="line">           heap.offer(word);</span><br><span class="line">           if (heap.size() &gt; k) heap.poll();</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       List&lt;String&gt; ans = new ArrayList();</span><br><span class="line">       while (!heap.isEmpty()) ans.add(heap.poll());</span><br><span class="line">       Collections.reverse(ans);</span><br><span class="line">       return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>using heap, puts the worst candidates at the top of the heap. At the end, we pop off the heap up to k times and reverse the result so that the best candidates are first.</p>
<h3 id="460-LFU-Cache"><a href="#460-LFU-Cache" class="headerlink" title="460  LFU Cache"></a>460  LFU Cache</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">class LFUCache &#123;</span><br><span class="line">    private Map&lt;Integer, Integer&gt; keyToCount = new HashMap&lt;&gt;();</span><br><span class="line">    private Map&lt;Integer, Integer&gt; keyToVal = new HashMap&lt;&gt;();</span><br><span class="line">    private Map&lt;Integer, LinkedHashSet&lt;Integer&gt;&gt; countToSet = new HashMap&lt;&gt;();</span><br><span class="line">    private int min = 0;</span><br><span class="line">    private int cap;</span><br><span class="line">    </span><br><span class="line">    public LFUCache(int capacity) &#123;</span><br><span class="line">        cap = capacity;    </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        if (!keyToVal.containsKey(key)) &#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //1. get actual value and calculate freq</span><br><span class="line">        int val = keyToVal.get(key);</span><br><span class="line">        int oldFreq = keyToCount.get(key);</span><br><span class="line">        int newFreq = oldFreq + 1;</span><br><span class="line">        </span><br><span class="line">        //2. remove old freq</span><br><span class="line">        LinkedHashSet&lt;Integer&gt; oldSet = countToSet.get(oldFreq);</span><br><span class="line">        oldSet.remove(key);</span><br><span class="line">        </span><br><span class="line">        //3. update min</span><br><span class="line">        if (min == oldFreq &amp;&amp; oldSet.size() == 0) &#123;</span><br><span class="line">            min++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //4. add new freq and update freq map</span><br><span class="line">        keyToCount.put(key, newFreq);</span><br><span class="line">        countToSet.putIfAbsent(newFreq, new LinkedHashSet&lt;&gt;());</span><br><span class="line">        countToSet.get(newFreq).add(key);</span><br><span class="line">        </span><br><span class="line">        return val;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(int key, int value) &#123;</span><br><span class="line">        if (cap &lt;= 0) &#123;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //if they key already exists</span><br><span class="line">        if (keyToVal.containsKey(key)) &#123;</span><br><span class="line">            keyToVal.put(key, value);</span><br><span class="line">            get(key);</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">        //remove min freq if size alreay equal to capacity</span><br><span class="line">        if (keyToVal.size() &gt;= cap) &#123;</span><br><span class="line">            int keyToRemove = countToSet.get(min).iterator().next();</span><br><span class="line">            countToSet.get(min).remove(keyToRemove);</span><br><span class="line">            keyToCount.remove(keyToRemove);</span><br><span class="line">            keyToVal.remove(keyToRemove);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        //add the key and assign the min freq to 1</span><br><span class="line">        keyToCount.put(key, 1);</span><br><span class="line">        keyToVal.put(key, value);</span><br><span class="line">        countToSet.putIfAbsent(1, new LinkedHashSet&lt;&gt;());</span><br><span class="line">        countToSet.get(1).add(key);</span><br><span class="line">        min = 1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Rush to Amazon 4]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/12/30/Rush-to-Amazon-4/</url>
      <content type="html"><![CDATA[<h3 id="139-Word-Break"><a href="#139-Word-Break" class="headerlink" title="139  Word Break"></a>139  Word Break</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean wordBreak(String s, List&lt;String&gt; wordDict) &#123;</span><br><span class="line">        Set&lt;String&gt; wordDictSet=new HashSet(wordDict);</span><br><span class="line">        boolean[] dp = new boolean[s.length() + 1];</span><br><span class="line">        dp[0] = true;</span><br><span class="line">        for (int i = 1; i &lt;= s.length(); i++) &#123;</span><br><span class="line">            for(int j = i-1 ; j &gt;= 0; j--) &#123;</span><br><span class="line">                if (dp[j] &amp;&amp; wordDictSet.contains(s.substring(j, i))) &#123;</span><br><span class="line">                    dp[i] = true;</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return dp[s.length()];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Using Dynamic Programming,  we further check if s2â€™s2 â€²is present in the dictionary. It might end the loop early with smaller substring.</p>
<h3 id="240-Search-a-2D-Matrix-II"><a href="#240-Search-a-2D-Matrix-II" class="headerlink" title="240  Search a 2D Matrix II"></a>240  Search a 2D Matrix II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public boolean searchMatrix(int[][] matrix, int target) &#123;</span><br><span class="line">        if(matrix == null || matrix.length == 0 || matrix[0].length &lt;1) return false;</span><br><span class="line">        int row = matrix.length -1;</span><br><span class="line">        int col = 0;</span><br><span class="line">        while(row &gt;= 0 &amp;&amp; col &lt; matrix[0].length)&#123;</span><br><span class="line">            if(matrix[row][col] &gt; target)&#123;</span><br><span class="line">                row--;</span><br><span class="line">            &#125;else if(matrix[row][col] &lt; target)&#123;</span><br><span class="line">                col++;</span><br><span class="line">            &#125;else&#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity : O(n+m). Search Space Reduction</p>
<h3 id="127-Word-Ladder"><a href="#127-Word-Ladder" class="headerlink" title="127  Word Ladder"></a>127  Word Ladder</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">public int ladderLength(String beginWord, String endWord, List&lt;String&gt; wordList) &#123;</span><br><span class="line">       if (!wordList.contains(endWord)) return 0;       </span><br><span class="line">       Set&lt;String&gt; dict = new HashSet&lt;&gt;(wordList);</span><br><span class="line">       Set&lt;String&gt; beginSet = new HashSet&lt;&gt;();</span><br><span class="line">       Set&lt;String&gt; endSet = new HashSet&lt;&gt;();</span><br><span class="line">       beginSet.add(beginWord);</span><br><span class="line">       endSet.add(endWord);</span><br><span class="line"></span><br><span class="line">       int step = 1;</span><br><span class="line">       Set&lt;String&gt; visited = new HashSet&lt;&gt;();</span><br><span class="line">       while (!beginSet.isEmpty() &amp;&amp; !endSet.isEmpty()) &#123;</span><br><span class="line">           if (beginSet.size() &gt; endSet.size()) &#123;</span><br><span class="line">               Set&lt;String&gt; set = beginSet;</span><br><span class="line">               beginSet = endSet;</span><br><span class="line">               endSet = set;</span><br><span class="line">           &#125;</span><br><span class="line">           Set&lt;String&gt; temp = new HashSet&lt;&gt;();</span><br><span class="line">           for (String word : beginSet) &#123;</span><br><span class="line">               char[] chs = word.toCharArray();</span><br><span class="line">               for (int i = 0; i &lt; chs.length; i++) &#123;</span><br><span class="line">                   for (char c = &apos;a&apos;; c &lt;= &apos;z&apos;; c++) &#123;</span><br><span class="line">                       char old = chs[i];</span><br><span class="line">                       chs[i] = c;</span><br><span class="line">                       String target = String.valueOf(chs);</span><br><span class="line">                       if (endSet.contains(target)) &#123;</span><br><span class="line">                           return step + 1;</span><br><span class="line">                       &#125;</span><br><span class="line">                       if (!visited.contains(target) &amp;&amp; dict.contains(target)) &#123;</span><br><span class="line">                           temp.add(target);</span><br><span class="line">                           visited.add(target);</span><br><span class="line">                       &#125;</span><br><span class="line">                       chs[i] = old;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">           beginSet = temp;</span><br><span class="line">           step++;</span><br><span class="line">       &#125;</span><br><span class="line">       return 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Bidirectional  BFS search.</p>
<h3 id="642-Design-Search-Autocomplete-System"><a href="#642-Design-Search-Autocomplete-System" class="headerlink" title="642  Design Search Autocomplete System"></a>642  Design Search Autocomplete System</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line">class AutocompleteSystem &#123;</span><br><span class="line">    class TrieNode implements Comparable&lt;TrieNode&gt; &#123;</span><br><span class="line">        TrieNode[] children;</span><br><span class="line">        String s;</span><br><span class="line">        int times;</span><br><span class="line">        List&lt;TrieNode&gt; hot;</span><br><span class="line">        </span><br><span class="line">        public TrieNode() &#123;</span><br><span class="line">            children = new TrieNode[128];</span><br><span class="line">            s = null;</span><br><span class="line">            times = 0;</span><br><span class="line">            hot = new ArrayList&lt;&gt;();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public int compareTo(TrieNode o) &#123;</span><br><span class="line">            if (this.times == o.times) &#123;</span><br><span class="line">                return this.s.compareTo(o.s);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            return o.times - this.times;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        public void update(TrieNode node) &#123;</span><br><span class="line">            if (!this.hot.contains(node)) &#123;</span><br><span class="line">                this.hot.add(node);</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            Collections.sort(hot);</span><br><span class="line">            </span><br><span class="line">            if (hot.size() &gt; 3) &#123;</span><br><span class="line">                hot.remove(hot.size() - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    TrieNode root;</span><br><span class="line">    TrieNode cur;</span><br><span class="line">    StringBuilder sb;</span><br><span class="line">    public AutocompleteSystem(String[] sentences, int[] times) &#123;</span><br><span class="line">        root = new TrieNode();</span><br><span class="line">        cur = root;</span><br><span class="line">        sb = new StringBuilder();</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; times.length; i++) &#123;</span><br><span class="line">            add(sentences[i], times[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    public void add(String sentence, int t) &#123;</span><br><span class="line">        TrieNode tmp = root;</span><br><span class="line">        </span><br><span class="line">        List&lt;TrieNode&gt; visited = new ArrayList&lt;&gt;();</span><br><span class="line">        for (char c : sentence.toCharArray()) &#123;</span><br><span class="line">            if (tmp.children[c] == null) &#123;</span><br><span class="line">                tmp.children[c] = new TrieNode();</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            tmp = tmp.children[c];</span><br><span class="line">            visited.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        tmp.s = sentence;</span><br><span class="line">        tmp.times += t;</span><br><span class="line">        </span><br><span class="line">        for (TrieNode node : visited) &#123;</span><br><span class="line">            node.update(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public List&lt;String&gt; input(char c) &#123;</span><br><span class="line">        List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">        if (c == &apos;#&apos;) &#123;</span><br><span class="line">            add(sb.toString(), 1);</span><br><span class="line">            sb = new StringBuilder();</span><br><span class="line">            cur = root;</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        sb.append(c);</span><br><span class="line">        if (cur != null) &#123;</span><br><span class="line">            cur = cur.children[c];</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        if (cur == null) return res;</span><br><span class="line">        for (TrieNode node : cur.hot) &#123;</span><br><span class="line">            res.add(node.s);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>TrieNode </p>
<h3 id="212-Word-Search-II"><a href="#212-Word-Search-II" class="headerlink" title="212  Word Search II"></a>212  Word Search II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; findWords(char[][] board, String[] words) &#123;</span><br><span class="line">    List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    TrieNode root = buildTrie(words);</span><br><span class="line">    for (int i = 0; i &lt; board.length; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; board[0].length; j++) &#123;</span><br><span class="line">            dfs (board, i, j, root, res);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void dfs(char[][] board, int i, int j, TrieNode p, List&lt;String&gt; res) &#123;</span><br><span class="line">    char c = board[i][j];</span><br><span class="line">    if (c == &apos;#&apos; || p.next[c - &apos;a&apos;] == null) return;</span><br><span class="line">    p = p.next[c - &apos;a&apos;];</span><br><span class="line">    if (p.word != null) &#123;   // found one</span><br><span class="line">        res.add(p.word);</span><br><span class="line">        p.word = null;     // de-duplicate</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    board[i][j] = &apos;#&apos;;</span><br><span class="line">    if (i &gt; 0) dfs(board, i - 1, j ,p, res); </span><br><span class="line">    if (j &gt; 0) dfs(board, i, j - 1, p, res);</span><br><span class="line">    if (i &lt; board.length - 1) dfs(board, i + 1, j, p, res); </span><br><span class="line">    if (j &lt; board[0].length - 1) dfs(board, i, j + 1, p, res); </span><br><span class="line">    board[i][j] = c;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public TrieNode buildTrie(String[] words) &#123;</span><br><span class="line">    TrieNode root = new TrieNode();</span><br><span class="line">    for (String w : words) &#123;</span><br><span class="line">        TrieNode p = root;</span><br><span class="line">        for (char c : w.toCharArray()) &#123;</span><br><span class="line">            int i = c - &apos;a&apos;;</span><br><span class="line">            if (p.next[i] == null) p.next[i] = new TrieNode();</span><br><span class="line">            p = p.next[i];</span><br><span class="line">       &#125;</span><br><span class="line">       p.word = w;</span><br><span class="line">    &#125;</span><br><span class="line">    return root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class TrieNode &#123;</span><br><span class="line">    TrieNode[] next = new TrieNode[26];</span><br><span class="line">    String word;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Trie DFS.</p>
]]></content>
      
        
        <tags>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Rush to Amazon 3]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/12/28/Rush-to-Amazon-3/</url>
      <content type="html"><![CDATA[<h3 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253  Meeting Rooms II"></a>253  Meeting Rooms II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">// method 1 using min heap</span><br><span class="line"> public int minMeetingRooms(int[][] intervals) &#123;</span><br><span class="line">        if(intervals == null || intervals.length == 0) return 0;</span><br><span class="line">        Arrays.sort(intervals, (a, b) -&gt; (a[0] - b[0]));</span><br><span class="line">        int max = 0;</span><br><span class="line">        PriorityQueue&lt;int[]&gt; queue = new PriorityQueue&lt;&gt;(intervals.length, (a, b) -&gt; (a[1] - b[1]));</span><br><span class="line">        for(int i = 0; i &lt; intervals.length; i++)&#123;</span><br><span class="line">            while(!queue.isEmpty() &amp;&amp; intervals[i][0] &gt;= queue.peek()[1])</span><br><span class="line">                queue.poll();</span><br><span class="line">            queue.offer(intervals[i]);</span><br><span class="line">            max = Math.max(max, queue.size());</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">//method 2 using two pointer</span><br><span class="line"> public int minMeetingRooms(int[][] intervals) &#123;</span><br><span class="line">        int[]start = new int[intervals.length];   </span><br><span class="line">        int[]end = new int[intervals.length];</span><br><span class="line">        for(int i = 0; i &lt; intervals.length; ++i)&#123;</span><br><span class="line">            start[i] = intervals[i][0]; end[i] = intervals[i][1];</span><br><span class="line">        &#125;</span><br><span class="line">        Arrays.sort(start); Arrays.sort(end);</span><br><span class="line">        </span><br><span class="line">        int i = 0; int j = 0; int count = 0; int len = 0;</span><br><span class="line">        while(i &lt; intervals.length &amp;&amp; j &lt; intervals.length)&#123;</span><br><span class="line">            if(start[i] &lt; end[j])&#123;</span><br><span class="line">               count++;   i++;  </span><br><span class="line">               len = Math.max(len, count);   </span><br><span class="line">            &#125;else&#123;</span><br><span class="line">               j++;  count--;  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return len;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>First, sort intervals by their start time. Use a min heap to track the minimum end time of merged intervals. If the start time is right after the end time, poll. Then offer current intervals. Return the maximum queue size.<br>//method 2<br>copy the start time and end time, then sort. See if it merge. if merge, increase count. Return the maximum value of count.</p>
<h3 id="973-K-Closest-Points-to-Origin"><a href="#973-K-Closest-Points-to-Origin" class="headerlink" title="973 K Closest Points to Origin"></a>973 K Closest Points to Origin</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//method 1 sort</span><br><span class="line">public int[][] kClosest(int[][] points, int K) &#123;</span><br><span class="line">        int N = points.length;</span><br><span class="line">        int[] dists = new int[N];</span><br><span class="line">        for (int i = 0; i &lt; N; ++i)</span><br><span class="line">            dists[i] = dist(points[i]);</span><br><span class="line"></span><br><span class="line">        Arrays.sort(dists);</span><br><span class="line">        int distK = dists[K-1];</span><br><span class="line"></span><br><span class="line">        int[][] ans = new int[K][2];</span><br><span class="line">        int t = 0;</span><br><span class="line">        for (int i = 0; i &lt; N; ++i)</span><br><span class="line">            if (dist(points[i]) &lt;= distK)</span><br><span class="line">                ans[t++] = points[i];</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public int dist(int[] point) &#123;</span><br><span class="line">        return point[0] * point[0] + point[1] * point[1];</span><br><span class="line">    &#125;</span><br><span class="line">//method 2 quick sort.</span><br><span class="line">public int[][] kClosest(int[][] points, int K) &#123;</span><br><span class="line">    int len =  points.length, l = 0, r = len - 1;</span><br><span class="line">    while (l &lt;= r) &#123;</span><br><span class="line">        int mid = helper(points, l, r);</span><br><span class="line">        if (mid == K) break;</span><br><span class="line">        if (mid &lt; K) &#123;</span><br><span class="line">            l = mid + 1;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            r = mid - 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return Arrays.copyOfRange(points, 0, K);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int helper(int[][] A, int l, int r) &#123;</span><br><span class="line">    int[] pivot = A[l];</span><br><span class="line">    while (l &lt; r) &#123;</span><br><span class="line">        while (l &lt; r &amp;&amp; compare(A[r], pivot) &gt;= 0) r--;</span><br><span class="line">        A[l] = A[r];</span><br><span class="line">        while (l &lt; r &amp;&amp; compare(A[l], pivot) &lt;= 0) l++;</span><br><span class="line">        A[r] = A[l];</span><br><span class="line">    &#125;</span><br><span class="line">    A[l] = pivot;</span><br><span class="line">    return l;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private int compare(int[] p1, int[] p2) &#123;</span><br><span class="line">    return p1[0] * p1[0] + p1[1] * p1[1] - p2[0] * p2[0] - p2[1] * p2[1];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>method 2 average O(N), worst case O(N^2).</p>
<h3 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49  Group Anagrams"></a>49  Group Anagrams</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">    if (strs == null || strs.length == 0) return new ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">        Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">        for (String s : strs) &#123;</span><br><span class="line">            char[] ca = s.toCharArray();</span><br><span class="line">            Arrays.sort(ca);</span><br><span class="line">            String keyStr = String.valueOf(ca);</span><br><span class="line">            if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList&lt;String&gt;());</span><br><span class="line">            map.get(keyStr).add(s);</span><br><span class="line">        &#125;</span><br><span class="line">        return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>using hashmap,  sort every string and add it to the map.</p>
<h3 id="380-Insert-Delete-GetRandom-O-1"><a href="#380-Insert-Delete-GetRandom-O-1" class="headerlink" title="380  Insert Delete GetRandom O(1)"></a>380  Insert Delete GetRandom O(1)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">public class RandomizedSet &#123;</span><br><span class="line">	Random random;</span><br><span class="line">	Map&lt;Integer, Integer&gt; map;</span><br><span class="line">	List&lt;Integer&gt; list;</span><br><span class="line">	public RandomizedSet() &#123;</span><br><span class="line">		random = new Random();</span><br><span class="line">		map = new HashMap&lt;&gt;();</span><br><span class="line">		list = new ArrayList&lt;&gt;();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean insert(int val) &#123;</span><br><span class="line">		if (map.containsKey(val)) return false;</span><br><span class="line">		list.add(val);</span><br><span class="line">		return map.put(val, list.size()-1) == null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public boolean remove(int val) &#123;</span><br><span class="line">		if (!map.containsKey(val)) return false;</span><br><span class="line">		Integer position = map.get(val);</span><br><span class="line">		Collections.swap(list, position, list.size() - 1);</span><br><span class="line">		map.put(list.get(position),position);</span><br><span class="line">		list.remove(list.size()-1);</span><br><span class="line">		return map.remove(val) != null;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	public int getRandom() &#123;</span><br><span class="line">		int i = random.nextInt(list.size());</span><br><span class="line">		return list.get(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> ArrayListâ€™s remove method is O(n) if you remove from random location. To overcome that, we swap the values between (randomIndex, lastIndex) and always remove the entry from the end of the list. After the swap, you need to update the new index of the swapped value (which was previously at the end of the list) in the map.</p>
<h3 id="124-Binary-Tree-Maximum-Path-Sum"><a href="#124-Binary-Tree-Maximum-Path-Sum" class="headerlink" title="124  Binary Tree Maximum Path Sum"></a>124  Binary Tree Maximum Path Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">int maxValue;</span><br><span class="line">    </span><br><span class="line">    public int maxPathSum(TreeNode root) &#123;</span><br><span class="line">        maxValue = Integer.MIN_VALUE;</span><br><span class="line">        maxPathDown(root);</span><br><span class="line">        return maxValue;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private int maxPathDown(TreeNode node) &#123;</span><br><span class="line">        if (node == null) return 0;</span><br><span class="line">        int left = Math.max(0, maxPathDown(node.left));</span><br><span class="line">        int right = Math.max(0, maxPathDown(node.right));</span><br><span class="line">        maxValue = Math.max(maxValue, left + right + node.val);</span><br><span class="line">        return Math.max(left, right) + node.val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>The second maxValue contains the bigger between the left sub-tree and right sub-tree.<br>if (left + right + node.val &lt; maxValue ) then the result will not include the parent node which means the maximum path is in the left branch or right branch.</p>
]]></content>
      
        
        <tags>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Rush to Amazon 2]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/12/27/Rush-to-Amazon-2/</url>
      <content type="html"><![CDATA[<h3 id="23-Merge-k-Sorted-Lists"><a href="#23-Merge-k-Sorted-Lists" class="headerlink" title="23  Merge k Sorted Lists"></a>23  Merge k Sorted Lists</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">method-1:</span><br><span class="line">   public ListNode mergeKLists(ListNode[] lists) &#123;</span><br><span class="line">        if (lists == null || lists.length == 0) return null;</span><br><span class="line">        PriorityQueue&lt;ListNode&gt; queue = new PriorityQueue&lt;ListNode&gt;(lists.length, (a,b)-&gt; a.val - b.val);</span><br><span class="line">        </span><br><span class="line">        ListNode head = new ListNode(0);</span><br><span class="line">        ListNode tail = head;</span><br><span class="line">        </span><br><span class="line">        for (ListNode node:lists)</span><br><span class="line">            if (node != null)</span><br><span class="line">                queue.add(node);</span><br><span class="line">        </span><br><span class="line">        while (!queue.isEmpty())&#123;</span><br><span class="line">            tail.next = queue.poll();</span><br><span class="line">            tail = tail.next;</span><br><span class="line">            </span><br><span class="line">            if (tail.next != null)</span><br><span class="line">                queue.add(tail.next);</span><br><span class="line">        &#125;</span><br><span class="line">        return head.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">method-2:</span><br><span class="line"> public static ListNode mergeKLists(ListNode[] lists)&#123;</span><br><span class="line">    return partion(lists,0,lists.length-1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static ListNode partion(ListNode[] lists,int head,int tail)&#123;</span><br><span class="line">    if(head==tail)  return lists[head];</span><br><span class="line">    if(head &lt; tail)&#123;</span><br><span class="line">        int mid=head+(tail-head)/2;</span><br><span class="line">        ListNode l1=partion(lists,head,mid);</span><br><span class="line">        ListNode l2=partion(lists,mid+1,tail);</span><br><span class="line">        return merge(l1,l2);</span><br><span class="line">    &#125;else</span><br><span class="line">        return null;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//This function is from Merge Two Sorted Lists.</span><br><span class="line">public static ListNode merge(ListNode l1,ListNode l2)&#123;</span><br><span class="line">    if(l1==null) return l2;</span><br><span class="line">    if(l2==null) return l1;</span><br><span class="line">    if(l1.val&lt;l2.val)&#123;</span><br><span class="line">        l1.next=merge(l1.next,l2);</span><br><span class="line">        return l1;</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        l2.next=merge(l1,l2.next);</span><br><span class="line">        return l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>method1: Using priority queue and Java 8 lambda. Really concise.<br>method2: Using recursion merge. O(Nlogk).</p>
<h3 id="937-Reorder-Data-in-Log-Files"><a href="#937-Reorder-Data-in-Log-Files" class="headerlink" title="937  Reorder Data in Log Files"></a>937  Reorder Data in Log Files</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public String[] reorderLogFiles(String[] logs) &#123;</span><br><span class="line">        Arrays.sort(logs, (s1, s2) -&gt; &#123;</span><br><span class="line">            int idx1 = s1.indexOf(&apos; &apos;);</span><br><span class="line">            int idx2 = s2.indexOf(&apos; &apos;);</span><br><span class="line">            String l1 = s1.substring(idx1 + 1);</span><br><span class="line">            String l2 = s2.substring(idx2 + 1);</span><br><span class="line">            </span><br><span class="line">            if (l1.charAt(0) &lt;= &apos;9&apos;)&#123;</span><br><span class="line">                if (l2.charAt(0) &lt;= &apos;9&apos;) return 0;</span><br><span class="line">                else return 1;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                if (l2.charAt(0) &lt;= &apos;9&apos;) return -1;</span><br><span class="line">                else&#123;</span><br><span class="line">                    int cmpContent = l1.compareTo(l2);</span><br><span class="line">                    if (cmpContent != 0) return cmpContent;</span><br><span class="line">                    return s1.substring(0, idx1).compareTo(s2.substring(0, idx2));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        return logs;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>second argument is comparator. </p>
<h3 id="138-Copy-List-with-Random-Pointer"><a href="#138-Copy-List-with-Random-Pointer" class="headerlink" title="138 Copy List with Random Pointer"></a>138 Copy List with Random Pointer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public Node copyRandomList(Node head) &#123;</span><br><span class="line">        Node iter = head, next;</span><br><span class="line">        while(iter != null)&#123;</span><br><span class="line">            next = iter.next;</span><br><span class="line">            Node temp = new Node(iter.val);</span><br><span class="line">            iter.next = temp;</span><br><span class="line">            temp.next =next;</span><br><span class="line">            iter =next;</span><br><span class="line">        &#125;</span><br><span class="line">        iter = head;</span><br><span class="line">        while (iter !=null)&#123;</span><br><span class="line">            if (iter.random != null)&#123;</span><br><span class="line">                iter.next.random =iter.random.next;</span><br><span class="line">            &#125;</span><br><span class="line">            iter = iter.next.next;</span><br><span class="line">        &#125;</span><br><span class="line">        iter =head;</span><br><span class="line">        Node res = new Node(0);</span><br><span class="line">        Node copy, copyI = res;</span><br><span class="line">        while (iter !=null)&#123;</span><br><span class="line">            next = iter.next.next;</span><br><span class="line">            </span><br><span class="line">            copy =iter.next;</span><br><span class="line">            copyI.next = copy;</span><br><span class="line">            copyI = copy;</span><br><span class="line">            </span><br><span class="line">            iter.next =next;</span><br><span class="line">            iter =next;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return res.next;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="273-Integer-to-English-Words"><a href="#273-Integer-to-English-Words" class="headerlink" title="273  Integer to English Words"></a>273  Integer to English Words</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">private final String[] LESS_THAN_20 = &#123;&quot;&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;, &quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;, &quot;Thirteen&quot;, &quot;Fourteen&quot;, &quot;Fifteen&quot;, &quot;Sixteen&quot;, &quot;Seventeen&quot;, &quot;Eighteen&quot;, &quot;Nineteen&quot;&#125;;</span><br><span class="line">private final String[] TENS = &#123;&quot;&quot;, &quot;Ten&quot;, &quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;&#125;;</span><br><span class="line">private final String[] THOUSANDS = &#123;&quot;&quot;, &quot;Thousand&quot;, &quot;Million&quot;, &quot;Billion&quot;&#125;;</span><br><span class="line"></span><br><span class="line">public String numberToWords(int num) &#123;</span><br><span class="line">    if (num == 0) return &quot;Zero&quot;;</span><br><span class="line"></span><br><span class="line">    int i = 0;</span><br><span class="line">    String words = &quot;&quot;;</span><br><span class="line">    </span><br><span class="line">    while (num &gt; 0) &#123;</span><br><span class="line">        if (num % 1000 != 0)</span><br><span class="line">    	    words = helper(num % 1000) +THOUSANDS[i] + &quot; &quot; + words;</span><br><span class="line">    	num /= 1000;</span><br><span class="line">    	i++;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return words.trim();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private String helper(int num) &#123;</span><br><span class="line">    if (num == 0)</span><br><span class="line">        return &quot;&quot;;</span><br><span class="line">    else if (num &lt; 20)</span><br><span class="line">        return LESS_THAN_20[num] + &quot; &quot;;</span><br><span class="line">    else if (num &lt; 100)</span><br><span class="line">        return TENS[num / 10] + &quot; &quot; + helper(num % 10);</span><br><span class="line">    else</span><br><span class="line">        return LESS_THAN_20[num / 100] + &quot; Hundred &quot; + helper(num % 100);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>store all the word in three string []. Then do recursion.</p>
<h3 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297 Serialize and Deserialize Binary Tree"></a>297 Serialize and Deserialize Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public String serialize(TreeNode root) &#123;</span><br><span class="line">        return serial(new StringBuilder(), root).toString();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Generate preorder string</span><br><span class="line">    private StringBuilder serial(StringBuilder str, TreeNode root) &#123;</span><br><span class="line">        if (root == null) return str.append(&quot;#&quot;);</span><br><span class="line">        str.append(root.val).append(&quot;,&quot;);</span><br><span class="line">        serial(str, root.left).append(&quot;,&quot;);</span><br><span class="line">        serial(str, root.right);</span><br><span class="line">        return str;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public TreeNode deserialize(String data) &#123;</span><br><span class="line">        return deserial(new LinkedList&lt;&gt;(Arrays.asList(data.split(&quot;,&quot;))));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // Use queue to simplify position move</span><br><span class="line">    private TreeNode deserial(Queue&lt;String&gt; q) &#123;</span><br><span class="line">        String val = q.poll();</span><br><span class="line">        if (&quot;#&quot;.equals(val)) return null;</span><br><span class="line">        TreeNode root = new TreeNode(Integer.valueOf(val));</span><br><span class="line">        root.left = deserial(q);</span><br><span class="line">        root.right = deserial(q);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>using StringBuilder and recursion.</p>
]]></content>
      
        
        <tags>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Rush to Amazon 1]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/12/23/Rush-to-Amazon-1/</url>
      <content type="html"><![CDATA[<h3 id="2-Add-Two-Numbers"><a href="#2-Add-Two-Numbers" class="headerlink" title="2  Add Two Numbers"></a>2  Add Two Numbers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123;</span><br><span class="line">       int temp = 0;</span><br><span class="line">       ListNode resultNode = new ListNode(0);</span><br><span class="line">       ListNode res = resultNode;</span><br><span class="line">       </span><br><span class="line">       while (l1 != null || l2 != null || temp != 0)&#123;</span><br><span class="line">           if(l1 != null)&#123;</span><br><span class="line">               temp += l1.val;</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           if(l2 != null)&#123;</span><br><span class="line">               temp += l2.val;</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           resultNode.next = new ListNode(temp % 10);</span><br><span class="line">           temp /= 10;</span><br><span class="line">           resultNode = resultNode.next;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       return res.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>using a Node res to link headNode, in every iteration, calculate the sum of  l1 and l2 and the value left to get every nodeâ€™s value. At last, return res.next.<br><a id="more"></a></p>
<h3 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5 Longest Palindromic Substring"></a>5 Longest Palindromic Substring</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">    private int lo, maxLen;</span><br><span class="line"></span><br><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">	int len = s.length();</span><br><span class="line">	if (len &lt; 2)</span><br><span class="line">		return s;</span><br><span class="line">	</span><br><span class="line">    for (int i = 0; i &lt; len-1; i++) &#123;</span><br><span class="line">     	extendPalindrome(s, i, i);  //assume odd length, try to extend Palindrome as possible</span><br><span class="line">     	extendPalindrome(s, i, i+1); //assume even length.</span><br><span class="line">    &#125;</span><br><span class="line">    return s.substring(lo, lo + maxLen);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private void extendPalindrome(String s, int j, int k) &#123;</span><br><span class="line">	while (j &gt;= 0 &amp;&amp; k &lt; s.length() &amp;&amp; s.charAt(j) == s.charAt(k)) &#123;</span><br><span class="line">		j--;</span><br><span class="line">		k++;</span><br><span class="line">	&#125;</span><br><span class="line">	if (maxLen &lt; k - j - 1) &#123;</span><br><span class="line">		lo = j + 1;</span><br><span class="line">		maxLen = k - j - 1;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>try to record maxlength and location when we call the helper method. So it â€˜s  O(n^2).</p>
<h3 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15 3Sum"></a>15 3Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;</span><br><span class="line"> 	List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">    Arrays.sort(nums);</span><br><span class="line">    for (int i = 0; i + 2 &lt; nums.length; i++) &#123;</span><br><span class="line">        if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;              // skip same result</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        int j = i + 1, k = nums.length - 1;  </span><br><span class="line">        int target = -nums[i];</span><br><span class="line">        while (j &lt; k) &#123;</span><br><span class="line">            if (nums[j] + nums[k] == target) &#123;</span><br><span class="line">                res.add(Arrays.asList(nums[i], nums[j], nums[k]));</span><br><span class="line">                j++;</span><br><span class="line">                k--;</span><br><span class="line">                while (j &lt; k &amp;&amp; nums[j] == nums[j - 1]) j++;  // skip same result</span><br><span class="line">                while (j &lt; k &amp;&amp; nums[k] == nums[k + 1]) k--;  // skip same result</span><br><span class="line">            &#125; else if (nums[j] + nums[k] &gt; target) &#123;</span><br><span class="line">                k--;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using two pointer at every iteration. O(N^2).</p>
<h3 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3  Longest Substring Without Repeating Characters"></a>3  Longest Substring Without Repeating Characters</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">       if(s.length() == 0) return 0;</span><br><span class="line">        Map&lt;Character, Integer&gt; map = new HashMap&lt;&gt;();</span><br><span class="line">        int max = 0;</span><br><span class="line">        for (int i=0,j=0;i &lt; s.length(); ++i)&#123;</span><br><span class="line">            if(map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">                j = Math.max(j,map.get(s.charAt(i))+1);</span><br><span class="line">            &#125;</span><br><span class="line">            map.put(s.charAt(i), i);</span><br><span class="line">            max = Math.max(max, i-j+1);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>find every substring and find the maximum of them.</p>
<h3 id="21-Merge-Two-Sorted-Lists"><a href="#21-Merge-Two-Sorted-Lists" class="headerlink" title="21  Merge Two Sorted Lists"></a>21  Merge Two Sorted Lists</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">      if(l1 == null) return l2;</span><br><span class="line">	if(l2 == null) return l1;</span><br><span class="line">	if(l1.val &lt; l2.val)&#123;</span><br><span class="line">		l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">		return l1;</span><br><span class="line">	&#125; else&#123;</span><br><span class="line">		l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">		return l2;</span><br><span class="line">	&#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123;</span><br><span class="line">       ListNode resNode = new ListNode(0);</span><br><span class="line">       ListNode res = resNode;</span><br><span class="line">       while(l1 != null || l2 != null)&#123;</span><br><span class="line">             if(l2 == null)&#123;</span><br><span class="line">               resNode.next = new ListNode(l1.val);</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">               resNode = resNode.next;</span><br><span class="line">           &#125;</span><br><span class="line">           else if (l1 == null)&#123;</span><br><span class="line">               resNode.next = new ListNode(l2.val);</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">               resNode = resNode.next;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">           else if(l1.val &gt; l2.val)&#123;</span><br><span class="line">               resNode.next = new ListNode(l2.val);</span><br><span class="line">               l2 = l2.next;</span><br><span class="line">               resNode = resNode.next;</span><br><span class="line">           &#125;</span><br><span class="line">           else &#123;</span><br><span class="line">                resNode.next = new ListNode(l1.val);</span><br><span class="line">               l1 = l1.next;</span><br><span class="line">               resNode = resNode.next;</span><br><span class="line">           &#125;</span><br><span class="line">         </span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">     return res.next;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>recursive version and iterative version.</p>
]]></content>
      
        
        <tags>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Rush to Amazon]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/12/20/Rush-to-Amazon/</url>
      <content type="html"><![CDATA[<p>Amazon tag leetcode</p>
<h3 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42 Trapping Rain Water"></a>42 Trapping Rain Water</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int trap(int[] A) &#123;</span><br><span class="line">        int a = 0;</span><br><span class="line">        int b = A.length - 1;</span><br><span class="line">        int max = 0;</span><br><span class="line">        int leftmax = 0;</span><br><span class="line">        int rightmax = 0;</span><br><span class="line">        while( a &lt;= b)&#123;</span><br><span class="line">            leftmax = Math.max(leftmax, A[a]);</span><br><span class="line">            rightmax = Math.max(rightmax, A[b]);</span><br><span class="line">            if(leftmax &lt; rightmax)&#123;</span><br><span class="line">                max += (leftmax - A[a]);</span><br><span class="line">                a++;</span><br><span class="line">            &#125;</span><br><span class="line">            else&#123;</span><br><span class="line">                max += (rightmax - A[b]);</span><br><span class="line">                b--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>For every iteration, just move one of two pointers. If leftmax is less than rightmax, move left pointer. Otherwise, move right pointer. By each move, we can count the rain water at pointerâ€™s current column.<br><a id="more"></a></p>
<h3 id="1-two-sum"><a href="#1-two-sum" class="headerlink" title="1 two sum"></a>1 two sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; ans = new HashMap&lt;&gt;();</span><br><span class="line">    for (int i = 0; i &lt; nums.length; ++i)&#123;</span><br><span class="line">        int diff = target - nums[i];</span><br><span class="line">            if (ans.containsKey(diff))&#123;</span><br><span class="line">                return new int[]&#123;ans.get(diff),i&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        ans.put(nums[i],i);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return new int[]&#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using one way hashmap.</p>
<h3 id="1192-Critical-Connections-in-a-network"><a href="#1192-Critical-Connections-in-a-network" class="headerlink" title="1192 Critical Connections in a network"></a>1192 Critical Connections in a network</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     public List&lt;List&lt;Integer&gt;&gt; criticalConnections(int n, List&lt;List&lt;Integer&gt;&gt; connections) &#123;</span><br><span class="line">            List&lt;Integer&gt;[] grah = new ArrayList[n];</span><br><span class="line">            for (int i = 0; i &lt; n; i++) grah[i] = new ArrayList&lt;&gt;();</span><br><span class="line">            for (List&lt;Integer&gt; e : connections) &#123;</span><br><span class="line">                int from = e.get(0);</span><br><span class="line">                int to = e.get(1);</span><br><span class="line">                grah[from].add(to);</span><br><span class="line">                grah[to].add(from);</span><br><span class="line">            &#125;</span><br><span class="line">            int[] low = new int[n];</span><br><span class="line">            int[] dfn = new int[n];</span><br><span class="line">            List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">            dfs(dfn, low, 0, -1, grah, res);</span><br><span class="line">            return res;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        int seq = 0;</span><br><span class="line">        void dfs(int[] dfn, int[] low, int cur, int parent, List&lt;Integer&gt;[] graph, List&lt;List&lt;Integer&gt;&gt; res) &#123;</span><br><span class="line">            if (dfn[cur] &gt; 0) return;</span><br><span class="line">            dfn[cur] = ++seq;</span><br><span class="line">            low[cur] = seq;</span><br><span class="line">            for (int neighbour : graph[cur]) &#123;</span><br><span class="line">                if (neighbour == parent) continue;</span><br><span class="line">                if (dfn[neighbour] == 0) dfs(dfn, low, neighbour, cur, graph, res);</span><br><span class="line">                low[cur] = Math.min(low[cur], low[neighbour]);</span><br><span class="line">            &#125;</span><br><span class="line">            if (cur != 0 &amp;&amp; low[cur] &gt; dfn[parent]) &#123;</span><br><span class="line">                res.add(Arrays.asList(parent, cur));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using dfs, Tarjin â€˜s bridge algorithm.</p>
<h3 id="200-Number-of-Islands"><a href="#200-Number-of-Islands" class="headerlink" title="200 Number of Islands"></a>200 Number of Islands</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    private int n,m;</span><br><span class="line">    public int numIslands(char[][] grid) &#123;</span><br><span class="line">        int count = 0;</span><br><span class="line">        n = grid.length;</span><br><span class="line">        if (n == 0) return 0;</span><br><span class="line">        m = grid[0].length;</span><br><span class="line">        for (int i = 0; i &lt; n; ++i)&#123;</span><br><span class="line">            for (int j = 0; j &lt; m; ++j)</span><br><span class="line">                if (grid[i][j] == &apos;1&apos;) &#123;</span><br><span class="line">                    DFSMarking(grid, i, j);</span><br><span class="line">                    ++count;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return count;</span><br><span class="line">    &#125;</span><br><span class="line">    private void DFSMarking(char[][] grid, int i, int j)&#123;</span><br><span class="line">        if (i &lt; 0 || j&lt;0 || i &gt;= n || j &gt;=m || grid[i][j] != &apos;1&apos;) return;</span><br><span class="line">        grid[i][j] = &apos;0&apos;;</span><br><span class="line">        DFSMarking(grid, i + 1, j);</span><br><span class="line">        DFSMarking(grid, i - 1, j);</span><br><span class="line">        DFSMarking(grid, i, j + 1);</span><br><span class="line">        DFSMarking(grid, i, j - 1);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using DFS, making every â€œ1â€ into â€œ0â€, so that we only meet every island once.</p>
<h3 id="146-LRU-Cache"><a href="#146-LRU-Cache" class="headerlink" title="146 LRU Cache"></a>146 LRU Cache</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line">class LRUCache &#123;</span><br><span class="line">    private class Node&#123;</span><br><span class="line">        int key, value;</span><br><span class="line">        Node prev, next;</span><br><span class="line">        Node (int k, int v)&#123;</span><br><span class="line">            this.key = k;</span><br><span class="line">            this.value = v;</span><br><span class="line">        &#125;</span><br><span class="line">        Node()&#123;</span><br><span class="line">            this(0, 0);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    private int capacity, count;</span><br><span class="line">    private Map&lt;Integer, Node&gt; map;</span><br><span class="line">    private Node head, tail;</span><br><span class="line">    </span><br><span class="line">    public LRUCache(int capacity) &#123;</span><br><span class="line">        this.capacity = capacity;</span><br><span class="line">        this.count = 0;</span><br><span class="line">        map = new HashMap&lt;&gt;();</span><br><span class="line">        head = new Node();</span><br><span class="line">        tail = new Node();</span><br><span class="line">        head.next = tail;</span><br><span class="line">        tail.prev = head;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int get(int key) &#123;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        if(n == null)&#123;</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        update(n);</span><br><span class="line">        return n.value;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void put(int key, int value)&#123;</span><br><span class="line">        Node n = map.get(key);</span><br><span class="line">        if(n == null)&#123;</span><br><span class="line">            n = new Node(key, value);</span><br><span class="line">            map.put(key, n);</span><br><span class="line">            add(n);</span><br><span class="line">            ++count;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            n.value = value;</span><br><span class="line">            update(n);</span><br><span class="line">        &#125;</span><br><span class="line">        if(count &gt; capacity)&#123;</span><br><span class="line">            Node toDel = tail.prev;</span><br><span class="line">            remove(toDel);</span><br><span class="line">            map.remove(toDel.key);</span><br><span class="line">            --count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void update(Node node)&#123;</span><br><span class="line">        remove(node);</span><br><span class="line">        add(node);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void add(Node node)&#123;</span><br><span class="line">        Node after = head.next;</span><br><span class="line">        head.next = node;</span><br><span class="line">        node.prev = head;</span><br><span class="line">        node.next = after;</span><br><span class="line">        after.prev = node;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private void remove(Node node)&#123;</span><br><span class="line">        Node before = node.prev, after = node.next;</span><br><span class="line">        before.next = after;</span><br><span class="line">        after.prev = before;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using hashmap and double linked list.</p>
]]></content>
      
        
        <tags>
            
            <tag> Amazon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 27]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/12/16/Everyday-Leetcode-27/</url>
      <content type="html"><![CDATA[<h3 id="173-Binary-Search-Tree-Iterator"><a href="#173-Binary-Search-Tree-Iterator" class="headerlink" title="173    Binary Search Tree Iterator"></a>173    Binary Search Tree Iterator</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">class BSTIterator &#123;</span><br><span class="line"></span><br><span class="line">    private Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span><br><span class="line">    </span><br><span class="line">    public BSTIterator(TreeNode root) &#123;</span><br><span class="line">        pushAll(root);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** @return the next smallest number */</span><br><span class="line">    public int next() &#123;</span><br><span class="line">        TreeNode temp = stack.pop();</span><br><span class="line">        pushAll(temp.right);</span><br><span class="line">        return temp.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /** @return whether we have a next smallest number */</span><br><span class="line">    public boolean hasNext() &#123;</span><br><span class="line">        return !stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void pushAll(TreeNode root)&#123;</span><br><span class="line">        while(root!=null)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Time complexity (next): average O(1). Using stack.</p>
<h3 id="230-Kth-Smallest-Element-in-a-BST"><a href="#230-Kth-Smallest-Element-in-a-BST" class="headerlink" title="230 Kth Smallest Element in a BST"></a>230 Kth Smallest Element in a BST</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">---- using Stack</span><br><span class="line">class Solution &#123;</span><br><span class="line">    private Stack&lt;TreeNode&gt; stack = new Stack&lt;TreeNode&gt;();</span><br><span class="line">    public int kthSmallest(TreeNode root, int k) &#123;</span><br><span class="line">        helper(root);</span><br><span class="line">        int ans = 0;</span><br><span class="line">        for(int i = 0; i &lt; k; ++i)&#123;</span><br><span class="line">            TreeNode temp = stack.pop();</span><br><span class="line">            helper(temp.right);</span><br><span class="line">            ans = temp.val;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public void helper(TreeNode root)&#123;</span><br><span class="line">        while(root != null)&#123;</span><br><span class="line">            stack.push(root);</span><br><span class="line">            root = root.left;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">---- DFS inorder recursive</span><br><span class="line">private static int number = 0;</span><br><span class="line">  private static int count = 0;</span><br><span class="line"></span><br><span class="line">  public int kthSmallest(TreeNode root, int k) &#123;</span><br><span class="line">      count = k;</span><br><span class="line">      helper(root);</span><br><span class="line">      return number;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public void helper(TreeNode n) &#123;</span><br><span class="line">      if (n.left != null) helper(n.left);</span><br><span class="line">      count--;</span><br><span class="line">      if (count == 0) &#123;</span><br><span class="line">          number = n.val;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      if (n.right != null) helper(n.right);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity: O(n) using DFS inorder recursive</p>
<h3 id="297-Serialize-and-Deserialize-Binary-Tree"><a href="#297-Serialize-and-Deserialize-Binary-Tree" class="headerlink" title="297 Serialize and Deserialize Binary Tree"></a>297 Serialize and Deserialize Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public String serialize(TreeNode root) &#123;</span><br><span class="line">       return serial(new StringBuilder(), root).toString();</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // Generate preorder string</span><br><span class="line">   private StringBuilder serial(StringBuilder str, TreeNode root) &#123;</span><br><span class="line">       if (root == null) return str.append(&quot;#&quot;);</span><br><span class="line">       str.append(root.val).append(&quot;,&quot;);</span><br><span class="line">       serial(str, root.left).append(&quot;,&quot;);</span><br><span class="line">       serial(str, root.right);</span><br><span class="line">       return str;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   public TreeNode deserialize(String data) &#123;</span><br><span class="line">       return deserial(new LinkedList&lt;&gt;(Arrays.asList(data.split(&quot;,&quot;))));</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   // Use queue to simplify position move</span><br><span class="line">   private TreeNode deserial(Queue&lt;String&gt; q) &#123;</span><br><span class="line">       String val = q.poll();</span><br><span class="line">       if (&quot;#&quot;.equals(val)) return null;</span><br><span class="line">       TreeNode root = new TreeNode(Integer.valueOf(val));</span><br><span class="line">       root.left = deserial(q);</span><br><span class="line">       root.right = deserial(q);</span><br><span class="line">       return root;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>DFS recursive. Time complexity is O(n);</p>
<h3 id="285-Inorder-Successor-in-BST"><a href="#285-Inorder-Successor-in-BST" class="headerlink" title="285    Inorder Successor in BST"></a>285    Inorder Successor in BST</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"> public TreeNode inorderSuccessor(TreeNode root, TreeNode p) &#123;</span><br><span class="line">  if (root == null)</span><br><span class="line">    return null;</span><br><span class="line"></span><br><span class="line">  if (root.val &lt;= p.val) &#123;</span><br><span class="line">    return inorderSuccessor(root.right, p);</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    TreeNode left = inorderSuccessor(root.left, p);</span><br><span class="line">    return (left != null) ? left : root;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>inorder recursive. Time Complexity: O(h)</p>
<h3 id="270-Closest-Binary-Search-Tree-Value"><a href="#270-Closest-Binary-Search-Tree-Value" class="headerlink" title="270    Closest Binary Search Tree Value"></a>270    Closest Binary Search Tree Value</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int closestValue(TreeNode root, double target) &#123;</span><br><span class="line">   int ret = root.val;   </span><br><span class="line">   while(root != null)&#123;</span><br><span class="line">       if(Math.abs(target - root.val) &lt; Math.abs(target - ret))&#123;</span><br><span class="line">           ret = root.val;</span><br><span class="line">       &#125;      </span><br><span class="line">       root = root.val &gt; target? root.left: root.right;</span><br><span class="line">   &#125;     </span><br><span class="line">   return ret;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>iterative. Time Complexity:O(h)</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 26]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/12/02/Everyday-Leetcode-26/</url>
      <content type="html"><![CDATA[<h3 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110 Balanced Binary Tree"></a>110 Balanced Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">      if (root == null)</span><br><span class="line">          return true;</span><br><span class="line">      return helper(root)!= -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int helper(TreeNode root)&#123;</span><br><span class="line">        if (root == null)</span><br><span class="line">            return 0;</span><br><span class="line">        int left = helper(root.left);</span><br><span class="line">        int right = helper(root.right);</span><br><span class="line">        if( left == -1 || right == -1 || Math.abs(left-right)&gt;1)</span><br><span class="line">            return -1;</span><br><span class="line">        return Math.max(left,right)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity:O(n) using DFS<br><a id="more"></a></p>
<h3 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235 Lowest Common Ancestor of a Binary Search Tree"></a>235 Lowest Common Ancestor of a Binary Search Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">--- iterative version</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">     if((root == null) || (p == null) || (q == null))  &#123;</span><br><span class="line">         return null;</span><br><span class="line">     &#125; </span><br><span class="line">     while(true)&#123;</span><br><span class="line">        if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            root = root.left ;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">            return root;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- recursive version</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if((root == null) || (p == null) || (q == null))  &#123;</span><br><span class="line">         return null;</span><br><span class="line">     &#125; </span><br><span class="line">     while(true)&#123;</span><br><span class="line">        if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            return lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            return lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">            return root;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity : O(n)<br>Both uses BSTâ€™s property to locate LCA. p,qâ€™s LCA must be larger than </p>
<h3 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236 Lowest Common Ancestor of a Binary Tree"></a>236 Lowest Common Ancestor of a Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (root == null || p == root || q == root) return root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p , q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        if(left != null &amp;&amp; right != null) return root;</span><br><span class="line">        return left != null ? left: right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="108-Convert-Sorted-Array-to-Binary-Search-tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-tree" class="headerlink" title="108 Convert Sorted Array to Binary Search tree"></a>108 Convert Sorted Array to Binary Search tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedArrayToBST(int[] nums) &#123;</span><br><span class="line">        if(nums == null || nums.length == 0) return null;</span><br><span class="line">        return helper(nums, 0, nums.length - 1); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public TreeNode helper(int[] nums, int low, int high)&#123;</span><br><span class="line">        if (low &gt; high) return null;</span><br><span class="line">        </span><br><span class="line">        int mid = low + (high-low)/2;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = new TreeNode(nums[mid]);</span><br><span class="line">        </span><br><span class="line">        root.left = helper(nums, low , mid - 1);</span><br><span class="line">        </span><br><span class="line">        root.right = helper(nums, mid + 1, high);</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity : O(n).  using low + (high-low)/2 instead of (low+high)/2 to avoid big integer overflow.<br>Space Complexity : O(logn)</p>
<h3 id="109-Convert-Sorted-List-to-Binary-Search-tree"><a href="#109-Convert-Sorted-List-to-Binary-Search-tree" class="headerlink" title="109 Convert Sorted List to Binary Search tree"></a>109 Convert Sorted List to Binary Search tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">    public TreeNode sortedListToBST(ListNode head)&#123;</span><br><span class="line">      return helper(head, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public TreeNode helper(ListNode head, ListNode tail)&#123;</span><br><span class="line">        if (head == null || head == tail) return null;</span><br><span class="line">        if (head.next == tail) return new TreeNode(head.val);</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        while( fast != tail &amp;&amp; fast.next != tail)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = new TreeNode(slow.val);</span><br><span class="line">        root.left = helper(head, slow);</span><br><span class="line">        root.right = helper(slow.next, tail);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity : O(nlogn). </p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 25]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/10/24/Everyday-Leetcode-25/</url>
      <content type="html"><![CDATA[<h3 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113    Path Sum II"></a>113    Path Sum II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt;ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); </span><br><span class="line">    List&lt;Integer&gt; cur = new ArrayList&lt;Integer&gt;(); </span><br><span class="line">    pathSum(root, sum, cur, ret);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void pathSum(TreeNode root, int sum, List&lt;Integer&gt;cur, List&lt;List&lt;Integer&gt;&gt;ret)&#123;</span><br><span class="line">    if (root == null)&#123;</span><br><span class="line">        return; </span><br><span class="line">    &#125;</span><br><span class="line">    cur.add(root.val);</span><br><span class="line">    if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum)&#123;</span><br><span class="line">        ret.add(new ArrayList(cur));</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        pathSum(root.left, sum - root.val, cur, ret);</span><br><span class="line">        pathSum(root.right, sum - root.val, cur, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    cur.remove(cur.size()-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Using ArrayList to save the result, if find pathsum, add to the ret. Test.</p>
<h3 id="129-Sum-Root-to-Leaf-Numbers"><a href="#129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="129    Sum Root to Leaf Numbers"></a>129    Sum Root to Leaf Numbers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int sumNumbers(TreeNode root) &#123;</span><br><span class="line">	return sum(root, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int sum(TreeNode n, int s)&#123;</span><br><span class="line">	if (n == null) return 0;</span><br><span class="line">	if (n.right == null &amp;&amp; n.left == null) return s*10 + n.val;</span><br><span class="line">	return sum(n.left, s*10 + n.val) + sum(n.right, s*10 + n.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Everytime we should return result * 10 plus the value of node, then we do the recursion.</p>
<h3 id="298-Binary-Tree-Longest-Consecutive-Sequence"><a href="#298-Binary-Tree-Longest-Consecutive-Sequence" class="headerlink" title="298    Binary Tree Longest Consecutive Sequence"></a>298    Binary Tree Longest Consecutive Sequence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int max = 0;</span><br><span class="line">    public int longestConsecutive(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        helper(root, 0, root.val);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void helper(TreeNode root, int cur, int target)&#123;</span><br><span class="line">        if(root == null) return;</span><br><span class="line">        if(root.val == target) cur++;</span><br><span class="line">        else cur = 1;</span><br><span class="line">        max = Math.max(cur, max);</span><br><span class="line">        helper(root.left, cur, root.val + 1);</span><br><span class="line">        helper(root.right, cur, root.val + 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>using private variable max to save the maximum result of longest Consecutive.</p>
<h3 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111    Minimum Depth of Binary Tree"></a>111    Minimum Depth of Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public static int minDepth(TreeNode root) &#123;</span><br><span class="line">	if (root == null)	return 0;</span><br><span class="line">	if (root.left == null)	return minDepth(root.right) + 1;</span><br><span class="line">	if (root.right == null) return minDepth(root.left) + 1;</span><br><span class="line">	return Math.min(minDepth(root.left),minDepth(root.right)) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using DFS.</p>
<h3 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104    Maximum Depth of Binary Tree"></a>104    Maximum Depth of Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        return root==null? 0 : Math.max(maxDepth(root.left), maxDepth(root.right))+1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>using DFS.</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 24]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/10/19/Everyday-Leetcode-24/</url>
      <content type="html"><![CDATA[<h3 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100    Same Tree"></a>100    Same Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (p == null || q == null) return p == q;</span><br><span class="line">   return p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>recursion way, easy.</p>
<h3 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101    Symmetric Tree"></a>101    Symmetric Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        if(root==null) return true;</span><br><span class="line">        return isMirror(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public boolean isMirror(TreeNode l, TreeNode r) &#123;</span><br><span class="line">        if (l==null || r==null) return l==r;</span><br><span class="line">        return (l.val==r.val) &amp;&amp; isMirror(l.left,r.right) &amp;&amp; isMirror(l.right,r.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">    if (root == null) return true;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    stack.push(root.left);</span><br><span class="line">    stack.push(root.right);</span><br><span class="line">    while (!stack.empty()) &#123;</span><br><span class="line">        TreeNode n1 = stack.pop(), n2 = stack.pop();</span><br><span class="line">        if (n1 == null &amp;&amp; n2 == null) continue;</span><br><span class="line">        if (n1 == null || n2 == null || n1.val != n2.val) return false;</span><br><span class="line">        stack.push(n1.left);</span><br><span class="line">        stack.push(n2.right);</span><br><span class="line">        stack.push(n1.right);</span><br><span class="line">        stack.push(n2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   Recursion way is easy. For iteration, I use stack.</p>
<h3 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226    Invert Binary Tree"></a>226    Invert Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">      if(root == null) return root;</span><br><span class="line">      invertTree(root.left);</span><br><span class="line">      invertTree(root.right);</span><br><span class="line">      TreeNode temp =root.left;</span><br><span class="line">      root.left=root.right;</span><br><span class="line">      root.right=temp;</span><br><span class="line">      return root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">       if (root == null) return null;</span><br><span class="line"></span><br><span class="line">      Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">      queue.offer(root);</span><br><span class="line"></span><br><span class="line">      while(!queue.isEmpty()) &#123;</span><br><span class="line">           TreeNode node = queue.poll();</span><br><span class="line">           TreeNode left = node.left;</span><br><span class="line">          node.left = node.right;</span><br><span class="line">          node.right = left;</span><br><span class="line"></span><br><span class="line">          if(node.left != null) &#123;</span><br><span class="line">              queue.offer(node.left);</span><br><span class="line">          &#125;</span><br><span class="line">          if(node.right != null) &#123;</span><br><span class="line">              queue.offer(node.right);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return root;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Recursion way is easy. For iteration, I use queue.</p>
<h3 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257    Binary Tree Paths"></a>257    Binary Tree Paths</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">      List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">      StringBuilder sb = new StringBuilder();</span><br><span class="line">      helper(res, root, sb);</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private void helper(List&lt;String&gt; res, TreeNode root, StringBuilder sb) &#123;</span><br><span class="line">      if(root == null) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      int len = sb.length();</span><br><span class="line">      sb.append(root.val);</span><br><span class="line">      if(root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">          res.add(sb.toString());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          sb.append(&quot;-&gt;&quot;);</span><br><span class="line">          helper(res, root.left, sb);</span><br><span class="line">          helper(res, root.right, sb);</span><br><span class="line">      &#125;</span><br><span class="line">      sb.setLength(len);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Track of the length of the StringBuilder before we append anything to it before recursion and afterwards set the length back.</p>
<h3 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112    Path Sum"></a>112    Path Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasPathSum(TreeNode root, int sum) &#123;</span><br><span class="line">        if(root == null) return false;</span><br><span class="line"></span><br><span class="line">       if(root.left == null &amp;&amp; root.right == null) return sum == root.val;</span><br><span class="line"></span><br><span class="line">       return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Rucursion way is easy. Just try to use  sum-root.val to  get the PathSum.</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 23]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/09/10/Everyday-Leetcode-23/</url>
      <content type="html"><![CDATA[<h3 id="367-Valid-Perfect-Square"><a href="#367-Valid-Perfect-Square" class="headerlink" title="367    Valid Perfect Square"></a>367    Valid Perfect Square</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPerfectSquare(int num) &#123;</span><br><span class="line">       if (num==1) return true;</span><br><span class="line">    else if(num&lt;2) return true;</span><br><span class="line">       else </span><br><span class="line">    &#123;</span><br><span class="line">           long low=1,high=num;</span><br><span class="line">           long mid,prod;</span><br><span class="line">           while(low&lt;high)</span><br><span class="line">           &#123;</span><br><span class="line">                mid=(low+high)/2;</span><br><span class="line">               prod=mid*mid;</span><br><span class="line">               if(prod==(long)num) return true;</span><br><span class="line">               else if (prod&lt;(long)num)&#123;</span><br><span class="line">                   low=mid+1;</span><br><span class="line">               &#125;else high=mid-1;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">        if (low==high) return (low*low==(long)num);</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>åŸºæœ¬äºŒåˆ†æŸ¥æ‰¾</p>
<h3 id="365-Water-and-Jug-Problem"><a href="#365-Water-and-Jug-Problem" class="headerlink" title="365    Water and Jug Problem"></a>365    Water and Jug Problem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean canMeasureWater(int x, int y, int z) &#123;</span><br><span class="line">        if(z == 0) return true;</span><br><span class="line">        if(x + y &lt; z)</span><br><span class="line">            return false;</span><br><span class="line">        return (z%gcd(x, y)==0);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public int gcd(int x, int y)&#123;</span><br><span class="line">        if (y==0) return x;</span><br><span class="line">            return gcd(y,x%y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>å¦‚æžœx,yçš„æœ€å¤§å…¬çº¦æ•°èƒ½è¢«zæ•´é™¤ï¼Œåˆ™å¯ä»¥ã€‚</p>
<h3 id="204-Count-Primes"><a href="#204-Count-Primes" class="headerlink" title="204    Count Primes"></a>204    Count Primes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int countPrimes(int n) &#123;</span><br><span class="line">        if(n &lt;=1 ) return 0;</span><br><span class="line">    </span><br><span class="line">    boolean[] notPrime = new boolean[n];        </span><br><span class="line">    notPrime[0] = true; </span><br><span class="line">    notPrime[1] = true; </span><br><span class="line"></span><br><span class="line">    for(int i = 2; i &lt; Math.sqrt(n); i++)&#123;</span><br><span class="line">        if(!notPrime[i])&#123;</span><br><span class="line">            for(int j = 2; j*i &lt; n; j++)&#123;</span><br><span class="line">                notPrime[i*j] = true; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int count = 0; </span><br><span class="line">    for(int i = 2; i&lt; notPrime.length; i++)&#123;</span><br><span class="line">        if(!notPrime[i]) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    return count; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>using a cache to store the prime count, improve the performance.</p>
<h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1    Two Sum"></a>1    Two Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; ans= new HashMap&lt;&gt;();</span><br><span class="line">       for (int i=0; i&lt;nums.length;i++)&#123;</span><br><span class="line">         int diff=target-nums[i];</span><br><span class="line">             if (ans.containsKey(diff))</span><br><span class="line">             &#123;</span><br><span class="line">                 </span><br><span class="line">                 return new int[]&#123;ans.get(diff),i&#125;;</span><br><span class="line">             &#125;</span><br><span class="line">           ans.put(nums[i],i);</span><br><span class="line">         </span><br><span class="line">   &#125;</span><br><span class="line">       return new int[]&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>using one-pass hashmap.</p>
<h3 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="167    Two Sum II - Input array is sorted"></a>167    Two Sum II - Input array is sorted</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">      int start = 0, end = numbers.length - 1;</span><br><span class="line">        while(start &lt; end)&#123;</span><br><span class="line">            if(numbers[start] + numbers[end] == target) break;</span><br><span class="line">            if(numbers[start] + numbers[end] &lt; target) start++;</span><br><span class="line">            else end--;</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[]&#123;start + 1, end + 1&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>search from both start and end , using two int as a pointer.</p>
<h3 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15    3Sum"></a>15    3Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> Arrays.sort(num);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); </span><br><span class="line">for (int i = 0; i &lt; num.length-2; i++) &#123;</span><br><span class="line">    if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) &#123;</span><br><span class="line">        int lo = i+1, hi = num.length-1, sum = 0 - num[i];</span><br><span class="line">        while (lo &lt; hi) &#123;</span><br><span class="line">            if (num[lo] + num[hi] == sum) &#123;</span><br><span class="line">                res.add(Arrays.asList(num[i], num[lo], num[hi]));</span><br><span class="line">                while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++;</span><br><span class="line">                while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--;</span><br><span class="line">                lo++; hi--;</span><br><span class="line">            &#125; else if (num[lo] + num[hi] &lt; sum) &#123;</span><br><span class="line">                // improve: skip duplicates</span><br><span class="line">                while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // improve: skip duplicates</span><br><span class="line">                while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br></pre></td></tr></table></figure>
<p>First, sort the array. Second, using one for loop and a while loop inside the for loop. In the while loop, using high and low to do the 2sum. And using serveral while loops to move the pointers.</p>
<h3 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18    4Sum"></a>18    4Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=new LinkedList&lt;&gt;();</span><br><span class="line">        if(nums.length&lt;4) return res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for(int i=0;i&lt;nums.length-3;i++)&#123;</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue;</span><br><span class="line">            </span><br><span class="line">            if(nums[i]*4&gt;target) break;// Too Big!!</span><br><span class="line">            if(nums[i]+3*nums[nums.length-1]&lt;target) continue;//Too Small</span><br><span class="line">            </span><br><span class="line">            for(int j=i+1;j&lt;nums.length-2;j++)&#123;</span><br><span class="line">                if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1]) continue;</span><br><span class="line">                </span><br><span class="line">                if(nums[j]*3&gt;target-nums[i]) break;//Too Big</span><br><span class="line">                if(nums[j]+2*nums[nums.length-1]&lt;target-nums[i]) continue;// Too Small</span><br><span class="line">                </span><br><span class="line">                int begin=j+1;</span><br><span class="line">                int end=nums.length-1;</span><br><span class="line">                while(begin&lt;end)&#123;</span><br><span class="line">                    int sum=nums[i]+nums[j]+nums[begin]+nums[end];</span><br><span class="line">                    if(sum==target)&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i],nums[j],nums[begin],nums[end]));</span><br><span class="line">                        while(begin&lt;end &amp;&amp; nums[begin]==nums[begin+1])&#123;begin++;&#125;</span><br><span class="line">                        while(begin&lt;end &amp;&amp; nums[end]==nums[end-1])&#123;end--;&#125;</span><br><span class="line">                        begin++;</span><br><span class="line">                        end--;</span><br><span class="line">                    &#125;else if (sum&lt;target)&#123;</span><br><span class="line">                        begin++;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        end--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Same as 3sum and 2sum, the difference is  we have to judge two samll or two beg. and using 2 for loop and a while loop. Also using begin end.</p>
<h3 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144    Binary Tree Preorder Traversal"></a>144    Binary Tree Preorder Traversal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">		List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;();</span><br><span class="line">		preHelper(root,pre);</span><br><span class="line">		return pre;</span><br><span class="line">	&#125;</span><br><span class="line">	public void preHelper(TreeNode root, List&lt;Integer&gt; pre) &#123;</span><br><span class="line">		if(root==null) return;</span><br><span class="line">		pre.add(root.val);</span><br><span class="line">		preHelper(root.left,pre);</span><br><span class="line">		preHelper(root.right,pre);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>using helper function, so that we dont have to initiate a new List at each recursion</p>
<h3 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94    Binary Tree Inorder Traversal"></a>94    Binary Tree Inorder Traversal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">       </span><br><span class="line">	List&lt;Integer&gt; in = new LinkedList&lt;Integer&gt;();</span><br><span class="line">	inHelper(root,in);</span><br><span class="line">	return in;</span><br><span class="line">&#125;</span><br><span class="line">public void inHelper(TreeNode root, List&lt;Integer&gt; in) &#123;</span><br><span class="line">	if(root==null) return;</span><br><span class="line">	inHelper(root.left,in);</span><br><span class="line">       in.add(root.val);</span><br><span class="line">	inHelper(root.right,in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>same</p>
<h3 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145    Binary Tree Postorder Traversal"></a>145    Binary Tree Postorder Traversal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();</span><br><span class="line">Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">if (root == null) return ans;</span><br><span class="line"></span><br><span class="line">stack.push(root);</span><br><span class="line">while (!stack.isEmpty()) &#123;</span><br><span class="line">	TreeNode cur = stack.pop();</span><br><span class="line">	ans.addFirst(cur.val);</span><br><span class="line">	if (cur.left != null) &#123;</span><br><span class="line">		stack.push(cur.left);</span><br><span class="line">	&#125;</span><br><span class="line">	if (cur.right != null) &#123;</span><br><span class="line">		stack.push(cur.right);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>No recursion version. using linkedlist and stack. Because insertion is O(1) in LinkedList, and itâ€™s O(n) in ArrayList. </p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 22]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/08/02/Everyday-Leetcode-22/</url>
      <content type="html"><![CDATA[<h3 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="67    Add Binary"></a>67    Add Binary</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public String addBinary(String a, String b) &#123;</span><br><span class="line">      StringBuilder sb = new StringBuilder();</span><br><span class="line">        int i=a.length()-1, j=b.length()-1, memo=0;</span><br><span class="line">        while(j&gt;=0 || i&gt;=0)&#123;</span><br><span class="line">        int sum= memo;</span><br><span class="line">        if(i&gt;=0) sum+= a.charAt(i--)-&apos;0&apos;;</span><br><span class="line">        if(j&gt;=0) sum+= b.charAt(j--)-&apos;0&apos;;</span><br><span class="line">        memo=sum/2;</span><br><span class="line">        sb.append(sum%2);</span><br><span class="line">        &#125;</span><br><span class="line">        if(memo!=0) sb.append(memo);</span><br><span class="line">        return sb.reverse().toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ä»Žå³å¾€å·¦è®¡ç®—ï¼Œæ¯ä¸€ä½ç®—å‡ºå½“å‰ä½çš„å’Œå†å¯¹2å–ä½™ï¼Œå°±æ˜¯è¿™ä¸€ä½çš„ç»“æžœï¼Œæœ€åŽæŠŠç¬¬ä¸€ä½çš„ç»“æžœåŠ å…¥åˆ°StringBuilderå†åå‘è¾“å‡ºã€‚<br><a id="more"></a></p>
<h3 id="43-Multiply-Strings"><a href="#43-Multiply-Strings" class="headerlink" title="43    Multiply Strings"></a>43    Multiply Strings</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public String multiply(String num1, String num2) &#123;</span><br><span class="line">      int n=num1.length(), m=num2.length();</span><br><span class="line">      int[] pos= new int[m + n];</span><br><span class="line">      if(num1.length()==0 ||num2.length()==0) return &quot;0&quot;;</span><br><span class="line">        for(int i=n-1;i&gt;=0;i--)</span><br><span class="line">            for(int j=m-1;j&gt;=0;j--)&#123;</span><br><span class="line">                int res=(num1.charAt(i)-&apos;0&apos;)* (num2.charAt(j)-&apos;0&apos;);</span><br><span class="line">                int p1=i+j, p2=i+j+1;</span><br><span class="line">                int sum= res+=pos[p2];</span><br><span class="line">                pos[p1]+=sum/10;</span><br><span class="line">                pos[p2]=(sum)%10;</span><br><span class="line">            &#125;</span><br><span class="line">         StringBuilder sb = new StringBuilder();</span><br><span class="line">    for(int p : pos) if(!(sb.length() == 0 &amp;&amp; p == 0)) sb.append(p);</span><br><span class="line">    return sb.length() == 0 ? &quot;0&quot; : sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>è®¡ç®—æ¯ä¸€ä½çš„ç»“æžœå¹¶å°†è¿›ä½çš„ç»“æžœæ¯æ¬¡éƒ½ç´¯åŠ ã€‚</p>
<h3 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29    Divide Two Integers"></a>29    Divide Two Integers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int divide(int dividend, int divisor) &#123;       </span><br><span class="line">      if(dividend ==  Integer.MIN_VALUE &amp;&amp; divisor == -1)&#123;</span><br><span class="line">          return Integer.MAX_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      boolean isNeg = (dividend &lt; 0) ^ (divisor &lt; 0);</span><br><span class="line">      if(dividend &gt; 0) dividend = -dividend;</span><br><span class="line">      if(divisor &gt; 0) divisor = -divisor;</span><br><span class="line">         </span><br><span class="line">      return isNeg? -div(dividend, divisor) : div(dividend, divisor);</span><br><span class="line">  &#125;</span><br><span class="line">  public int div(int divid, int divis)&#123;</span><br><span class="line">      if(divid &gt; divis) return 0;</span><br><span class="line">      int curSum = divis &lt;&lt; 1, prevSum = divis, q = 1;</span><br><span class="line">      </span><br><span class="line">      while(divid &lt;= curSum &amp;&amp; curSum &lt; prevSum)&#123;</span><br><span class="line">          prevSum = curSum;</span><br><span class="line">          curSum &lt;&lt;= 1; q &lt;&lt;= 1;</span><br><span class="line">      &#125;</span><br><span class="line">      return q + div(divid - prevSum, divis);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>æ¯æ¬¡å°†divisorÃ—2ï¼Œå¦‚æžœå¤§äºŽdividendå°±è¿”å›žä¹‹å‰çš„ç»“æžœ+å·®çš„ç»“æžœã€‚</p>
<h3 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69    Sqrt(x)"></a>69    Sqrt(x)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int mySqrt(int x) &#123;</span><br><span class="line">      int i = 1;</span><br><span class="line">      int j = x;</span><br><span class="line">      int ans = 0;</span><br><span class="line">      while (i &lt;=j)&#123;</span><br><span class="line">          int mid = i + (j-i)/2;</span><br><span class="line">          if (mid &lt;= x/mid)&#123;</span><br><span class="line">              i = mid +1;</span><br><span class="line">              ans = mid;</span><br><span class="line">          &#125;</span><br><span class="line">          else</span><br><span class="line">              j = mid-1;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      return ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>äºŒåˆ†æ³•ï¼Œå½“iå°äºŽjçš„æ—¶å€™ï¼Œæ¯æ¬¡midéƒ½=å·¦æŒ‡é’ˆ+å·¦å³æŒ‡é’ˆè·ç¦»çš„çš„1/2ï¼Œæ‰¾åˆ°æœ€æŽ¥è¿‘xçš„n*nã€‚</p>
<h3 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50    Pow(x, n)"></a>50    Pow(x, n)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public double myPow(double x, int n) &#123;</span><br><span class="line">       if(n == 0)</span><br><span class="line">           return 1;</span><br><span class="line">       if(n&lt;0)&#123;</span><br><span class="line">           if(n == Integer.MIN_VALUE) &#123;</span><br><span class="line">           n += 2;</span><br><span class="line">       &#125;</span><br><span class="line">       n = -n;</span><br><span class="line">       x = 1/x;</span><br><span class="line">       &#125;</span><br><span class="line">       return (n%2 == 0) ? myPow(x*x, n/2) : x*myPow(x*x, n/2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>æ¯æ¬¡éƒ½é€’å½’è°ƒç”¨è‡ªèº« næ¯æ¬¡/2ï¼Œè¦æ³¨æ„MIN_VALUEçš„æƒ…å†µä¼šæº¢å‡ºï¼Œæ‰€ä»¥n+=2ã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 21]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/07/25/Everyday-Leetcode-21/</url>
      <content type="html"><![CDATA[<h3 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7    Reverse Integer"></a>7    Reverse Integer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int reverse(int x) &#123;</span><br><span class="line">          long rev= 0;</span><br><span class="line">        while( x != 0)&#123;</span><br><span class="line">            rev= rev*10 + x % 10;</span><br><span class="line">            x= x/10;</span><br><span class="line">            if( rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE)</span><br><span class="line">                return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) rev;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>æ¯æ¬¡å°†æœ€åŽä¸€ä½*10+ä¹‹å‰çš„ä¸€ä½ã€‚</p>
<h3 id="165-Compare-Version-Numbers"><a href="#165-Compare-Version-Numbers" class="headerlink" title="165    Compare Version Numbers"></a>165    Compare Version Numbers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int compareVersion(String version1, String version2) &#123;</span><br><span class="line">   String[] levels1 = version1.split(&quot;\\.&quot;);</span><br><span class="line">   String[] levels2 = version2.split(&quot;\\.&quot;);</span><br><span class="line">   </span><br><span class="line">   int length = Math.max(levels1.length, levels2.length);</span><br><span class="line">   for (int i=0; i&lt;length; i++) &#123;</span><br><span class="line">   	Integer v1 = i &lt; levels1.length ? Integer.parseInt(levels1[i]) : 0;</span><br><span class="line">   	Integer v2 = i &lt; levels2.length ? Integer.parseInt(levels2[i]) : 0;</span><br><span class="line">   	int compare = v1.compareTo(v2);</span><br><span class="line">   	if (compare != 0) &#123;</span><br><span class="line">   		return compare;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆæŠŠ.åŽ»æŽ‰ï¼Œå–ä¸¤ä¸ªå­—ç¬¦ä¸²ä¸­æœ€å¤§çš„é•¿åº¦ï¼Œç„¶åŽé€ä½æ¯”è¾ƒã€‚</p>
<h3 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66    Plus One"></a>66    Plus One</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> public int[] plusOne(int[] digits) &#123;</span><br><span class="line">        int n = digits.length;</span><br><span class="line">        for (int i = digits.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            if (digits[i] &lt; 9) &#123;</span><br><span class="line">                ++digits[i];</span><br><span class="line">                return digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res = new int[n + 1];</span><br><span class="line">        res[0] = 1;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>å¦‚æžœè¯¥ä½å°äºŽ9å°±+1è¿”å›žï¼Œå¦åˆ™=0.è¿™æ ·å¯ä»¥å®Œæˆè¿›ä½ã€‚</p>
<h3 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8    String to Integer (atoi)"></a>8    String to Integer (atoi)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> public int myAtoi(String str) &#123;</span><br><span class="line">	if (str.isEmpty())</span><br><span class="line">		return 0;</span><br><span class="line">	str = str.trim();</span><br><span class="line">      if (str.isEmpty())</span><br><span class="line">		return 0;</span><br><span class="line">	int i = 0, ans = 0, sign = 1, len = str.length();</span><br><span class="line">	if (str.charAt(i) == &apos;-&apos; || str.charAt(i) == &apos;+&apos;)</span><br><span class="line">		sign = str.charAt(i++) == &apos;+&apos; ? 1 : -1;</span><br><span class="line">	for (; i &lt; len; ++i) &#123;</span><br><span class="line">		int tmp = str.charAt(i) - &apos;0&apos;;</span><br><span class="line">		if (tmp &lt; 0 || tmp &gt; 9)</span><br><span class="line">			break;</span><br><span class="line">		if (ans &gt; Integer.MAX_VALUE / 10</span><br><span class="line">				|| (ans == Integer.MAX_VALUE / 10 &amp;&amp; Integer.MAX_VALUE % 10 &lt; tmp))</span><br><span class="line">			return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">		else</span><br><span class="line">			ans = ans * 10 + tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	return sign * ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆï¼Œhandleç©ºå­—ä¸²ï¼ŒåŽ»æŽ‰ç©ºæ ¼åŽå†handleï¼Œå¦åˆ™ä¼šè¶Šç•Œã€‚åŽé¢å½“ansè¶Šç•Œæ—¶è¿”å›žæ­£æ— ç©·æˆ–è´Ÿæ— ç©·ã€‚ansæ¯æ¬¡*10å†åŠ ä¸Štmpã€‚</p>
<h3 id="258-Add-Digits"><a href="#258-Add-Digits" class="headerlink" title="258    Add Digits"></a>258    Add Digits</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int addDigits(int num) &#123;</span><br><span class="line">        return (num!=0 &amp;&amp; num%9==0) ? 9 : num%9;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>è¿”å›ž9æˆ–å¯¹9å–ä½™çš„ç»“æžœå³å¯ã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 20]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/07/22/Everyday-Leetcode-20/</url>
      <content type="html"><![CDATA[<h3 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32    Longest Valid Parentheses"></a>32    Longest Valid Parentheses</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int longestValidParentheses(String s) &#123;</span><br><span class="line">    char[] S = s.toCharArray();</span><br><span class="line">    int[] V = new int[S.length];</span><br><span class="line">    int open = 0;</span><br><span class="line">    int max = 0;</span><br><span class="line">    for (int i=0; i&lt;S.length; i++) &#123;</span><br><span class="line">        if (S[i] == &apos;(&apos;) open++;</span><br><span class="line">        if (S[i] == &apos;)&apos; &amp;&amp; open &gt; 0) &#123;</span><br><span class="line">            // matches found</span><br><span class="line">            V[i] = 2+ V[i-1];</span><br><span class="line">            // add matches from previous</span><br><span class="line">            if(i-V[i]&gt;0)</span><br><span class="line">                V[i] += V[i-V[i]];</span><br><span class="line">            open--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (V[i] &gt; max) max = V[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>dp,çŠ¶æ€æ–¹ç¨‹å¼ä¸ºV[i] = 2+ V[i-1]+ previous matches V[i- (V[i-1] + 2) ] if S[i] = â€˜)â€™ and â€˜(â€˜ count &gt; 0ã€‚</p>
<h3 id="241-Different-Ways-to-Add-Parentheses"><a href="#241-Different-Ways-to-Add-Parentheses" class="headerlink" title="241    Different Ways to Add Parentheses"></a>241    Different Ways to Add Parentheses</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String,List&lt;Integer&gt;&gt; memo = new HashMap&lt;&gt;();</span><br><span class="line">   public List&lt;Integer&gt; diffWaysToCompute(String input) &#123;</span><br><span class="line">       int len = input.length();</span><br><span class="line">       List&lt;Integer&gt; result = memo.get(input);</span><br><span class="line">       if (result != null) &#123; return result; &#125;</span><br><span class="line">       result = new ArrayList&lt;&gt;();</span><br><span class="line">       if (isDigit(input)) &#123;</span><br><span class="line">           result.add(Integer.parseInt(input));</span><br><span class="line">           memo.put(input,result);</span><br><span class="line">           return result;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">           char c = input.charAt(i);</span><br><span class="line">           if (c == &apos;+&apos; || c == &apos;-&apos; || c == &apos;*&apos;) &#123;</span><br><span class="line">               List&lt;Integer&gt; left = diffWaysToCompute(input.substring(0,i));</span><br><span class="line">               List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i+1,len));</span><br><span class="line">               for (Integer il : left) &#123;</span><br><span class="line">                   for (Integer ir : right) &#123;</span><br><span class="line">                       switch (c) &#123;</span><br><span class="line">                           case &apos;+&apos;: result.add(il + ir); break;</span><br><span class="line">                           case &apos;-&apos;: result.add(il - ir); break;</span><br><span class="line">                           case &apos;*&apos;: result.add(il * ir); break;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       memo.put(input,result);</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br><span class="line">   private boolean isDigit(String s) &#123;</span><br><span class="line">       for (Character c : s.toCharArray()) &#123;</span><br><span class="line">           if (!Character.isDigit(c)) &#123; return false; &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆç»´æŠ¤ä¸€ä¸ªprivateçš„hashmapç”¨æ¥å‚¨å­˜ã€‚å¦‚æžœå·²ç»æœ‰ç»“æžœç›´æŽ¥è¿”å›žï¼Œå¦‚æžœæ˜¯æ•°å­—ï¼Œç›´æŽ¥åŠ å…¥åˆ°memoå¹¶è¿”å›žã€‚éåŽ†å­—ç¬¦ï¼Œå°†å·¦è¾¹çš„å’Œå³è¾¹çš„éƒ½é€’å½’è°ƒç”¨è‡ªèº«è¿”å›žç»“æžœï¼Œç„¶åŽæ ¹æ®å½“å‰ç¬¦å·è®¡ç®—ï¼Œæœ€åŽä¿å­˜ç»“æžœåˆ°hashmapã€‚</p>
<h3 id="301-Remove-Invalid-Parentheses"><a href="#301-Remove-Invalid-Parentheses" class="headerlink" title="301    Remove Invalid Parentheses"></a>301    Remove Invalid Parentheses</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; removeInvalidParentheses(String s) &#123;</span><br><span class="line">    List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    remove(s, ans, 0, 0, new char[]&#123;&apos;(&apos;, &apos;)&apos;&#125;);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void remove(String s, List&lt;String&gt; ans, int last_i, int last_j,  char[] par) &#123;</span><br><span class="line">    for (int stack = 0, i = last_i; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        if (s.charAt(i) == par[0]) stack++;</span><br><span class="line">        if (s.charAt(i) == par[1]) stack--;</span><br><span class="line">        if (stack &gt;= 0) continue;</span><br><span class="line">        for (int j = last_j; j &lt;= i; ++j)</span><br><span class="line">            if (s.charAt(j) == par[1] &amp;&amp; (j == last_j || s.charAt(j - 1) != par[1]))</span><br><span class="line">                remove(s.substring(0, j) + s.substring(j + 1, s.length()), ans, i, j, par);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    String reversed = new StringBuilder(s).reverse().toString();</span><br><span class="line">    if (par[0] == &apos;(&apos;) // finished left to right</span><br><span class="line">        remove(reversed, ans, 0, 0, new char[]&#123;&apos;)&apos;, &apos;(&apos;&#125;);</span><br><span class="line">    else // finished right to left</span><br><span class="line">        ans.add(reversed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stacké‡åˆ°å·¦æ‹¬å·è‡ªå¢ž1ï¼Œé‡åˆ°å³æ‹¬å·è‡ªå‡1ã€‚å½“stack&lt;0æ—¶ï¼Œä»Žä¸Šä¸€ä¸ªåˆ é™¤çš„ä½ç½®å¼€å§‹éåŽ†ã€‚å½“å½“å‰å­—ç¬¦ä¸ºå³æ‹¬å·è€Œä¸”æ˜¯ç¬¬ä¸€ä¸ªå³æ‹¬å·ï¼Œåˆ é™¤å½“å‰å³æ‹¬å·å¹¶é€’å½’ã€‚åŽé¢å°†å­—ç¬¦ä¸²åè½¬ï¼Œå¦‚æžœparæ˜¯å·¦æ‹¬å·ï¼Œåˆ™è°ƒç”¨é€’å½’å‡½æ•°ä¼ å…¥åå‘æ‹¬å·æ¥åˆ é™¤å¤šçš„å·¦æ‹¬å·ã€‚å¦åˆ™è¯´æ˜Žå·²ç»åè½¬ï¼Œå¯ä»¥ç›´æŽ¥åŠ å…¥ç»“æžœäº†ã€‚</p>
<h3 id="392-Is-Subsequence"><a href="#392-Is-Subsequence" class="headerlink" title="392    Is Subsequence"></a>392    Is Subsequence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSubsequence(String s, String t) </span><br><span class="line">  &#123;</span><br><span class="line">      if(t.length() &lt; s.length()) return false;</span><br><span class="line">      int prev = 0;</span><br><span class="line">      for(int i = 0; i &lt; s.length();i++)</span><br><span class="line">      &#123;</span><br><span class="line">          char tempChar = s.charAt(i);</span><br><span class="line">          prev = t.indexOf(tempChar,prev);</span><br><span class="line">          if(prev == -1) return false;</span><br><span class="line">          prev++;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ä½¿ç”¨stringçš„indexOfï¼Œæ¯æ¬¡éƒ½æ£€ç´¢æ˜¯å¦ä»Žå½“å‰ä½ç½®å¼€å§‹ï¼Œæ˜¯å¦æœ‰sçš„å­—ç¬¦åœ¨tä¸­ã€‚</p>
<h3 id="115-Distinct-Subsequences"><a href="#115-Distinct-Subsequences" class="headerlink" title="115    Distinct Subsequences"></a>115    Distinct Subsequences</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int numDistinct(String S, String T) &#123;</span><br><span class="line">   int[][] mem = new int[T.length()+1][S.length()+1];</span><br><span class="line">   for(int j=0; j&lt;=S.length(); j++) &#123;</span><br><span class="line">       mem[0][j] = 1;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   for(int i=0; i&lt;T.length(); i++) &#123;</span><br><span class="line">       for(int j=0; j&lt;S.length(); j++) &#123;</span><br><span class="line">           if(T.charAt(i) == S.charAt(j)) &#123;</span><br><span class="line">               mem[i+1][j+1] = mem[i][j] + mem[i+1][j];</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mem[i+1][j+1] = mem[i+1][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return mem[T.length()][S.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp ã€‚dp[i][j] = dp[i-1][j] + dp[i-1][j-1]</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 19]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/07/21/Everyday-Leetcode-19/</url>
      <content type="html"><![CDATA[<h3 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131    Palindrome Partitioning"></a>131    Palindrome Partitioning</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">	List&lt;List&lt;String&gt;&gt; lists=new ArrayList&lt;&gt;();</span><br><span class="line">	int len=s.length();</span><br><span class="line">	if(len==0) return lists;</span><br><span class="line">	backtrack(lists, new ArrayList&lt;&gt;(), s,0,len);</span><br><span class="line">	return lists;</span><br><span class="line">&#125;</span><br><span class="line">private void backtrack(List&lt;List&lt;String&gt;&gt; lists,List&lt;String&gt; list,String s, int l, int r) &#123;</span><br><span class="line">	if(l==r) &#123;</span><br><span class="line">		lists.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=l+1;i&lt;=r;i++) &#123;</span><br><span class="line">		if(isPalindrome(s, l, i)) &#123;</span><br><span class="line">			list.add(s.substring(l, i));</span><br><span class="line">			backtrack(lists, list, s,i,r);</span><br><span class="line">			list.remove(list.size()-1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">private boolean isPalindrome(String s, int l, int r)&#123;</span><br><span class="line">    if(l==r-1) return true;</span><br><span class="line">    while(l&lt;r-1)&#123;</span><br><span class="line">        if(s.charAt(l)!=s.charAt(r-1)) return false;</span><br><span class="line">        l++;r--;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>isPalindromeåˆ¤æ–­å›žæ–‡ä¸²ï¼Œbacktrackå‡½æ•°ï¼ŒéåŽ†è¿‡ç¨‹ä¸­å¦‚æžœl=rè¯´æ˜Žå·²ç»éåŽ†å®Œæˆï¼Œè¿”å›žã€‚å¦åˆ™éåŽ†å¦‚æžœå½“å‰låˆ°iä¸ºå­—ç¬¦ä¸²ä¸ºå›žæ–‡ä¸²ï¼ŒåŠ åˆ°listä¸­å¹¶é€’å½’è°ƒç”¨backtrack(iåŽé¢çš„å­—ç¬¦ä¸²)æœ€åŽremoveæŽ‰æœ€åŽnewçš„ç©ºå­—ç¬¦ä¸²æ•°ç»„ã€‚</p>
<h3 id="132-Palindrome-Partitioning-II"><a href="#132-Palindrome-Partitioning-II" class="headerlink" title="132    Palindrome Partitioning II"></a>132    Palindrome Partitioning II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int minCut(String s) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        boolean dp[][] = new boolean[n+1][n+1];</span><br><span class="line">        int min[] = new int[n];</span><br><span class="line">        for(int i=0; i&lt;n; ++i) &#123;</span><br><span class="line">            min[i] = i;</span><br><span class="line">            for(int j=0; j&lt;=i; ++j) &#123;</span><br><span class="line">                if(s.charAt(i) == s.charAt(j) &amp;&amp; (j+1 &gt; i-1 || dp[j+1][i-1])) &#123;</span><br><span class="line">                    dp[j][i] = true;</span><br><span class="line">                    min[i] = j == 0 ? 0 : Math.min(min[i], min[j-1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min[n-1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>å½“[j][i]ä¸ºå›žæ–‡æ—¶ï¼Œdp[j+1][i-1]==trueï¼Œä¸”s.charAt(i) == s.charAt(j)ã€‚æ‰€ä»¥åˆ©ç”¨è¿™ä¸ªå†™å‡ºdpã€‚ç¬¬ä¸€ä¸ªforå¾ªçŽ¯éåŽ†çš„æ˜¯iï¼Œæ­¤æ—¶æˆ‘ä»¬çŽ°å°† min[i] åˆå§‹åŒ–ä¸º iï¼Œå› ä¸ºå¯¹äºŽåŒºé—´ [0, i]ï¼Œå°±ç®—æˆ‘ä»¬æ¯ä¸ªå­—æ¯å‰²ä¸€åˆ€ï¼Œæœ€å¤šèƒ½åªç”¨åˆ†å‰² i æ¬¡ï¼Œä¸éœ€è¦å†å¤šäºŽè¿™ä¸ªæ•°å­—ã€‚ä½†æ˜¯å¯èƒ½ä¼šå˜å°ï¼Œæ‰€ä»¥ç¬¬äºŒä¸ªforå¾ªçŽ¯ç”¨ j éåŽ†åŒºé—´ [0, j]ï¼Œæ ¹æ®ä¸Šé¢çš„è§£é‡Šï¼Œæˆ‘ä»¬éœ€è¦éªŒè¯çš„æ˜¯åŒºé—´ [j, i] å†…çš„å­ä¸²æ˜¯å¦ä¸ºå›žæ–‡ä¸²ï¼Œé‚£ä¹ˆåªè¦ s[j] == s[i]ï¼Œå¹¶ä¸” j+1&gt;i-1 æˆ–è€… p[j+1][i-1] ä¸ºtrueçš„è¯ï¼Œå…ˆæ›´æ–° dp[j][i] ä¸ºtrueï¼Œç„¶åŽåœ¨æ›´æ–° dp[i]ï¼Œè¿™é‡Œéœ€è¦æ³¨æ„ä¸€ä¸‹corner caseï¼Œå½“ j=0 æ—¶ï¼Œæˆ‘ä»¬ç›´æŽ¥ç»™ dp[i] èµ‹å€¼ä¸º0ï¼Œå› ä¸ºæ­¤æ—¶èƒ½è¿è¡Œåˆ°è¿™ï¼Œè¯´æ˜Ž [j, i] åŒºé—´æ˜¯å›žæ–‡ä¸²ï¼Œè€Œ j=0ï¼Œ åˆ™è¯´æ˜Ž [0, i] åŒºé—´å†…æ˜¯å›žæ–‡ä¸²ï¼Œè¿™æ ·æ ¹æœ¬ä¸ç”¨åˆ†å‰²å•Šã€‚è‹¥ j å¤§äºŽ0ï¼Œåˆ™ç”¨ min[j-1] + 1 æ¥æ›´æ–°,min[ i]ï¼Œæœ€ç»ˆè¿”å›ž min[n-1] å³å¯ã€‚</p>
<h3 id="267-Palindrome-Permutation-II"><a href="#267-Palindrome-Permutation-II" class="headerlink" title="267    Palindrome Permutation II"></a>267    Palindrome Permutation II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; generatePalindromes(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        unordered_map&lt;char, int&gt; m;</span><br><span class="line">        string t = &quot;&quot;, mid = &quot;&quot;;</span><br><span class="line">        for (auto a : s) ++m[a];</span><br><span class="line">        for (auto &amp;it : m) &#123;</span><br><span class="line">            if (it.second % 2 == 1) mid += it.first;</span><br><span class="line">            it.second /= 2;</span><br><span class="line">            t += string(it.second, it.first);</span><br><span class="line">            if (mid.size() &gt; 1) return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        permute(t, m, mid, &quot;&quot;, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void permute(string &amp;t, unordered_map&lt;char, int&gt; &amp;m, string mid, string out, vector&lt;string&gt; &amp;res) &#123;</span><br><span class="line">        if (out.size() &gt;= t.size()) &#123;</span><br><span class="line">            res.push_back(out + mid + string(out.rbegin(), out.rend()));</span><br><span class="line">            return;</span><br><span class="line">        &#125; </span><br><span class="line">        for (auto &amp;it : m) &#123;</span><br><span class="line">            if (it.second &gt; 0) &#123;</span><br><span class="line">                --it.second;</span><br><span class="line">                permute(t, m, mid, out + it.first, res);</span><br><span class="line">                ++it.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ç”¨å“ˆå¸Œè¡¨æ¥è®°å½•æ‰€æœ‰å­—ç¬¦çš„å‡ºçŽ°ä¸ªæ•°ï¼Œç„¶åŽæˆ‘ä»¬æ‰¾å‡ºå‡ºçŽ°å¥‡æ•°æ¬¡æ•°çš„å­—ç¬¦åŠ å…¥midä¸­ï¼Œå¦‚æžœæœ‰ä¸¤ä¸ªæˆ–ä¸¤ä¸ªä»¥ä¸Šçš„å¥‡æ•°ä¸ªæ•°çš„å­—ç¬¦ï¼Œé‚£ä¹ˆè¿”å›žç©ºé›†ï¼Œæˆ‘ä»¬å¯¹äºŽæ¯ä¸ªå­—ç¬¦ï¼Œä¸ç®¡å…¶å¥‡å¶ï¼Œéƒ½å°†å…¶ä¸ªæ•°é™¤ä»¥2çš„ä¸ªæ•°çš„å­—ç¬¦åŠ å…¥tä¸­ï¼Œè¿™æ ·åšçš„åŽŸå› æ˜¯å¦‚æžœæ˜¯å¶æ•°ä¸ªï¼Œé‚£ä¹ˆå°†å…¶ä¸€èˆ¬åŠ å…¥tä¸­ï¼Œå¦‚æžœæ˜¯å¥‡æ•°ï¼Œå¦‚æžœæœ‰1ä¸ªï¼Œé‚£ä¹ˆé™¤ä»¥2æ˜¯0ï¼Œä¸ä¼šæœ‰å­—ç¬¦åŠ å…¥tï¼Œå¦‚æžœæ˜¯3ä¸ªï¼Œé‚£ä¹ˆé™¤ä»¥2æ˜¯1ï¼Œå–ä¸€ä¸ªåŠ å…¥tã€‚ç­‰æˆ‘ä»¬èŽ·å¾—äº†tä¹‹åŽï¼Œtæ˜¯å°±æ˜¯å‰åŠæ®µå­—ç¬¦ï¼Œæˆ‘ä»¬å¯¹å…¶åšå…¨æŽ’åˆ—ï¼Œæ¯å¾—åˆ°ä¸€ä¸ªå…¨æŽ’åˆ—ï¼Œæˆ‘ä»¬åŠ ä¸Šmidå’Œè¯¥å…¨æŽ’åˆ—çš„é€†åºåˆ—å°±æ˜¯ä¸€ç§æ‰€æ±‚çš„å›žæ–‡å­—ç¬¦ä¸²ï¼Œè¿™æ ·æˆ‘ä»¬å°±å¯ä»¥å¾—åˆ°æ‰€æœ‰çš„å›žæ–‡å…¨æŽ’åˆ—äº†ã€‚åŒæ—¶ç”¨hashseté˜²é‡å¤ã€‚</p>
<h3 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20    Valid Parentheses"></a>20    Valid Parentheses</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">	for (char c : s.toCharArray()) &#123;</span><br><span class="line">		if (c == &apos;(&apos;)</span><br><span class="line">			stack.push(&apos;)&apos;);</span><br><span class="line">		else if (c == &apos;&#123;&apos;)</span><br><span class="line">			stack.push(&apos;&#125;&apos;);</span><br><span class="line">		else if (c == &apos;[&apos;)</span><br><span class="line">			stack.push(&apos;]&apos;);</span><br><span class="line">		else if (stack.isEmpty() || stack.pop() != c)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>åˆ©ç”¨æ ˆï¼Œå¦‚æžœæ˜¯å·¦è¾¹çš„ï¼ˆ{[ï¼Œå°±æŠŠå³è¾¹çš„åŽ‹å…¥æ ˆä¸­ï¼Œå¦åˆ™å°±åˆ¤æ–­æ˜¯å¦èƒ½æ¶ˆåŽ»ï¼Œæˆ–è€…æ ˆä¸ºç©ºã€‚æœ€åŽæ ˆä¸ºç©ºçš„æƒ…å†µä¸‹å°±æ˜¯trueã€‚</p>
<h3 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22    Generate Parentheses"></a>22    Generate Parentheses</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">       List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">       backtrack(list, &quot;&quot;, 0, 0, n);</span><br><span class="line">       return list;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void backtrack(List&lt;String&gt; list, String str, int open, int close, int max)&#123;</span><br><span class="line">       </span><br><span class="line">       if(str.length() == max*2)&#123;</span><br><span class="line">           list.add(str);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       if(open &lt; max)</span><br><span class="line">           backtrack(list, str+&quot;(&quot;, open+1, close, max);</span><br><span class="line">       if(close &lt; open)</span><br><span class="line">           backtrack(list, str+&quot;)&quot;, open, close+1, max);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>é€’å½’è°ƒç”¨èµ„æ·±ï¼Œå¦‚æžœstré•¿åº¦ç­‰äºŽn*2åˆ™ç›´æŽ¥è¿”å›žresã€‚å¦‚æžœopen&lt;nå°±åŠ ï¼ˆï¼Œclose&lt;openå°±åŠ ï¼‰ï¼Œæœ€åŽè¿”å›žresã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 18]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/07/20/Everyday-Leetcode-18/</url>
      <content type="html"><![CDATA[<h3 id="266-Palindrome-Permutation"><a href="#266-Palindrome-Permutation" class="headerlink" title="266    Palindrome Permutation"></a>266    Palindrome Permutation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool canPermutePalindrome(string s) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; m;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for (auto a : s) ++m[a];</span><br><span class="line">        for (auto a : m) &#123;</span><br><span class="line">            if (a.second % 2 == 1) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt == 0 || (s.size() % 2 == 1 &amp;&amp; cnt == 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>åˆ›å»ºå­—ç¬¦ä¸²çš„hashmapï¼Œå­—ç¬¦æ˜¯keyï¼Œå‡ºçŽ°æ¬¡æ•°æ˜¯valueã€‚ç»Ÿè®¡å‡ºçŽ°æ¬¡æ•°ä¸ºå¥‡æ•°çš„å­—ç¬¦ä¸ªæ•°ï¼Œå¦‚æžœä¸º0åˆ™å¯ä»¥å…¨æŽ’åˆ—å›žæ–‡ï¼Œå¦‚æžœä¸º1ä¸”åªæœ‰1ä¸ªå­—ç¬¦å‡ºçŽ°å¥‡æ•°æ¬¡ï¼Œä¹Ÿå¯ä»¥å…¨æŽ’åˆ—å›žæ–‡ã€‚<br><!-- mroe --></p>
<h3 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5    Longest Palindromic Substring"></a>5    Longest Palindromic Substring</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">       String res = &quot;&quot;;</span><br><span class="line">       int currLength = 0;</span><br><span class="line">       for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">           if(isPalindrome(s,i-currLength-1,i))&#123;</span><br><span class="line">               res = s.substring(i-currLength-1,i+1);</span><br><span class="line">               currLength = currLength+2;</span><br><span class="line">           &#125;</span><br><span class="line">           else if(isPalindrome(s,i-currLength,i))&#123;</span><br><span class="line">               res = s.substring(i-currLength,i+1);</span><br><span class="line">               currLength = currLength+1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public boolean isPalindrome(String s, int begin, int end)&#123;</span><br><span class="line">       if(begin&lt;0) return false;</span><br><span class="line">       while(begin&lt;end)&#123;</span><br><span class="line">       	if(s.charAt(begin++)!=s.charAt(end--)) return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆå†™ä¸€ä¸ªåˆ¤æ–­æ˜¯å¦ä¸ºå›žæ–‡çš„è¾…åŠ©å‡½æ•°ï¼Œç„¶åŽéåŽ†ï¼Œåˆ¤æ–­ä»Žå½“å‰å³æŒ‡é’ˆåˆ°å‰é¢length+1æˆ–è€…+2é•¿åº¦çš„å­—ç¬¦ä¸²æ˜¯å¦å›žæ–‡ï¼Œæ˜¯çš„è¯å°±æ›´æ–°é•¿åº¦ï¼Œä¿å­˜resã€‚æœ€åŽè¿”å›žresã€‚</p>
<h3 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9    Palindrome Number"></a>9    Palindrome Number</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPalindrome(int x) &#123;</span><br><span class="line">       if (x &lt; 0) return false;</span><br><span class="line"></span><br><span class="line">   int p = x; </span><br><span class="line">   int q = 0; </span><br><span class="line">   </span><br><span class="line">   while (p &gt;= 10)&#123;</span><br><span class="line">       q *=10; </span><br><span class="line">       q += p%10; </span><br><span class="line">       p /=10; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return q == x / 10 &amp;&amp; p == x % 10;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>pä¸ºxçš„ç¬¬ä¸€ä½ï¼Œqä¸ºxçš„é€†åºå°‘åŽ»ä¸ªä½æ•°ã€‚åˆ¤æ–­ä»–ä»¬å’ŒåŽŸæ•°å­—æ˜¯å¦ç›¸ç­‰</p>
<h3 id="214-Shortest-Palindrome"><a href="#214-Shortest-Palindrome" class="headerlink" title="214    Shortest Palindrome"></a>214    Shortest Palindrome</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public String shortestPalindrome(String s) &#123;</span><br><span class="line">    String temp = s + &quot;#&quot; + new StringBuilder(s).reverse().toString();</span><br><span class="line">    int[] table = getTable(temp);</span><br><span class="line"></span><br><span class="line">    return new StringBuilder(s.substring(table[table.length - 1])).reverse().toString() + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int[] getTable(String s)&#123;</span><br><span class="line">    int[] table = new int[s.length()];</span><br><span class="line"></span><br><span class="line">    int index = 0;</span><br><span class="line">    for(int i = 1; i &lt; s.length(); )&#123;</span><br><span class="line">        if(s.charAt(index) == s.charAt(i))&#123;</span><br><span class="line">            table[i] = ++index;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if(index &gt; 0)&#123;</span><br><span class="line">                index = table[index-1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                index = 0;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>æˆ‘ä»¬æŠŠså’Œå…¶è½¬ç½®rè¿žæŽ¥èµ·æ¥ï¼Œä¸­é—´åŠ ä¸Šä¸€ä¸ªå…¶ä»–å­—ç¬¦ï¼Œå½¢æˆä¸€ä¸ªæ–°çš„å­—ç¬¦ä¸²tï¼Œæˆ‘ä»¬è¿˜éœ€è¦ä¸€ä¸ªå’Œté•¿åº¦ç›¸åŒçš„ä¸€ä½æ•°ç»„ tableï¼Œå…¶ä¸­ table[i] è¡¨ç¤ºä»Ž t[i] åˆ°å¼€å¤´çš„å­ä¸²çš„ç›¸åŒå‰ç¼€åŽç¼€çš„ä¸ªæ•°ï¼Œå…·ä½“å¯å‚è€ƒ KMP ç®—æ³•ä¸­è§£é‡Šã€‚æœ€åŽæˆ‘ä»¬æŠŠä¸ç›¸åŒçš„ä¸ªæ•°å¯¹åº”çš„å­—ç¬¦ä¸²æ·»åŠ åˆ°sä¹‹å‰å³å¯ã€‚</p>
<h3 id="336-Palindrome-Pairs"><a href="#336-Palindrome-Pairs" class="headerlink" title="336    Palindrome Pairs"></a>336    Palindrome Pairs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">    TrieNode[] next;</span><br><span class="line">    int index;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    	</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">    	next = new TrieNode[26];</span><br><span class="line">    	index = -1;</span><br><span class="line">    	list = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; palindromePairs(String[] words) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    TrieNode root = new TrieNode();</span><br><span class="line">    for (int i = 0; i &lt; words.length; i++) addWord(root, words[i], i);</span><br><span class="line">    for (int i = 0; i &lt; words.length; i++) search(words, i, root, res);</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private void addWord(TrieNode root, String word, int index) &#123;</span><br><span class="line">    for (int i = word.length() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        int j = word.charAt(i) - &apos;a&apos;;</span><br><span class="line">    	if (root.next[j] == null) root.next[j] = new TrieNode();</span><br><span class="line">    	if (isPalindrome(word, 0, i)) root.list.add(index);</span><br><span class="line">    	root = root.next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    	</span><br><span class="line">    root.list.add(index);</span><br><span class="line">    root.index = index;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private void search(String[] words, int i, TrieNode root, List&lt;List&lt;Integer&gt;&gt; res) &#123;</span><br><span class="line">    for (int j = 0; j &lt; words[i].length(); j++) &#123;	</span><br><span class="line">    	if (root.index &gt;= 0 &amp;&amp; root.index != i &amp;&amp; isPalindrome(words[i], j, words[i].length() - 1)) &#123;</span><br><span class="line">    	    res.add(Arrays.asList(i, root.index));</span><br><span class="line">    	&#125;</span><br><span class="line">    		</span><br><span class="line">    	root = root.next[words[i].charAt(j) - &apos;a&apos;];</span><br><span class="line">      	if (root == null) return;</span><br><span class="line">    &#125;</span><br><span class="line">    	</span><br><span class="line">    for (int j : root.list) &#123;</span><br><span class="line">    	if (i == j) continue;</span><br><span class="line">    	res.add(Arrays.asList(i, j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private boolean isPalindrome(String word, int i, int j) &#123;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">    	if (word.charAt(i++) != word.charAt(j--)) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    	</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ä½¿ç”¨Trieæ¥ä¿å­˜å­—ç¬¦ä¸²ã€‚æž„å»ºTrieæ ‘ï¼Œå°†æ¯ä¸ªwordå’Œæ¯æ­¥æ˜¯å¦æ˜¯å›žæ–‡çš„ç»“æžœä¿å­˜è¿›åŽ»ï¼ŒéšåŽå†éåŽ†æŸ¥æ‰¾ï¼Œå¦‚æžœæ˜¯ä»Žjåˆ°æœ€åŽçš„å›žæ–‡ä¸²åˆ™åŠ å…¥è¯¥é”®å€¼å¯¹åˆ°resï¼Œæœ€åŽæŠŠlistä¸­æœ¬æ¥å°±æ˜¯å›žæ–‡çš„ä¹ŸåŠ å…¥resã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 17]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/07/19/Everyday-Leetcode-17/</url>
      <content type="html"><![CDATA[<h3 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3    Longest Substring Without Repeating Characters"></a>3    Longest Substring Without Repeating Characters</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        if (s.length()==0) return 0;</span><br><span class="line">       HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</span><br><span class="line">       int max=0;</span><br><span class="line">       for (int i=0, j=0; i&lt;s.length(); ++i)&#123;</span><br><span class="line">           if (map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">               j = Math.max(j,map.get(s.charAt(i))+1);</span><br><span class="line">           &#125;</span><br><span class="line">           map.put(s.charAt(i),i);</span><br><span class="line">           max = Math.max(max,i-j+1);</span><br><span class="line">       &#125;</span><br><span class="line">       return max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>æž„å»ºå­—ç¬¦ä¸²çš„hashmapï¼Œå­—ç¬¦æ˜¯keyï¼Œä½ç½®æ˜¯valueã€‚ç„¶åŽéåŽ†ï¼Œæž„å»ºä¸€ä¸ªsliding windowï¼Œ jæ˜¯å·¦æŒ‡é’ˆï¼Œiæ˜¯å³æŒ‡é’ˆï¼Œå¦‚æžœå‡ºçŽ°è¿‡è¯¥å­—ç¬¦ï¼Œåˆ™æ›´æ–°hashmapï¼Œå¦åˆ™ç›´æŽ¥åŠ å…¥ã€‚<br><a id="more"></a></p>
<h3 id="340-Longest-Substring-with-At-Most-K-Distinct-Characters"><a href="#340-Longest-Substring-with-At-Most-K-Distinct-Characters" class="headerlink" title="340    Longest Substring with At Most K Distinct Characters"></a>340    Longest Substring with At Most K Distinct Characters</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLongestSubstringTwoDistinct(string s) &#123;</span><br><span class="line">        int res = 0, left = 0;</span><br><span class="line">        unordered_map&lt;char, int&gt; m;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            ++m[s[i]];</span><br><span class="line">            while (m.size() &gt; k) &#123;</span><br><span class="line">                if (--m[s[left]] == 0) m.erase(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, i - left + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>åŒä¸‹é¢˜159ï¼ŒæŠŠ2æ”¹æˆk</p>
<h3 id="395-Longest-Substring-with-At-Least-K-Repeating-Characters"><a href="#395-Longest-Substring-with-At-Least-K-Repeating-Characters" class="headerlink" title="395    Longest Substring with At Least K Repeating Characters"></a>395    Longest Substring with At Least K Repeating Characters</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int longestSubstring(String s, int k) &#123;</span><br><span class="line">      if (s == null || s.length() == 0) return 0;</span><br><span class="line">      char[] chars = new char[26];</span><br><span class="line">      // record the frequency of each character</span><br><span class="line">      for (int i = 0; i &lt; s.length(); i += 1) chars[s.charAt(i) - &apos;a&apos;] += 1;</span><br><span class="line">      boolean flag = true;</span><br><span class="line">      for (int i = 0; i &lt; chars.length; i += 1) &#123;</span><br><span class="line">          if (chars[i] &lt; k &amp;&amp; chars[i] &gt; 0) flag = false;</span><br><span class="line">      &#125;</span><br><span class="line">      // return the length of string if this string is a valid string</span><br><span class="line">      if (flag == true) return s.length();</span><br><span class="line">      int result = 0;</span><br><span class="line">      int start = 0, cur = 0;</span><br><span class="line">      // otherwise we use all the infrequent elements as splits</span><br><span class="line">      while (cur &lt; s.length()) &#123;</span><br><span class="line">          if (chars[s.charAt(cur) - &apos;a&apos;] &lt; k) &#123;</span><br><span class="line">              result = Math.max(result, longestSubstring(s.substring(start, cur), k));</span><br><span class="line">              start = cur + 1;</span><br><span class="line">          &#125;</span><br><span class="line">          cur++;</span><br><span class="line">      &#125;</span><br><span class="line">      result = Math.max(result, longestSubstring(s.substring(start), k));</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>é€’å½’åšæ³•ï¼Œè®°å½•å­—ç¬¦ä¸²ä¸­æ¯ä¸ªå­—ç¬¦çš„å‡ºçŽ°æ¬¡æ•°ï¼Œå¦‚æžœå·²ç»æ˜¯valid stringå°±è¿”å›žï¼Œå¦åˆ™ä¾¿éåŽ†æ‰€æœ‰splitsï¼Œåœ¨å¾ªçŽ¯ä¸­é€’å½’è°ƒç”¨è‡ªèº«ï¼ˆstartåˆ°curï¼‰ã€‚å†…å±‚å¾ªçŽ¯ç»“æŸåŽï¼Œæœ€åŽå†é€’å½’è°ƒç”¨è‡ªèº«ï¼ˆstartåˆ°æœ€åŽï¼‰ã€‚</p>
<h3 id="159-Longest-Substring-with-At-Most-Two-Distinct-Characters"><a href="#159-Longest-Substring-with-At-Most-Two-Distinct-Characters" class="headerlink" title="159    Longest Substring with At Most Two Distinct Characters"></a>159    Longest Substring with At Most Two Distinct Characters</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLongestSubstringTwoDistinct(string s) &#123;</span><br><span class="line">        int res = 0, left = 0;</span><br><span class="line">        unordered_map&lt;char, int&gt; m;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            ++m[s[i]];</span><br><span class="line">            while (m.size() &gt; 2) &#123;</span><br><span class="line">                if (--m[s[left]] == 0) m.erase(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, i - left + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>HashMap è®°å½•æ¯ä¸ªå­—ç¬¦çš„å‡ºçŽ°æ¬¡æ•°ï¼Œç„¶åŽå¦‚æžœ HashMap ä¸­çš„æ˜ å°„æ•°é‡è¶…è¿‡ä¸¤ä¸ªçš„æ—¶å€™ï¼Œæˆ‘ä»¬éœ€è¦åˆ æŽ‰ä¸€ä¸ªæ˜ å°„ï¼Œç„¶åŽæˆ‘ä»¬æ›´æ–°ç»“æžœä¸º i - left + 1ã€‚</p>
<h3 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125    Valid Palindrome"></a>125    Valid Palindrome</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPalindrome(String s) &#123;</span><br><span class="line">   char[] c = s.toCharArray();</span><br><span class="line">       for (int i = 0, j = c.length - 1; i &lt; j; ) &#123;</span><br><span class="line">           if (!Character.isLetterOrDigit(c[i])) i++;</span><br><span class="line">           else if (!Character.isLetterOrDigit(c[j])) j--;</span><br><span class="line">           else if (Character.toLowerCase(c[i++]) != Character.toLowerCase(c[j--])) </span><br><span class="line">               return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆè½¬æ¢æˆchar[]ï¼Œç„¶åŽå¦‚æžœä¸æ˜¯letterå°±ç§»åŠ¨å·¦å³ä¸¤ä¸ªæŒ‡é’ˆï¼ŒéšåŽæ¯”è¾ƒtolowercaseåŽçš„ä¸¤ä¸ªå­—ç¬¦ï¼Œå¦‚æžœæœ‰ä¸ä¸€æ ·å°±è¿”å›žfalseï¼Œå¦‚æžœéåŽ†å®Œæ²¡æœ‰è¯´æ˜Žæ˜¯palindromeï¼Œè¿”å›žtrueã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 16]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/26/Everyday-Leetcode-16/</url>
      <content type="html"><![CDATA[<h3 id="65-Valid-Number"><a href="#65-Valid-Number" class="headerlink" title="65    Valid Number"></a>65    Valid Number</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean isNumber(String s) &#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">       boolean pointSeen = false;</span><br><span class="line">       boolean eSeen = false;</span><br><span class="line">       boolean numberSeen = false;</span><br><span class="line">       for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">           if(&apos;0&apos; &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= &apos;9&apos;) &#123;</span><br><span class="line">               numberSeen = true;</span><br><span class="line">           &#125; else if(s.charAt(i) == &apos;.&apos;) &#123;</span><br><span class="line">               if(eSeen || pointSeen)</span><br><span class="line">                   return false;</span><br><span class="line">               pointSeen = true;</span><br><span class="line">           &#125; else if(s.charAt(i) == &apos;e&apos;) &#123;</span><br><span class="line">               if(eSeen || !numberSeen)</span><br><span class="line">                   return false;</span><br><span class="line">               numberSeen = false;</span><br><span class="line">               eSeen = true;</span><br><span class="line">           &#125; else if(s.charAt(i) == &apos;-&apos; || s.charAt(i) == &apos;+&apos;) &#123;</span><br><span class="line">               if(i != 0 &amp;&amp; s.charAt(i-1) != &apos;e&apos;)</span><br><span class="line">                   return false;</span><br><span class="line">           &#125; else</span><br><span class="line">               return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return numberSeen;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>å¦‚ä¸Šæ‰€ç¤ºã€‚</p>
<h3 id="157-Read-N-Characters-Given-Read4"><a href="#157-Read-N-Characters-Given-Read4" class="headerlink" title="157    Read N Characters Given Read4"></a>157    Read N Characters Given Read4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int read(char *buf, int n) &#123;</span><br><span class="line">        int t = read4(buf);</span><br><span class="line">        if (t &gt;= n) return n;</span><br><span class="line">        if (t &lt; 4) return t;</span><br><span class="line">        return 4 + read(&amp;buf[4], n - 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>é€’å½’è§£æ³•ï¼Œå¦‚æžœè¿”å›žå€¼tå¤§äºŽç­‰äºŽnï¼Œè¯´æ˜Žæ­¤æ—¶nä¸å¤§äºŽ4ï¼Œç›´æŽ¥è¿”å›žnå³å¯ï¼Œå¦‚æžœæ­¤è¿”å›žå€¼tå°äºŽ4ï¼Œç›´æŽ¥è¿”å›žtå³å¯ï¼Œå¦‚æžœéƒ½ä¸æ˜¯ï¼Œåˆ™ç›´æŽ¥è¿”å›žè°ƒç”¨é€’å½’å‡½æ•°åŠ ä¸Š4ï¼Œå…¶ä¸­é€’å½’å‡½æ•°çš„bufåº”å¾€åŽæŽ¨4ä¸ªå­—ç¬¦ï¼Œæ­¤æ—¶nå˜æˆn-4å³å¯ã€‚</p>
<h3 id="158-Read-N-Characters-Given-Read4-II-Call-multiple-times"><a href="#158-Read-N-Characters-Given-Read4-II-Call-multiple-times" class="headerlink" title="158    Read N Characters Given Read4 II - Call multiple times"></a>158    Read N Characters Given Read4 II - Call multiple times</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> public class Solution extends Reader4 &#123;</span><br><span class="line">    char[] buffer = new char[4];</span><br><span class="line">    int readPos = 0;</span><br><span class="line">    int writePos = 0;</span><br><span class="line">    public int read(char[] buf, int n) &#123;</span><br><span class="line">        int idx = 0;</span><br><span class="line">        while (idx &lt; n) &#123;</span><br><span class="line">            if (readPos == 0) &#123;</span><br><span class="line">                writePos = read4(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            while (readPos &lt; writePos &amp;&amp; idx &lt; n) &#123;</span><br><span class="line">                buf[idx++] = buffer[readPos++];</span><br><span class="line">            &#125;</span><br><span class="line">            if (readPos == writePos) &#123;</span><br><span class="line">                readPos = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (idx == n || writePos &lt; 4) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>æ¯”å¦‚file(â€œabcdefgâ€)ï¼Œç„¶åŽè¦æ±‚çš„æ˜¯[read(1), read(2), read(2), read(1)]ã€‚</p>
<ol>
<li>è°ƒç”¨read(1)åŽï¼Œæ­¤æ—¶buffä¸ºç©ºï¼Œè°ƒç”¨ä¸€ä¸ªread4ï¼Œbuffä¸­å­˜å‚¨äº†â€œabcdâ€ï¼ŒwritePos = 4ï¼Œç„¶åŽä»Žbuffä¸­è¯»å‡º1ä¸ªå­—ç¬¦åˆ°bufï¼Œé‚£ä¹ˆå°±æ˜¯ç¬¬ä¸€ä¸ªå­—ç¬¦[â€œaâ€]ï¼Œæ­¤æ—¶readPos = 1ã€‚</li>
<li>è°ƒç”¨read(2)ï¼Œæ­¤æ—¶readPos = 1 &lt; writePos = 4ï¼Œæ‰€ä»¥å…ˆä»Žbufä¸­è¯»å–2ä¸ªå­—ç¬¦ï¼Œä¹Ÿå°±æ˜¯[â€œbcâ€]ï¼Œæ­¤æ—¶readPos = 3ã€‚</li>
<li>ç„¶åŽread(2)ï¼Œæ­¤æ—¶readPos = 3 &lt; readPos = 4ï¼Œæ‰€ä»¥ç»§ç»­ä»Žbuffä¸­è¯»å–ï¼Œä½†æ˜¯bufferä¸­åªå‰©ä¸‹ä¸€ä¸ªå­—ç¬¦äº†ï¼Œæ‰€ä»¥å…ˆæŠŠå®ƒè¯»åˆ°bufä¸­ï¼Œ[â€œdâ€]ï¼Œç„¶åŽreadPos == writePosäº†ï¼Œæ‰€ä»¥readPosé‡ç½®ä¸º0ï¼Œç»§ç»­å¾ªçŽ¯ã€‚æ­¤æ—¶readPos = 0ï¼Œæˆ‘ä»¬è°ƒç”¨ä¸€ä¸ªread4å¡«å……buffï¼Œbuffä¸­ä¸ºâ€efgâ€ï¼Œç„¶åŽæˆ‘ä»¬å¯ä»¥ç»§ç»­è¯»å–ä¸€ä¸ªå­—ç¬¦åˆ°bufä¸­ï¼Œä¹Ÿå°±æ˜¯è¿™æ¬¡æœ€ç»ˆè¯»å–çš„ç»“æžœä¸º[â€œdeâ€]ã€‚</li>
<li>æœ€åŽä¸€æ¬¡æ˜¯è°ƒç”¨read(1)ï¼Œåˆ™æ˜¯æŠŠbuffä¸­çš„1ä¸ªå­—ç¬¦å¤åˆ¶åˆ°bufä¸­ï¼Œå¾—åˆ°[â€œfâ€]</li>
</ol>
<h3 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76    Minimum Window Substring"></a>76    Minimum Window Substring</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public String minWindow(String s, String t) &#123;</span><br><span class="line">   int [] map = new int[128];</span><br><span class="line">   for (char c : t.toCharArray()) &#123;</span><br><span class="line">     map[c]++;</span><br><span class="line">   &#125;</span><br><span class="line">   int start = 0, end = 0, minStart = 0, minLen = Integer.MAX_VALUE, counter = t.length();</span><br><span class="line">   while (end &lt; s.length()) &#123;</span><br><span class="line">     final char c1 = s.charAt(end);</span><br><span class="line">     if (map[c1] &gt; 0) counter--;</span><br><span class="line">     map[c1]--;</span><br><span class="line">     end++;</span><br><span class="line">     while (counter == 0) &#123;</span><br><span class="line">       if (minLen &gt; end - start) &#123;</span><br><span class="line">         minLen = end - start;</span><br><span class="line">         minStart = start;</span><br><span class="line">       &#125;</span><br><span class="line">       final char c2 = s.charAt(start);</span><br><span class="line">       map[c2]++;</span><br><span class="line">       if (map[c2] &gt; 0) counter++;</span><br><span class="line">       start++;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return minLen == Integer.MAX_VALUE ? &quot;&quot; : s.substring(minStart, minStart + minLen);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆ+mapï¼Œå¦‚æžœå‘½ä¸­counter-1ï¼Œå½“counter==-æ—¶è¯´æ˜Žæ‰¾åˆ°åŒ…å«substringçš„windowï¼ŒäºŽæ˜¯åœ¨windowå†…æ‰¾æ»¡è¶³æ¡ä»¶çš„æœ€å°windowï¼Œæœ€åŽè¿”å›žæœ€å°çš„windowã€‚</p>
<h3 id="30-Substring-with-Concatenation-of-All-Words"><a href="#30-Substring-with-Concatenation-of-All-Words" class="headerlink" title="30    Substring with Concatenation of All Words"></a>30    Substring with Concatenation of All Words</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Integer&gt; findSubstring(String S, String[] L) &#123;</span><br><span class="line">    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    if (S == null || L == null || L.length == 0) return res;</span><br><span class="line">    int len = L[0].length(); // length of each word</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); // map for L</span><br><span class="line">    for (String w : L) map.put(w, map.containsKey(w) ? map.get(w) + 1 : 1);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt;= S.length() - len * L.length; i++) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; copy = new HashMap&lt;String, Integer&gt;(map);</span><br><span class="line">        for (int j = 0; j &lt; L.length; j++) &#123; // checkc if match</span><br><span class="line">            String str = S.substring(i + j*len, i + j*len + len); // next word</span><br><span class="line">            if (copy.containsKey(str)) &#123; // is in remaining words</span><br><span class="line">                int count = copy.get(str);</span><br><span class="line">                if (count == 1) copy.remove(str);</span><br><span class="line">                else copy.put(str, count - 1);</span><br><span class="line">                if (copy.isEmpty()) &#123; // matches</span><br><span class="line">                    res.add(i);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else break; // not in L</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆæž„å»ºmapï¼Œç„¶åŽéåŽ†æŸ¥æ‰¾æ˜¯å¦match</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 15]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/18/Everyday-Leetcode-15/</url>
      <content type="html"><![CDATA[<h3 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12    Integer to Roman"></a>12    Integer to Roman</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public String intToRoman(int num) &#123;</span><br><span class="line">       int[] values = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;;</span><br><span class="line">   String[] strs = &#123;&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;&#125;;</span><br><span class="line">   </span><br><span class="line">   StringBuilder sb = new StringBuilder();</span><br><span class="line">   </span><br><span class="line">   for(int i=0;i&lt;values.length;i++) &#123;</span><br><span class="line">       while(num &gt;= values[i]) &#123;</span><br><span class="line">           num -= values[i];</span><br><span class="line">           sb.append(strs[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>ä»Žé«˜åˆ°ä½Žåˆ¤æ–­æ˜¯å¦ç¬¦åˆç½—é©¬æ•°å­—å¤§å°ï¼Œç¬¦åˆåˆ™å‡åŽ»ä¸€è¯¥æ•°å­—å¹¶åŠ å…¥å­—ç¬¦åˆ°ç»“æžœã€‚</p>
<h3 id="273-Integer-to-English-Words"><a href="#273-Integer-to-English-Words" class="headerlink" title="273    Integer to English Words"></a>273    Integer to English Words</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private final String[] belowTen = new String[] &#123;&quot;&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;&#125;;</span><br><span class="line">    private final String[] belowTwenty = new String[] &#123;&quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;, &quot;Thirteen&quot;, &quot;Fourteen&quot;, &quot;Fifteen&quot;, &quot;Sixteen&quot;, &quot;Seventeen&quot;, &quot;Eighteen&quot;, &quot;Nineteen&quot;&#125;;</span><br><span class="line">    private final String[] belowHundred = new String[] &#123;&quot;&quot;, &quot;Ten&quot;, &quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;&#125;;</span><br><span class="line">    </span><br><span class="line">    public String numberToWords(int num) &#123;</span><br><span class="line">        if (num == 0) return &quot;Zero&quot;;</span><br><span class="line">        return helper(num); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private String helper(int num) &#123;</span><br><span class="line">        String result = new String();</span><br><span class="line">        if (num &lt; 10) result = belowTen[num];</span><br><span class="line">        else if (num &lt; 20) result = belowTwenty[num -10];</span><br><span class="line">        else if (num &lt; 100) result = belowHundred[num/10] + &quot; &quot; + helper(num % 10);</span><br><span class="line">        else if (num &lt; 1000) result = helper(num/100) + &quot; Hundred &quot; +  helper(num % 100);</span><br><span class="line">        else if (num &lt; 1000000) result = helper(num/1000) + &quot; Thousand &quot; +  helper(num % 1000);</span><br><span class="line">        else if (num &lt; 1000000000) result = helper(num/1000000) + &quot; Million &quot; +  helper(num % 1000000);</span><br><span class="line">        else result = helper(num/1000000000) + &quot; Billion &quot; + helper(num % 1000000000);</span><br><span class="line">        return result.trim();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>æž„å»ºå•è¯è¡¨ï¼ˆè®°å¾—å¼€å¤´æœ‰â€œâ€)ï¼Œç„¶åŽæ ¹æ®å¤§å°else ifï¼Œè®°å¾—å¯ä»¥é€’å½’è°ƒç”¨è‡ªèº«ã€‚</p>
<h3 id="246-Strobogrammatic-Number"><a href="#246-Strobogrammatic-Number" class="headerlink" title="246    Strobogrammatic Number"></a>246    Strobogrammatic Number</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool isStrobogrammatic(string num) &#123;</span><br><span class="line">       unordered_map&lt;char, char&gt; m &#123;&#123;&apos;0&apos;, &apos;0&apos;&#125;, &#123;&apos;1&apos;, &apos;1&apos;&#125;, &#123;&apos;8&apos;, &apos;8&apos;&#125;, &#123;&apos;6&apos;, &apos;9&apos;&#125;, &#123;&apos;9&apos;, &apos;6&apos;&#125;&#125;;</span><br><span class="line">       for (int i = 0; i &lt;= num.size() / 2; ++i) &#123;</span><br><span class="line">           if (m[num[i]] != num[num.size() - i - 1]) return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>å¦‚æžœå¯¹åº”ä¸¤ä¸ªä½ç½®ä¸æ»¡è¶³å¯¹ç§°è¦æ±‚ï¼Œè¿”å›žfalseã€‚</p>
<h3 id="247-Strobogrammatic-Number-II"><a href="#247-Strobogrammatic-Number-II" class="headerlink" title="247    Strobogrammatic Number II"></a>247    Strobogrammatic Number II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; findStrobogrammatic(int n) &#123;</span><br><span class="line">      return find(n, n);</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;string&gt; find(int m, int n) &#123;</span><br><span class="line">      if (m == 0) return &#123;&quot;&quot;&#125;;</span><br><span class="line">      if (m == 1) return &#123;&quot;0&quot;, &quot;1&quot;, &quot;8&quot;&#125;;</span><br><span class="line">      vector&lt;string&gt; t = find(m - 2, n), res;</span><br><span class="line">      for (auto a : t) &#123;</span><br><span class="line">          if (m != n) res.push_back(&quot;0&quot; + a + &quot;0&quot;);</span><br><span class="line">          res.push_back(&quot;1&quot; + a + &quot;1&quot;);</span><br><span class="line">          res.push_back(&quot;6&quot; + a + &quot;9&quot;);</span><br><span class="line">          res.push_back(&quot;8&quot; + a + &quot;8&quot;);</span><br><span class="line">          res.push_back(&quot;9&quot; + a + &quot;6&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>ä»Žm=0å±‚å¼€å§‹ï¼Œä¸€å±‚ä¸€å±‚å¾€ä¸ŠåŠ çš„ï¼Œéœ€è¦æ³¨æ„çš„æ˜¯å½“åŠ åˆ°äº†nå±‚çš„æ—¶å€™ï¼Œå·¦å³ä¸¤è¾¹ä¸èƒ½åŠ [0 0]ã€‚</p>
<h3 id="68-Text-Justification"><a href="#68-Text-Justification" class="headerlink" title="68    Text Justification"></a>68    Text Justification</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; fullJustify(String[] words, int maxWidth) &#123;</span><br><span class="line">      List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">      int i=0;</span><br><span class="line">      while (i&lt;words.length)&#123;</span><br><span class="line">          int width=0, I=i;</span><br><span class="line">          while (I&lt;words.length &amp;&amp; width+words[I].length()+(I-i)&lt;=maxWidth)</span><br><span class="line">              width+=words[I++].length();</span><br><span class="line">          int space=1, extra=0;</span><br><span class="line">          if (I-i!=1 &amp;&amp; I!=words.length)&#123;</span><br><span class="line">              space=(maxWidth-width)/(I-i-1);</span><br><span class="line">              extra=(maxWidth-width)%(I-i-1);</span><br><span class="line">          &#125;</span><br><span class="line">          StringBuilder line= new StringBuilder(words[i++]);</span><br><span class="line">          while (i&lt;I)&#123;</span><br><span class="line">              for (int s= space; s&gt;0; s--) line.append(&quot; &quot;);</span><br><span class="line">              if (extra--&gt;0) line.append(&quot; &quot;);</span><br><span class="line">              line.append(words[i++]);</span><br><span class="line">          &#125;</span><br><span class="line">          for (int s= maxWidth-line.length(); s&gt;0; s--) line.append(&quot; &quot;);</span><br><span class="line">          res.add(line.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>å½“widthå°äºŽmaxwidthæ—¶ï¼ŒåŠ wordåˆ°æ”¹è¡Œï¼Œç„¶åŽå†åŽé¢è¡¥ç©ºæ ¼å¦‚æžœç©ºæ ¼æ•°ä¸æ˜¯2çš„å€æ•°ï¼Œé‚£ä¹ˆå·¦è¾¹çš„ç©ºé—´é‡Œè¦æ¯”å³è¾¹çš„ç©ºé—´é‡Œå¤šåŠ å…¥ä¸€ä¸ªç©ºæ ¼ï¼Œé‚£ä¹ˆæˆ‘ä»¬åªéœ€è¦ç”¨æ€»çš„ç©ºæ ¼æ•°é™¤ä»¥ç©ºé—´ä¸ªæ•°ã€‚èƒ½é™¤å°½æœ€å¥½ï¼Œè¯´æ˜Žèƒ½å¹³å‡åˆ†é…ï¼Œé™¤ä¸å°½çš„è¯å°±å¤šåŠ ä¸ªç©ºæ ¼æ”¾åœ¨å·¦è¾¹çš„ç©ºé—´é‡Œã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 14]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/17/Everyday-Leetcode-14/</url>
      <content type="html"><![CDATA[<h3 id="316-Remove-Duplicate-Letters"><a href="#316-Remove-Duplicate-Letters" class="headerlink" title="316    Remove Duplicate Letters"></a>316    Remove Duplicate Letters</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public String removeDuplicateLetters(String sr) &#123;   </span><br><span class="line">        int[] res = new int[26]; </span><br><span class="line">   boolean[] visited = new boolean[26]; </span><br><span class="line">   char[] ch = sr.toCharArray();</span><br><span class="line">   for(char c: ch)&#123;  </span><br><span class="line">       res[c-&apos;a&apos;]++;</span><br><span class="line">   &#125;</span><br><span class="line">   Stack&lt;Character&gt; st = new Stack&lt;&gt;();</span><br><span class="line">   int index;</span><br><span class="line">   for(char s:ch)&#123; </span><br><span class="line">       index= s-&apos;a&apos;;</span><br><span class="line">       res[index]--;   </span><br><span class="line">       if(visited[index]) </span><br><span class="line">           continue;</span><br><span class="line">       while(!st.isEmpty() &amp;&amp; s&lt;st.peek() &amp;&amp; res[st.peek()-&apos;a&apos;]!=0)&#123; </span><br><span class="line">           visited[st.pop()-&apos;a&apos;]=false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       st.push(s); </span><br><span class="line">       visited[index]=true;</span><br><span class="line">   &#125;</span><br><span class="line">   StringBuilder sb = new StringBuilder();</span><br><span class="line">   while(!st.isEmpty())&#123;</span><br><span class="line">       sb.insert(0,st.pop());</span><br><span class="line">   &#125;</span><br><span class="line">   return sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>é¦–å…ˆç”¨charæ•°ç»„è®°å½•å­—ç¬¦å‡ºçŽ°æ¬¡æ•°ï¼Œç„¶åŽéåŽ†ï¼Œå¦‚æžœè¯¥æ•°å­—å·²ç»å‡ºçŽ°åœ¨åºåˆ—ä¸­ï¼Œcontinueä¸ç®¡å®ƒï¼Œå¦‚æžœæ¯”å½“å‰æ ˆé¡¶å°ï¼Œè€Œä¸”æ ˆé¡¶å­—ç¬¦æ¬¡æ•°ä¸ä¸º0ï¼Œè¿˜ä¼šåœ¨åŽé¢å‡ºçŽ°ï¼Œå°±å¼¹å‡ºå¹¶ç½®ä¸ºfalseæœªå‡ºçŽ°ï¼Œå°†å½“å‰å­—ç¬¦åŽ‹å…¥æ ˆä¸­ã€‚æœ€åŽæŒ‰ç…§æ ˆçš„æ¬¡åºpopè¾“å‡ºã€‚</p>
<h3 id="271-Encode-and-Decode-Strings"><a href="#271-Encode-and-Decode-Strings" class="headerlink" title="271    Encode and Decode Strings"></a>271    Encode and Decode Strings</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Encodes a list of strings to a single string.</span><br><span class="line">    string encode(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        for (string str : strs) res += str + &apos;\0&apos;;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    // Decodes a single string to a list of strings.</span><br><span class="line">    vector&lt;string&gt; decode(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        stringstream ss(s);</span><br><span class="line">        string t;</span><br><span class="line">        while (getline(ss, t, &apos;\0&apos;)) &#123;</span><br><span class="line">            res.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>åœ¨æ¯ä¸ªå­—ç¬¦ä¸²çš„åŽé¢åŠ ä¸Šæ¢è¡Œå­—ç¬¦â€™\0â€™ï¼Œå…¶è¿˜å±žäºŽä¸€ä¸ªå­—ç¬¦ä¸²ï¼Œè¿™æ ·æˆ‘ä»¬åœ¨è§£ç çš„æ—¶å€™ï¼Œåªè¦åŽ»æŸ¥æ‰¾è¿™ä¸ªæ¢è¡Œå­—ç¬¦å°±å¯ä»¥äº†ã€‚</p>
<h3 id="168-Excel-Sheet-Column-Title"><a href="#168-Excel-Sheet-Column-Title" class="headerlink" title="168    Excel Sheet Column Title"></a>168    Excel Sheet Column Title</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String convertToTitle(int n) &#123;</span><br><span class="line">      StringBuilder sb= new StringBuilder();</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">        while(n&gt;0)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            sb.insert(0, (char)(&apos;A&apos; + n % 26));</span><br><span class="line">            n /= 26;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ç›¸å½“äºŽè½¬æ¢æˆ26è¿›åˆ¶ã€‚</p>
<h3 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171    Excel Sheet Column Number"></a>171    Excel Sheet Column Number</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int titleToNumber(String s) &#123;</span><br><span class="line">       </span><br><span class="line">     char[] ch = s.toCharArray();</span><br><span class="line">       int res=0;</span><br><span class="line">      for(int i=s.length()-1;i&gt;=0;i--)&#123;</span><br><span class="line">          int sq=s.length()-1-i;</span><br><span class="line">          int q=1;</span><br><span class="line">          while(sq&gt;0)&#123;</span><br><span class="line">              q*=26;</span><br><span class="line">              sq--;</span><br><span class="line">          &#125;</span><br><span class="line">       res+=(int)(ch[i]-&apos;A&apos;+1)*q;</span><br><span class="line">        &#125;</span><br><span class="line">       return res;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>åŒä¸Šï¼Œåè¿‡æ¥åšã€‚</p>
<h3 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13    Roman to Integer"></a>13    Roman to Integer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int romanToInt(String s) &#123;</span><br><span class="line">       </span><br><span class="line">        int[] map = new int[256];</span><br><span class="line">        map[&apos;I&apos;] = 1; map[&apos;V&apos;] = 5; map[&apos;X&apos;] = 10; map[&apos;L&apos;] = 50; map[&apos;C&apos;] = 100; map[&apos;D&apos;] = 500; map[&apos;M&apos;] = 1000;</span><br><span class="line">        </span><br><span class="line">        int ret = 0, pre = 1;</span><br><span class="line">        for (int i = s.length()-1; i &gt;= 0; --i) &#123;</span><br><span class="line">            int cur = map[s.charAt(i)];</span><br><span class="line">            if (cur &lt; pre) ret -= cur;</span><br><span class="line">            else &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                ret += cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ç½—é©¬æ•°å­—çš„è§„åˆ™ï¼Œå¦‚æžœå°å¾—æ”¾å‰é¢è¯´æ˜Žè¦å‡åŽ»å‰é¢è¿™ä¸ªã€‚å¦åˆ™ç›´æŽ¥ç´¯åŠ ã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 13]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/15/Everyday-Leetcode-13/</url>
      <content type="html"><![CDATA[<h3 id="249-Group-Shifted-Strings"><a href="#249-Group-Shifted-Strings" class="headerlink" title="249    Group Shifted Strings"></a>249    Group Shifted Strings</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; groupStrings(vector&lt;string&gt;&amp; strings) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt; &gt; res;</span><br><span class="line">        unordered_map&lt;string, multiset&lt;string&gt;&gt; m;</span><br><span class="line">        for (auto a : strings) &#123;</span><br><span class="line">            string t = &quot;&quot;;</span><br><span class="line">            for (char c : a) &#123;</span><br><span class="line">                t += to_string((c + 26 - a[0]) % 26) + &quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[t].insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto it = m.begin(); it != m.end(); ++it) &#123;</span><br><span class="line">            res.push_back(vector&lt;string&gt;(it-&gt;second.begin(), it-&gt;second.end()));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>æ‰€æœ‰äº’ä¸ºåç§»çš„å­—ç¬¦ä¸²éƒ½æœ‰ä¸ªuniqueçš„è·ç¦»å·®ï¼Œæˆ‘ä»¬æ ¹æ®è¿™ä¸ªæ¥å»ºç«‹æ˜ å°„å°±å¯ä»¥å¾ˆå¥½çš„è¿›è¡Œå•è¯åˆ†ç»„äº†ã€‚<br><a id="more"></a></p>
<h3 id="87-Scramble-String"><a href="#87-Scramble-String" class="headerlink" title="87    Scramble String"></a>87    Scramble String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean isScramble(String s1, String s2) &#123;</span><br><span class="line">       </span><br><span class="line">        if (s1.equals(s2)) return true; </span><br><span class="line">        </span><br><span class="line">        int[] letters = new int[26];</span><br><span class="line">        for (int i=0; i&lt;s1.length(); i++) &#123;</span><br><span class="line">            letters[s1.charAt(i)-&apos;a&apos;]++;</span><br><span class="line">            letters[s2.charAt(i)-&apos;a&apos;]--;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=0; i&lt;26; i++) if (letters[i]!=0) return false;</span><br><span class="line">    </span><br><span class="line">        for (int i=1; i&lt;s1.length(); i++) &#123;</span><br><span class="line">            if (isScramble(s1.substring(0,i), s2.substring(0,i)) </span><br><span class="line">             &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) return true;</span><br><span class="line">            if (isScramble(s1.substring(0,i), s2.substring(s2.length()-i)) </span><br><span class="line">             &amp;&amp; isScramble(s1.substring(i), s2.substring(0,s2.length()-i))) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆåˆ¤æ–­æ˜¯å¦ç›´æŽ¥ç›¸ç­‰ï¼Œå†åˆ¤æ–­æ‰€å«å­—æ¯æ˜¯å¦ç›¸ç­‰ã€‚ç„¶åŽéåŽ†ï¼Œé€’å½’è°ƒç”¨ç›´åˆ°è¾“å‡ºç»“æžœã€‚è¦ä¹ˆåˆ†è§£åˆ°å•è¯åŒ…å«çš„å­—æ¯éƒ½ä¸€æ ·ï¼Œè¦ä¹ˆåˆ†è§£åˆ°ä¸¤å¤´å•è¯å¯¹å’Œä¸­é—´å•è¯å¯¹ç›¸åŒï¼Œè¯´æ˜Žå¯ä»¥ç¿»è½¬ã€‚</p>
<h3 id="161-One-Edit-Distance"><a href="#161-One-Edit-Distance" class="headerlink" title="161    One Edit Distance"></a>161    One Edit Distance</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool isOneEditDistance(string s, string t) &#123;</span><br><span class="line">    for (int i = 0; i &lt; min(s.size(), t.size()); ++i) &#123;</span><br><span class="line">        if (s[i] != t[i]) &#123;</span><br><span class="line">            if (s.size() == t.size()) return s.substr(i + 1) == t.substr(i + 1);</span><br><span class="line">            else if (s.size() &lt; t.size()) return s.substr(i) == t.substr(i + 1);</span><br><span class="line">            else return s.substr(i + 1) == t.substr(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return abs((int)s.size() - (int)t.size()) == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>å¯¹æ¯”ä¸¤ä¸ªå­—ç¬¦ä¸²å¯¹åº”ä½ç½®ä¸Šçš„å­—ç¬¦ï¼Œå¦‚æžœé‡åˆ°ä¸åŒçš„æ—¶å€™ï¼Œè¿™æ—¶æˆ‘ä»¬çœ‹ä¸¤ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦å…³ç³»ï¼Œå¦‚æžœç›¸ç­‰ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ¯”è¾ƒå½“å‰ä½ç½®åŽçš„å­—ä¸²æ˜¯å¦ç›¸åŒï¼Œå¦‚æžœsçš„é•¿åº¦å¤§ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ¯”è¾ƒsçš„ä¸‹ä¸€ä¸ªä½ç½®å¼€å§‹çš„å­ä¸²ï¼Œå’Œtçš„å½“å‰ä½ç½®å¼€å§‹çš„å­ä¸²æ˜¯å¦ç›¸åŒï¼Œåä¹‹å¦‚æžœtçš„é•¿åº¦å¤§ï¼Œé‚£ä¹ˆæˆ‘ä»¬æ¯”è¾ƒtçš„ä¸‹ä¸€ä¸ªä½ç½®å¼€å§‹çš„å­ä¸²ï¼Œå’Œsçš„å½“å‰ä½ç½®å¼€å§‹çš„å­ä¸²æ˜¯å¦ç›¸åŒã€‚å¦‚æžœå¾ªçŽ¯ç»“æŸï¼Œéƒ½æ²¡æœ‰æ‰¾åˆ°ä¸åŒçš„å­—ç¬¦ï¼Œé‚£ä¹ˆæ­¤æ—¶æˆ‘ä»¬çœ‹ä¸¤ä¸ªå­—ç¬¦ä¸²çš„é•¿åº¦æ˜¯å¦ç›¸å·®1</p>
<h3 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38    Count and Say"></a>38    Count and Say</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public String countAndSay(int n) &#123;</span><br><span class="line">        if(n==1)</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb=new StringBuilder();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        String str=countAndSay(n-1);</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        char c=&apos;0&apos;;</span><br><span class="line">        int count=0;</span><br><span class="line">        for (int i=0;i&lt;str.length();i++)&#123;</span><br><span class="line">            c=str.charAt(i);</span><br><span class="line">            count=1;</span><br><span class="line">            while ((i+1)&lt;str.length()&amp;&amp;str.charAt(i+1)==c)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(count+&quot;&quot;+c);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>é€’å½’è¿”å›žå‰ä¸€è¡Œçš„ç»“æžœã€‚æ¯æ¬¡whileæ¥countç›¸åŒå­—ç¬¦çš„æ•°é‡ï¼Œç„¶åŽåŠ å…¥åˆ°stringbuilderä¸­ã€‚</p>
<h3 id="358-Rearrange-String-k-Distance-Apart"><a href="#358-Rearrange-String-k-Distance-Apart" class="headerlink" title="358    Rearrange String k Distance Apart"></a>358    Rearrange String k Distance Apart</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">string rearrangeString(string str, int k) &#123;</span><br><span class="line">        if (k == 0) return str;</span><br><span class="line">        string res;</span><br><span class="line">        int len = (int)str.size();</span><br><span class="line">        unordered_map&lt;char, int&gt; m;</span><br><span class="line">        priority_queue&lt;pair&lt;int, char&gt;&gt; q;</span><br><span class="line">        for (auto a : str) ++m[a];</span><br><span class="line">        for (auto it = m.begin(); it != m.end(); ++it) &#123;</span><br><span class="line">            q.push(&#123;it-&gt;second, it-&gt;first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            vector&lt;pair&lt;int, int&gt;&gt; v;</span><br><span class="line">            int cnt = min(k, len);</span><br><span class="line">            for (int i = 0; i &lt; cnt; ++i) &#123;</span><br><span class="line">                if (q.empty()) return &quot;&quot;;</span><br><span class="line">                auto t = q.top(); q.pop();</span><br><span class="line">                res.push_back(t.second);</span><br><span class="line">                if (--t.first &gt; 0) v.push_back(t);</span><br><span class="line">                --len;</span><br><span class="line">            &#125;</span><br><span class="line">            for (auto a : v) q.push(a);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>æˆ‘ä»¬éœ€è¦ä¸€ä¸ªå“ˆå¸Œè¡¨æ¥å»ºç«‹å­—ç¬¦å’Œå…¶å‡ºçŽ°æ¬¡æ•°ä¹‹é—´çš„æ˜ å°„ï¼Œç„¶åŽéœ€è¦ä¸€ä¸ªå †æ¥ä¿å­˜è¿™æ¯ä¸€å †æ˜ å°„ï¼ŒæŒ‰ç…§å‡ºçŽ°æ¬¡æ•°æ¥æŽ’åºã€‚ç„¶åŽå¦‚æžœå †ä¸ä¸ºç©ºæˆ‘ä»¬å°±å¼€å§‹å¾ªçŽ¯ï¼Œæˆ‘ä»¬æ‰¾å‡ºkå’Œstré•¿åº¦ä¹‹é—´çš„è¾ƒå°å€¼ï¼Œç„¶åŽä»Ž0éåŽ†åˆ°è¿™ä¸ªè¾ƒå°å€¼ï¼Œå¯¹äºŽæ¯ä¸ªéåŽ†åˆ°çš„å€¼ï¼Œå¦‚æžœæ­¤æ—¶å †ä¸ºç©ºäº†ï¼Œè¯´æ˜Žæ­¤ä½ç½®æ²¡æ³•å¡«å…¥å­—ç¬¦äº†ï¼Œè¿”å›žç©ºå­—ç¬¦ä¸²ï¼Œå¦åˆ™æˆ‘ä»¬ä»Žå †é¡¶å–å‡ºä¸€å¯¹æ˜ å°„ï¼Œç„¶åŽæŠŠå­—æ¯åŠ å…¥ç»“æžœresä¸­ï¼Œæ­¤æ—¶æ˜ å°„çš„ä¸ªæ•°å‡1ï¼Œå¦‚æžœå‡1åŽçš„ä¸ªæ•°ä»å¤§äºŽ0ï¼Œåˆ™æˆ‘ä»¬å°†æ­¤æ˜ å°„åŠ å…¥ä¸´æ—¶é›†åˆvä¸­ï¼ŒåŒæ—¶strçš„ä¸ªæ•°lenå‡1ï¼ŒéåŽ†å®Œä¸€æ¬¡ï¼Œæˆ‘ä»¬æŠŠä¸´æ—¶é›†åˆä¸­çš„æ˜ å°„å¯¹ç”±åŠ å…¥å †ä¸­ã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 12]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/14/Everyday-Leetcode-12/</url>
      <content type="html"><![CDATA[<h3 id="293-Flip-Game"><a href="#293-Flip-Game" class="headerlink" title="293    Flip Game"></a>293    Flip Game</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public generatePossibleNextMoves(string s) &#123;</span><br><span class="line"> StringBuilder sb = new StringBuilder();</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            </span><br><span class="line">            if (s.charAt(i) == &apos;+&apos;&amp;&amp; scharAt(i - 1) == &apos;+&apos;) &#123;</span><br><span class="line">            sb.append(s.substring(0, i - 1) + &quot;--&quot; + s.substrting(i + 1)));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return sb.toString(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>éåŽ† å¦‚æžœiå’Œi-1éƒ½æ˜¯åŠ åˆ™åŠ å…¥å­—ç¬¦ä¸²ã€‚<br><a id="more"></a></p>
<h3 id="294-Flip-Game-II"><a href="#294-Flip-Game-II" class="headerlink" title="294    Flip Game II"></a>294    Flip Game II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool canWin(string s) &#123;</span><br><span class="line">        for (int i = 1; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            if (s[i] == &apos;+&apos; &amp;&amp; s[i - 1] == &apos;+&apos; &amp;&amp; !canWin(s.substr(0, i - 1) + &quot;--&quot; + s.substr(i + 1))) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>é€’å½’è°ƒç”¨å¦‚æžœå°†è¿™ä¸¤ä¸ªä½ç½®å˜ä¸ºâ€“çš„å­—ç¬¦ä¸²ï¼Œå¦‚æžœè¿”å›žfalseï¼Œè¯´æ˜Žå½“å‰çŽ©å®¶å¯ä»¥èµ¢ï¼Œç»“æŸå¾ªçŽ¯è¿”å›žfalseã€‚</p>
<h3 id="290-Word-Pattern"><a href="#290-Word-Pattern" class="headerlink" title="290    Word Pattern"></a>290    Word Pattern</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean wordPattern(String pattern, String str) &#123;</span><br><span class="line">    String[] words = str.split(&quot; &quot;);</span><br><span class="line">    if (words.length != pattern.length())</span><br><span class="line">        return false;</span><br><span class="line">    Map index = new HashMap();</span><br><span class="line">    for (Integer i=0; i&lt;words.length; ++i)</span><br><span class="line">        if (index.put(pattern.charAt(i), i) != index.put(words[i], i))</span><br><span class="line">            return false;</span><br><span class="line">    return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>æž„å»ºhashmapï¼Œå’Œå‰é¢205åŽŸç†ä¸€æ ·ã€‚</p>
<h3 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242    Valid Anagram"></a>242    Valid Anagram</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">        </span><br><span class="line">        if (s.length() != t.length()) return false;</span><br><span class="line"></span><br><span class="line">        int n = s.length();</span><br><span class="line">        int[] freq = new int[26];</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            freq[s.charAt(i) - &apos;a&apos;]++; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (freq[t.charAt(i) - &apos;a&apos;]-- == 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>å»ºç«‹å•è¯è¡¨ï¼Œä¸¤ä¸ªforéåŽ†ã€‚</p>
<h3 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49    Group Anagrams"></a>49    Group Anagrams</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">   if (strs == null || strs.length == 0) return new ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">       Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">       for (String s : strs) &#123;</span><br><span class="line">           char[] ca = s.toCharArray();</span><br><span class="line">           Arrays.sort(ca);</span><br><span class="line">           String keyStr = String.valueOf(ca);</span><br><span class="line">           if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList&lt;String&gt;());</span><br><span class="line">           map.get(keyStr).add(s);</span><br><span class="line">       &#125;</span><br><span class="line">       return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>æŠŠæ¯ä¸ªå­—ç¬¦ä¸²æŽ’åºï¼Œè¿™æ ·å¾—åˆ°çš„keyStréƒ½ä¸€æ ·ï¼Œç„¶åŽå°†åŒä¸ªkeyçš„å­—ç¬¦ä¸²addè¿›åŒä¸€ä¸ªlistã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 11]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/13/Everyday-Leetcode-11/</url>
      <content type="html"><![CDATA[<h3 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344    Reverse String"></a>344    Reverse String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void reverseString(char[] s) &#123;</span><br><span class="line">   for(int i=0,j=s.length-1;i&lt;j;i++,j--)&#123;</span><br><span class="line">     char temp=s[i];</span><br><span class="line">     s[i]=s[j];</span><br><span class="line">     s[j]=temp;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>å¤´å°¾éåŽ†å¹¶äº¤æ¢ã€‚<br><a id="more"></a></p>
<h3 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151    Reverse Words in a String"></a>151    Reverse Words in a String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public String reverseWords(String s) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int i = n - 1;</span><br><span class="line">        while(i &gt;= 0) &#123;</span><br><span class="line">            if (s.charAt(i) == &apos; &apos;) &#123;i--; continue; &#125;;</span><br><span class="line">            int j = i - 1;</span><br><span class="line">            while(j &gt;= 0 &amp;&amp; s.charAt(j) != &apos; &apos;) j--;</span><br><span class="line">            sb.append(&quot; &quot;);</span><br><span class="line">            sb.append(s.substring(j + 1, i + 1));</span><br><span class="line">            i = j - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sb.length() &gt; 0) sb.deleteCharAt(0);</span><br><span class="line">        return sb.toString(); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>åŒæ ·ä¸¤ä¸ªæŒ‡é’ˆï¼Œéƒ½ä»Žå°¾éƒ¨å¼€å§‹ï¼Œié‡åˆ°ä¸æ˜¯ç©ºæ ¼åœä¸‹ï¼Œjé‡åˆ°ç©ºæ ¼åœä¸‹ï¼Œj+1åˆ°i+1ä¸ºè¯ã€‚</p>
<h3 id="186-Reverse-Words-in-a-String-II"><a href="#186-Reverse-Words-in-a-String-II" class="headerlink" title="186    Reverse Words in a String II"></a>186    Reverse Words in a String II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">åŒä¸Š</span><br></pre></td></tr></table></figure>
<p>åŒä¸Šã€‚</p>
<h3 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345    Reverse Vowels of a String"></a>345    Reverse Vowels of a String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> public  boolean isVowel(char a)&#123;</span><br><span class="line">	    switch(a)&#123;</span><br><span class="line">	         case (&apos;a&apos;) : return true;</span><br><span class="line">	         case (&apos;e&apos;) : return true;</span><br><span class="line">	         case (&apos;i&apos;) : return true;</span><br><span class="line">	         case (&apos;o&apos;) : return true;</span><br><span class="line">	         case (&apos;u&apos;) : return true;</span><br><span class="line">	         case (&apos;A&apos;) : return true;</span><br><span class="line">	         case (&apos;E&apos;) : return true;</span><br><span class="line">	         case (&apos;I&apos;) : return true;</span><br><span class="line">	         case (&apos;O&apos;) : return true;</span><br><span class="line">	         case (&apos;U&apos;) : return true;</span><br><span class="line">	         default : return false;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  String reverseVowels(String s) &#123;</span><br><span class="line">	     if (s.length()&lt;2) return s;</span><br><span class="line">	</span><br><span class="line">	     char[] tab = s.toCharArray();</span><br><span class="line">	     int j = tab.length - 1;</span><br><span class="line">	     int i = 0;</span><br><span class="line">	</span><br><span class="line">	     while( i &lt; j ) &#123;</span><br><span class="line"></span><br><span class="line">		if (!isVowel(tab[i]))</span><br><span class="line">			i++;	</span><br><span class="line">		else &#123;</span><br><span class="line">			while (j!=i &amp;&amp; !isVowel(tab[j]))</span><br><span class="line">				j--;</span><br><span class="line">			</span><br><span class="line">			char temp = tab[i];</span><br><span class="line">			tab[i] = tab[j];</span><br><span class="line">			tab[j] = temp;</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return new String(tab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆå°†stringå˜ä¸ºcharArrayï¼Œç„¶åŽä¾ç„¶ä»Žå¤´æ‰¾å…ƒéŸ³ï¼Œæ‰¾åˆ°åŽå†ä»Žæœªå¼€å§‹æ‰¾ã€‚æ‰¾åˆ°åŽäº¤æ¢ã€‚ æœ€åŽè¿”å›žnew Stringã€‚</p>
<h3 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="205    Isomorphic Strings"></a>205    Isomorphic Strings</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean isIsomorphic(String s, String t) &#123;</span><br><span class="line">        int[] m1 = new int[256];</span><br><span class="line">        int[] m2 = new int[256];</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if (m1[s.charAt(i)] != m2[t.charAt(i)]) return false;</span><br><span class="line">            m1[s.charAt(i)] = m2[t.charAt(i)] = i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>å¯ä»¥ç”¨ä¸¤ä¸ªhashmapï¼Œä½†æ˜¯æ—¶é—´ä¸åˆ’ç®—ã€‚å¯ä»¥ç”¨int[]ä»£æ›¿ï¼Œå¦‚æžœä¸ç›¸ç­‰è¯´æ˜Žæ¬¡åºä¸ç­‰ã€‚charå¯ä»¥è¡¨ç¤ºæˆ256çš„intï¼ˆasciiï¼‰ã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 10]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/11/Everyday-Leetcode-10/</url>
      <content type="html"><![CDATA[<h3 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28    Implement strStr()"></a>28    Implement strStr()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int strStr(String haystack, String needle) &#123;</span><br><span class="line">       if(needle==null||needle.length()==0) return 0;</span><br><span class="line">       if(haystack.length()&lt;needle.length()) return -1;</span><br><span class="line">       for(int i=0;i&lt;=haystack.length()-needle.length();++i)&#123;</span><br><span class="line">           int j=0;</span><br><span class="line">           for(;j&lt;needle.length();++j)&#123;</span><br><span class="line">                if (haystack.charAt(i + j) != needle.charAt(j)) break;</span><br><span class="line">           &#125;</span><br><span class="line">           if (j == needle.length()) return i;</span><br><span class="line">           &#125;</span><br><span class="line">       return -1;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>å¦‚æžœæœ‰ä½ç½®ä¸ç­‰çš„å°±è·³å‡ºå¾ªçŽ¯ï¼Œå¦‚æžœå¾ªçŽ¯é•¿åº¦ç­‰äºŽné•¿åº¦å°±è¿”å›žiã€‚å‰é¢ä¸¤ä¸ªcornercaseã€‚<br><a id="more"></a></p>
<h3 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14    Longest Common Prefix"></a>14    Longest Common Prefix</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">       if (strs == null || strs.length == 0) return &quot;&quot;;</span><br><span class="line">       for (int j = 0; j &lt; strs[0].length(); ++j) &#123;</span><br><span class="line">           for (int i = 0; i &lt; strs.length; ++i) &#123;</span><br><span class="line">               if (j &gt;= strs[i].length() || strs[i].charAt(j) != strs[0].charAt(j)) &#123;</span><br><span class="line">                   return strs[i].substring(0, j); </span><br><span class="line">               &#125;   </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return strs[0];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>å¦‚æžœä¸ç›¸ç­‰è¯´æ˜Žæœ€é•¿å‰ç¼€å·²æ‰¾åˆ°ï¼Œå¦åˆ™æœ€åŽè¿”å›žç¬¬ä¸€ä¸ªå•è¯å°±æ˜¯ç»“æžœã€‚</p>
<h3 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58    Length of Last Word"></a>58    Length of Last Word</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLastWord(String s) &#123;</span><br><span class="line">   if(s.length()&lt;1) return 0;</span><br><span class="line">       int res=0;</span><br><span class="line">       int i=s.length()-1;</span><br><span class="line">       while(i&gt;=0&amp;&amp;s.charAt(i)==&apos; &apos;) i--;</span><br><span class="line">       while(i&gt;=0&amp;&amp;s.charAt(i)!=&apos; &apos;) &#123;</span><br><span class="line">           res++;</span><br><span class="line">           i--;</span><br><span class="line">       &#125;</span><br><span class="line">      return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>ä»Žæœ«å°¾æ‰¾é½ï¼ŒæŠŠç©ºæ ¼åŽ»æŽ‰ï¼Œå†é‡åˆ°ç©ºæ ¼å°±ç»Ÿè®¡åˆ°è¿™æ®µä¸ºæ­¢çš„é•¿åº¦ã€‚æ³¨æ„i&gt;=0ä¸€å®šè¦åœ¨å‰é¢ï¼Œä¸ç„¶ä¼šè¶Šç•Œã€‚</p>
<h3 id="387-First-Unique-Character-in-a-String"><a href="#387-First-Unique-Character-in-a-String" class="headerlink" title="387    First Unique Character in a String"></a>387    First Unique Character in a String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> public int firstUniqChar(String s) &#123;</span><br><span class="line">    if(s==null||s.length()&lt;1) return -1;</span><br><span class="line">    if(s.length()==1) return 0;</span><br><span class="line">    for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">        if(s.lastIndexOf(s.charAt(i))==i &amp;&amp;s.indexOf(s.charAt(i))==i) return i;</span><br><span class="line">      &#125;</span><br><span class="line">     return -1;</span><br><span class="line">    &#125;</span><br><span class="line">//5ms</span><br><span class="line">public int firstUniqChar(String s) &#123;</span><br><span class="line">    int[] count = new int[26];</span><br><span class="line">        </span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            count[c - &apos;a&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int i = 0;</span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            if (count[c- &apos;a&apos;] == 1) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>å¦‚æžœfirstå’Œlastindexéƒ½æ˜¯iï¼Œè¯´æ˜Žæ˜¯å”¯ä¸€çš„ã€‚<br>ç¬¬äºŒç§è§£æ³•ï¼Œç»Ÿè®¡æ¯ä¸ªå­—æ¯çš„ä¸ªæ•°ï¼Œç„¶åŽ==1çš„å°±æ˜¯å”¯ä¸€çš„ã€‚</p>
<h3 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383    Ransom Note"></a>383    Ransom Note</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean canConstruct(String ransomNote, String magazine) &#123;</span><br><span class="line">    </span><br><span class="line">     int[] arr = new int[26];</span><br><span class="line">        for (int i = 0; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            arr[magazine.charAt(i) - &apos;a&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">            if(--arr[ransomNote.charAt(i)-&apos;a&apos;] &lt; 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>ç»Ÿè®¡æ¯ä¸ªå­—æ¯å‡ºçŽ°æ¬¡æ•°ã€‚å¦‚æžœâ€“åŽå°äºŽ0è¯´æ˜Žfalse å¦åˆ™trueã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 9 ]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/10/Everyday-Leetcode-9/</url>
      <content type="html"><![CDATA[<h3 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75    Sort Colors"></a>75    Sort Colors</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void sortColors(int[] nums) &#123;</span><br><span class="line">    // 1-pass</span><br><span class="line">    int p1 = 0, p2 = nums.length - 1, index = 0;</span><br><span class="line">    while (index &lt;= p2) &#123;</span><br><span class="line">        if (nums[index] == 0) &#123;</span><br><span class="line">            nums[index] = nums[p1];</span><br><span class="line">            nums[p1] = 0;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[index] == 2) &#123;</span><br><span class="line">            nums[index] = nums[p2];</span><br><span class="line">            nums[p2] = 2;</span><br><span class="line">            p2--;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2pass</span><br><span class="line">public void sortColors(int[] nums) &#123;</span><br><span class="line">        int rc=0,wc=0,bc=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(nums[i]==0) rc++;</span><br><span class="line">            else if(nums[i]==1) wc++;</span><br><span class="line">            else if(nums[i]==2) bc++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;nums.length;j++)&#123;</span><br><span class="line">        if(rc&gt;0)&#123;nums[j]=0;rc--;&#125;</span><br><span class="line">        else  if(wc&gt;0)&#123;nums[j]=1;wc--;&#125;</span><br><span class="line">        else   if(bc&gt;0)&#123;nums[j]=2;bc--;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>1passæ–¹æ³•ï¼Œåœ¨å¤´éƒ¨æ’å…¥0ï¼Œåœ¨å°¾éƒ¨æ’å…¥2ï¼Œå…¶ä»–1ä¸åŠ¨ã€‚<br>2passï¼Œç»Ÿè®¡æ•°ç›®ç„¶åŽé‡æ–°å†™å…¥ã€‚<br><a id="more"></a></p>
<h3 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="283    Move Zeroes"></a>283    Move Zeroes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> public void moveZeroes(int[] nums) &#123;</span><br><span class="line">         </span><br><span class="line">    if (nums == null || nums.length == 0) return;        </span><br><span class="line"></span><br><span class="line">    int insertPos = 0;</span><br><span class="line">    for (int num: nums) &#123;</span><br><span class="line">        if (num != 0) nums[insertPos++] = num;</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    while (insertPos &lt; nums.length) &#123;</span><br><span class="line">        nums[insertPos++] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>å¦‚æžœä¸ç­‰äºŽ0åˆ™åœ¨å‰é¢å¼€å§‹æ’å…¥ï¼Œç„¶åŽè¡¥è¶³0ã€‚</p>
<h3 id="376-Wiggle-Subsequence"><a href="#376-Wiggle-Subsequence" class="headerlink" title="376    Wiggle Subsequence"></a>376    Wiggle Subsequence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int wiggleMaxLength(int[] nums) &#123;</span><br><span class="line">        if (nums.length &lt; 2) return nums.length;</span><br><span class="line">        int up = 1;</span><br><span class="line">        int down = 1;</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; nums[i - 1]) &#123;</span><br><span class="line">                up = down + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums[i] &lt; nums[i - 1]) &#123;</span><br><span class="line">                down = up + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return Math.max(up, down); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>å¾ˆå·§å¦™çš„åšæ³•ï¼Œè®¾ç½®upå’Œdownï¼Œåªæœ‰ç¬¦åˆwiggleçš„æ‰ä¼šé€’å¢žï¼Œä¸ç„¶åœæ»žï¼Œæœ€åŽè¾“å‡ºmaxå³å¯ã€‚</p>
<h3 id="280-Wiggle-Sort"><a href="#280-Wiggle-Sort" class="headerlink" title="280    Wiggle Sort"></a>280    Wiggle Sort</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void wiggleSort(vector&lt;int&gt; &amp;nums) &#123;</span><br><span class="line">       if (nums.size() &lt;= 1) return;</span><br><span class="line">       for (int i = 1; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">           if ((i % 2 == 1 &amp;&amp; nums[i] &lt; nums[i - 1]) || (i % 2 == 0 &amp;&amp; nums[i] &gt; nums[i - 1])) &#123;</span><br><span class="line">               swap(nums[i], nums[i - 1]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>å¦‚æžœä¸ç¬¦åˆæ¡ä»¶å°±å’Œå‰é¢çš„äº¤æ¢ã€‚</p>
<h3 id="324-Wiggle-Sort-II"><a href="#324-Wiggle-Sort-II" class="headerlink" title="324    Wiggle Sort II"></a>324    Wiggle Sort II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void wiggleSort(int[] nums) &#123;</span><br><span class="line">       int[] copy = new int[nums.length];</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       for(int i = 0; i &lt; nums.length; i++) copy[i] = nums[i];</span><br><span class="line">       int index = 1;</span><br><span class="line">       for(int i = nums.length - 1; i &gt; (nums.length - 1) / 2; i--)&#123;</span><br><span class="line">           nums[index] = copy[i];</span><br><span class="line">           index += 2;</span><br><span class="line">       &#125;</span><br><span class="line">       index = 0;</span><br><span class="line">       for(int i = (nums.length - 1) / 2; i &gt;= 0; i--)&#123;</span><br><span class="line">           nums[index] = copy[i];</span><br><span class="line">           index += 2;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆå°†æ•°ç»„æŽ’åºï¼Œç„¶åŽå¤åˆ¶æ•°ç»„ï¼Œå°†åŽåŠéƒ¨åˆ†çš„æ•°ç»„æ¯2ä¸ªæ’å…¥ï¼Œå‰åŠéƒ¨åˆ†çš„æ•°ç»„ä¹Ÿæ¯2ä¸ªæ’å…¥ã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 8]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/09/Everyday-Leetcode-8/</url>
      <content type="html"><![CDATA[<h3 id="238-Product-of-Array-Except-Self"><a href="#238-Product-of-Array-Except-Self" class="headerlink" title="238    Product of Array Except Self"></a>238    Product of Array Except Self</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int[] productExceptSelf(int[] nums) &#123;</span><br><span class="line">       if(nums==null||nums.length&lt;=1) return null;</span><br><span class="line">        int[] res = new int[nums.length];</span><br><span class="line">       res[0] = 1;</span><br><span class="line">       for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">       res[i] = res[i - 1] * nums[i - 1];</span><br><span class="line">       &#125;</span><br><span class="line">       int right = 1;</span><br><span class="line">   for (int i = nums.length-1; i &gt;= 0; i--) &#123;</span><br><span class="line">       res[i] *= right;</span><br><span class="line">       right *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">   return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>è‡ªå·±åšçš„æ—¶å€™ç®—é”™äº†ï¼Œä»¥ä¸ºè¿™æ ·ä¸æ˜¯Oï¼ˆnï¼‰ï¼Œä¸è¿‡ç¡®å®žä¹Ÿå¾ˆå·§å¦™ã€‚ç¬¬ä¸€ééåŽ†ç®—iå·¦è¾¹çš„ç´¯ç§¯ï¼Œç¬¬äºŒéç®—iå³è¾¹çš„ç´¯ç§¯ã€‚å¾—å‡ºç»“æžœã€‚<br><a id="more"></a></p>
<h3 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152    Maximum Product Subarray"></a>152    Maximum Product Subarray</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int maxProduct(int[] nums) &#123;</span><br><span class="line">    int maxSum = nums[0];</span><br><span class="line">    int currentMax = nums[0];</span><br><span class="line">    int currentMin = nums[0];</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] &lt; 0)&#123;</span><br><span class="line">        int tmp = currentMax;</span><br><span class="line">        currentMax = currentMin;</span><br><span class="line">        currentMin = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentMax = Math.max(nums[i], currentMax * nums[i]);</span><br><span class="line">        currentMin = Math.min(nums[i], currentMin * nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum, currentMax);</span><br><span class="line">    &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>å¦‚æžœå°äºŽ0åˆ™äº¤æ¢currentMaxå’Œminï¼Œå°†åˆ°çŽ°åœ¨ä¸ºæ­¢æœ€å¤§å’Œæœ€å°çš„ä¹˜ç§¯éƒ½ä¿å­˜ä¸‹æ¥ã€‚æ³¨æ„æ¯”è¾ƒçš„æ˜¯nums[i]å’Œnums[i]*currentMax/minï¼Œè¿™æ ·ç›¸å½“äºŽå¯ä»¥ä»Žnums[i]é‡æ–°å¼€å§‹ç®—ä¹˜ç§¯ã€‚</p>
<h3 id="228-Summary-Ranges"><a href="#228-Summary-Ranges" class="headerlink" title="228    Summary Ranges"></a>228    Summary Ranges</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; summaryRanges(int[] nums) &#123;</span><br><span class="line">        List&lt;String&gt; list=new ArrayList();</span><br><span class="line">	if(nums.length==1)&#123;</span><br><span class="line">		list.add(nums[0]+&quot;&quot;);</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line">    for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">    	int a=nums[i];</span><br><span class="line">    	while(i+1&lt;nums.length&amp;&amp;(nums[i+1]-nums[i])==1)&#123;</span><br><span class="line">    		i++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	if(a!=nums[i])&#123;</span><br><span class="line">    		list.add(a+&quot;-&gt;&quot;+nums[i]);</span><br><span class="line">    	&#125;else&#123;</span><br><span class="line">    		list.add(a+&quot;&quot;);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>å¦‚æžœèƒ½æž„æˆè¿žç»­çš„å°±ä¸€ç›´èµ°åˆ°åº•ã€‚å¦‚æžœèµ°è¿‡äº†å°±è¾“å‡º-&gt;ï¼Œ æ²¡èµ°è¿‡å°±è¾“å‡ºåŽŸæœ‰çš„aã€‚å¤ªå·§å¦™ã€‚</p>
<h3 id="163-Missing-Ranges"><a href="#163-Missing-Ranges" class="headerlink" title="163    Missing Ranges"></a>163    Missing Ranges</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; findMissingRanges(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123;</span><br><span class="line">       vector&lt;string&gt; res;</span><br><span class="line">       int l = lower;</span><br><span class="line">       for (int i = 0; i &lt;= nums.size(); ++i) &#123;</span><br><span class="line">           int r = (i &lt; nums.size() &amp;&amp; nums[i] &lt;= upper) ? nums[i] : upper + 1;</span><br><span class="line">           if (l == r) ++l;</span><br><span class="line">           else if (r &gt; l) &#123;</span><br><span class="line">               res.push_back(r - l == 1 ? to_string(l) : to_string(l) + &quot;-&gt;&quot; + to_string(r - 1));</span><br><span class="line">               l = r + 1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>æˆ‘ä»¬é¦–å…ˆå°†lowerèµ‹ç»™lï¼Œç„¶åŽå¼€å§‹éåŽ†numsæ•°ç»„ï¼Œå¦‚æžœiå°äºŽnumsé•¿åº¦ä¸”å½“å‰æ•°å­—å°äºŽç­‰äºŽupperï¼Œæˆ‘ä»¬è®©rç­‰äºŽå½“å‰æ•°å­—ï¼Œå¦åˆ™å¦‚æžœå½“iç­‰äºŽnumsçš„é•¿åº¦æ—¶æˆ–è€…å½“å‰æ•°å­—å¤§äºŽupperæ—¶ï¼Œå°†rèµ‹ä¸ºupper+1ã€‚ç„¶åŽåˆ¤æ–­lå’Œrçš„å€¼ï¼Œè‹¥ç›¸åŒï¼Œlè‡ªå¢ž1ï¼Œå¦åˆ™å½“rå¤§äºŽlæ—¶ï¼Œè¯´æ˜Žç¼ºå¤±ç©ºé—´å­˜åœ¨ï¼Œæˆ‘ä»¬çœ‹lå’Œræ˜¯å¦å·®1ï¼Œå¦‚æžœæ˜¯ï¼Œè¯´æ˜Žåªç¼ºå¤±äº†ä¸€ä¸ªæ•°å­—ï¼Œè‹¥ä¸æ˜¯ï¼Œåˆ™è¯´æ˜Žç¼ºå¤±äº†ä¸€ä¸ªåŒºé—´ï¼Œæˆ‘ä»¬åˆ†åˆ«åŠ ä¸Šæ•°å­—æˆ–è€…åŒºé—´å³å¯ã€‚</p>
<h3 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88    Merge Sorted Array"></a>88    Merge Sorted Array</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">   int i=m-1, j=n-1, k=m+n-1;</span><br><span class="line">    while (i&gt;-1 &amp;&amp; j&gt;-1) nums1[k--]= (nums1[i]&gt;nums2[j]) ? nums1[i--] : nums2[j--];</span><br><span class="line">    while (j&gt;-1)         nums1[k--]=nums2[j--];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ç²¾å¦™ä¹‹å¤„åœ¨äºŽä¸¤ä¸ªwhileçš„æ¡ä»¶ã€‚é¦–å…ˆè‚¯å®šå¦‚æžœiå…ˆéåŽ†å®Œï¼Œjè¿˜æ²¡æœ‰éåŽ†å®Œçš„è¯ï¼Œæ˜¯å¯ä»¥åœ¨ä¸‹ä¸ªå¾ªçŽ¯å…¨éƒ¨æ’å…¥çš„ã€‚ å¦‚æžœjå…ˆéåŽ†å®Œï¼Œè¯´æ˜Žæ’å…¥å®Œæˆï¼Œå‰©ä¸‹çš„iå·²ç»åœ¨nums1é‡Œäº†ï¼Œè¿™å°±æ˜¯å·§å¦™ä¹‹å¤„ã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 7]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/06/Everyday-Leetcode-7/</url>
      <content type="html"><![CDATA[<h3 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239    Sliding Window Maximum"></a>239    Sliding Window Maximum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int[] maxSlidingWindow(int[] a, int k) &#123;		</span><br><span class="line">		if (a == null || k &lt;= 0) &#123;</span><br><span class="line">			return new int[0];</span><br><span class="line">		&#125;</span><br><span class="line">		int n = a.length;</span><br><span class="line">		int[] r = new int[n-k+1];</span><br><span class="line">		int ri = 0;</span><br><span class="line">		// store index</span><br><span class="line">		Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			// remove numbers out of range k</span><br><span class="line">			while (!q.isEmpty() &amp;&amp; q.peek() &lt; i - k + 1) &#123;</span><br><span class="line">				q.poll();</span><br><span class="line">			&#125;</span><br><span class="line">			// remove smaller numbers in k range as they are useless</span><br><span class="line">			while (!q.isEmpty() &amp;&amp; a[q.peekLast()] &lt; a[i]) &#123;</span><br><span class="line">				q.pollLast();</span><br><span class="line">			&#125;</span><br><span class="line">			// q contains index... r contains content</span><br><span class="line">			q.offer(i);</span><br><span class="line">			if (i &gt;= k - 1) &#123;</span><br><span class="line">				r[ri++] = a[q.peek()];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>è¿™é¢˜ç”¨åˆ°äº†ä¸ç†Ÿæ‚‰çš„æ•°æ®ç»“æž„Dequeï¼Œç”¨qä¿å­˜æ•´ä¸ªæ•°ç»„çš„ä¸‹æ ‡éåŽ†æ•´ä¸ªæ•°ç»„ï¼Œå¦‚æžœæ­¤æ—¶é˜Ÿåˆ—çš„é¦–å…ƒç´ æ˜¯i - kçš„è¯ï¼Œè¡¨ç¤ºæ­¤æ—¶çª—å£å‘å³ç§»äº†ä¸€æ­¥ï¼Œåˆ™ç§»é™¤é˜Ÿé¦–å…ƒç´ ã€‚ç„¶åŽæ¯”è¾ƒé˜Ÿå°¾å…ƒç´ å’Œå°†è¦è¿›æ¥çš„å€¼ï¼Œå¦‚æžœå°çš„è¯å°±éƒ½ç§»é™¤ï¼Œç„¶åŽæ­¤æ—¶æˆ‘ä»¬æŠŠé˜Ÿé¦–å…ƒç´ åŠ å…¥ç»“æžœä¸­å³å¯ã€‚<br><a id="more"></a></p>
<h3 id="295-Find-Median-from-Data-Stream"><a href="#295-Find-Median-from-Data-Stream" class="headerlink" title="295    Find Median from Data Stream"></a>295    Find Median from Data Stream</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class MedianFinder &#123;</span><br><span class="line"></span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    private Queue&lt;Long&gt; small = new PriorityQueue(),</span><br><span class="line">                        large = new PriorityQueue();</span><br><span class="line"></span><br><span class="line">    public void addNum(int num) &#123;</span><br><span class="line">        large.add((long) num);</span><br><span class="line">        small.add(-large.poll());</span><br><span class="line">        if (large.size() &lt; small.size())</span><br><span class="line">            large.add(-small.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double findMedian() &#123;</span><br><span class="line">        return large.size() &gt; small.size()</span><br><span class="line">               ? large.peek()</span><br><span class="line">               : (large.peek() - small.peek()) / 2.0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>è¿™é¢˜ç”¨äº†ä¸¤ä¸ªPriorityQueueï¼Œåˆ†åˆ«è®°å½•æ•°ç»„çš„ä¸¤ç«¯ï¼Œå§‹ç»ˆä¿æŒlargeæ•°é‡å¤§äºŽç­‰äºŽsmallï¼Œæ­¤æ—¶ä¸­ä½æ•°è¦ä¹ˆæ˜¯large.peekï¼Œè¦ä¹ˆæ˜¯largeä¸Žsmallå¤´éƒ¨å…ƒç´ çš„å·®/2ã€‚</p>
<h3 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53    Maximum Subarray"></a>53    Maximum Subarray</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">      int res=Integer.MIN_VALUE;</span><br><span class="line">      if (nums==null||nums.length&lt;1) return 0;</span><br><span class="line">      if (nums.length==1) return nums[0];</span><br><span class="line">      for(int i=1;i&lt;nums.length;i++)&#123;</span><br><span class="line">          if (nums[i-1]&gt;0)</span><br><span class="line">              nums[i]+=nums[i-1];</span><br><span class="line">      &#125;</span><br><span class="line">      for(int j:nums)&#123;</span><br><span class="line">          res= Math.max(res,j);</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>æ³¨æ„è¾¹ç•Œæƒ…å†µã€‚</p>
<h3 id="325-Maximum-Size-Subarray-Sum-Equals-k"><a href="#325-Maximum-Size-Subarray-Sum-Equals-k" class="headerlink" title="325    Maximum Size Subarray Sum Equals k"></a>325    Maximum Size Subarray Sum Equals k</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArrayLen(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int sum = 0, res = 0;</span><br><span class="line">        unordered_map&lt;int, int&gt; m;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            if (sum == k) res = i + 1;</span><br><span class="line">            else if (m.count(sum - k)) res = max(res, i - m[sum - k]);</span><br><span class="line">            if (!m.count(sum)) m[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ç”¨ä¸€ä¸ªå˜é‡sumè¾¹ç´¯åŠ è¾¹å¤„ç†ï¼Œåªè¦ä¿å­˜ç¬¬ä¸€ä¸ªå‡ºçŽ°è¯¥ç´¯ç§¯å’Œçš„ä½ç½®ï¼ŒåŽé¢å†å‡ºçŽ°ç›´æŽ¥è·³è¿‡ï¼Œè¿™æ ·ç®—ä¸‹æ¥å°±æ˜¯æœ€é•¿çš„å­æ•°ç»„ã€‚</p>
<h3 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209    Minimum Size Subarray Sum"></a>209    Minimum Size Subarray Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//Oï¼ˆnï¼‰åšæ³•</span><br><span class="line"> public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">        int i = 0, j = 0, sum = 0, min = Integer.MAX_VALUE;</span><br><span class="line">        while (j &lt; nums.length) &#123;</span><br><span class="line">            while (sum &lt; s &amp;&amp; j &lt; nums.length) sum += nums[j++];</span><br><span class="line">            if(sum&gt;=s)&#123;</span><br><span class="line">                while (sum &gt;= s &amp;&amp; i &lt; j) sum -= nums[i++];</span><br><span class="line">                min = Math.min(min, j - i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min == Integer.MAX_VALUE ? 0 : min;</span><br><span class="line">    &#125;</span><br><span class="line">//Oï¼ˆnlognï¼‰åšæ³•</span><br><span class="line">public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">        int i = 1, j = nums.length, min = 0;</span><br><span class="line">        while (i &lt;= j) &#123;</span><br><span class="line">            int mid = (i + j) / 2;</span><br><span class="line">            if (windowExist(mid, nums, s)) &#123;</span><br><span class="line">                j = mid - 1;</span><br><span class="line">                min = mid;</span><br><span class="line">            &#125; else i = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private boolean windowExist(int size, int[] nums, int s) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (i &gt;= size) sum -= nums[i - size];</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            if (sum &gt;= s) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆè®© right å‘å³ç§»ï¼Œç›´åˆ°å­æ•°ç»„å’Œå¤§äºŽç­‰äºŽç»™å®šå€¼æˆ–è€… right è¾¾åˆ°æ•°ç»„æœ«å°¾ï¼Œæ­¤æ—¶æˆ‘ä»¬æ›´æ–°æœ€çŸ­è·ç¦»ï¼Œå¹¶ä¸”å°† left åƒå³ç§»ä¸€ä½ï¼Œç„¶åŽå† sum ä¸­å‡åŽ»ç§»åŽ»çš„å€¼ï¼Œç„¶åŽé‡å¤ä¸Šé¢çš„æ­¥éª¤ï¼Œç›´åˆ° right åˆ°è¾¾æœ«å°¾ï¼Œä¸” left åˆ°è¾¾ä¸´ç•Œä½ç½®ï¼Œå³è¦ä¹ˆåˆ°è¾¾è¾¹ç•Œï¼Œè¦ä¹ˆå†å¾€å³ç§»åŠ¨ï¼Œå’Œå°±ä¼šå°äºŽç»™å®šå€¼ã€‚ æ­¤æ—¶å³ä¸ºæœ€å°åºåˆ—ã€‚<br>nlognï¼ŒäºŒåˆ†ï¼Œä¸æ–­æŸ¥æ‰¾è¿™æ®µä¸­æœ‰æ²¡æœ‰åºåˆ—å€¼ä¸ºsçš„åºåˆ—ï¼Œæœ‰åˆ™è¿”å›žtrueï¼Œæœ€åŽé”å®šsizeã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 6]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/05/Everyday-Leetcode-6/</url>
      <content type="html"><![CDATA[<h3 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128    Longest Consecutive Sequence"></a>128    Longest Consecutive Sequence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int longestConsecutive(int[] nums) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        Set&lt;Integer&gt; s = new HashSet&lt;Integer&gt;();</span><br><span class="line">        for (int num : nums) s.add(num);</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            if (s.remove(num)) &#123;</span><br><span class="line">                int pre = num - 1, next = num + 1;</span><br><span class="line">                while (s.remove(pre)) --pre;</span><br><span class="line">                while (s.remove(next)) ++next;</span><br><span class="line">                res = Math.max(res, next - pre - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆéƒ½åŠ å…¥åˆ°hashsetä¸­ï¼ŒéåŽ†numsï¼Œå¦‚æžœæœ‰ï¼Œåˆ™removeï¼Œç„¶åŽä¸€ä¸ªä¸ªremoveå‰ä¸€ä¸ªå’ŒåŽä¸€ä¸ªæ•°ï¼Œå¾—å‡ºæœ€å¤§åºåˆ—é•¿åº¦ã€‚<br><a id="more"></a></p>
<h3 id="164-Maximum-Gap"><a href="#164-Maximum-Gap" class="headerlink" title="164    Maximum Gap"></a>164    Maximum Gap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//æˆ‘çš„åšæ³•ï¼Œå…ˆæŽ’åºã€‚ faster than 37.82%ï¼Œless than 85.87%ã€‚</span><br><span class="line"> public int maximumGap(int[] nums) &#123;</span><br><span class="line">        if(nums.length&lt;2||nums==null) return 0;</span><br><span class="line">        int res=0;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">         if(nums.length==2)return nums[1]-nums[0];</span><br><span class="line">        for(int i=0;i&lt;=nums.length-2;i++)&#123;</span><br><span class="line">        res=Math.max(res,nums[i+1]-nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">//æ¡¶æŽ’åº</span><br><span class="line">public int maximumGap(int[] nums)&#123;</span><br><span class="line">   if (num == null || num.length &lt; 2)</span><br><span class="line">        return 0;</span><br><span class="line">    // get the max and min value of the array</span><br><span class="line">    int min = num[0];</span><br><span class="line">    int max = num[0];</span><br><span class="line">    for (int i:num) &#123;</span><br><span class="line">        min = Math.min(min, i);</span><br><span class="line">        max = Math.max(max, i);</span><br><span class="line">    &#125;</span><br><span class="line">    // the minimum possibale gap, ceiling of the integer division</span><br><span class="line">    int gap = (int)Math.ceil((double)(max - min)/(num.length - 1));</span><br><span class="line">    int[] bucketsMIN = new int[num.length - 1]; // store the min value in that bucket</span><br><span class="line">    int[] bucketsMAX = new int[num.length - 1]; // store the max value in that bucket</span><br><span class="line">    Arrays.fill(bucketsMIN, Integer.MAX_VALUE);</span><br><span class="line">    Arrays.fill(bucketsMAX, Integer.MIN_VALUE);</span><br><span class="line">    // put numbers into buckets</span><br><span class="line">    for (int i:num) &#123;</span><br><span class="line">        if (i == min || i == max)</span><br><span class="line">            continue;</span><br><span class="line">        int idx = (i - min) / gap; // index of the right position in the buckets</span><br><span class="line">        bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]);</span><br><span class="line">        bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    // scan the buckets for the max gap</span><br><span class="line">    int maxGap = Integer.MIN_VALUE;</span><br><span class="line">    int previous = min;</span><br><span class="line">    for (int i = 0; i &lt; num.length - 1; i++) &#123;</span><br><span class="line">        if (bucketsMIN[i] == Integer.MAX_VALUE &amp;&amp; bucketsMAX[i] == Integer.MIN_VALUE)</span><br><span class="line">            // empty bucket</span><br><span class="line">            continue;</span><br><span class="line">        // min value minus the previous value is the current gap</span><br><span class="line">        maxGap = Math.max(maxGap, bucketsMIN[i] - previous);</span><br><span class="line">        // update previous bucket value</span><br><span class="line">        previous = bucketsMAX[i];</span><br><span class="line">    &#125;</span><br><span class="line">    maxGap = Math.max(maxGap, max - previous); // updata the final max value gap</span><br><span class="line">    return maxGap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆè¿›è¡Œæ¡¶æŽ’åºï¼Œç„¶åŽéåŽ†æ¡¶ï¼Œç®—å‡ºå¹¶è®°å½•æœ€å¤§çš„gapï¼ŒreturnmaxGapã€‚</p>
<h3 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287    Find the Duplicate Number"></a>287    Find the Duplicate Number</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//æˆ‘çš„è§£æ³•ï¼Œæ¯”è¾ƒæœ´ç´ ã€‚</span><br><span class="line"> public int findDuplicate(int[] nums) &#123;</span><br><span class="line">        if(nums==null||nums.length&lt;1) return 0;</span><br><span class="line">        if(nums.length==2) return nums[0];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for(int i=0;i&lt;nums.length-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i]==nums[i+1]) return nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">//å‡»è´¥100%è§£æ³•ã€‚</span><br><span class="line"> public int findDuplicate(int[] nums) &#123;</span><br><span class="line">        if (nums.length &gt; 1)&#123;</span><br><span class="line">		int slow = nums[0];</span><br><span class="line">		int fast = nums[nums[0]];</span><br><span class="line">		while (slow != fast)&#123;</span><br><span class="line">			slow = nums[slow];</span><br><span class="line">			fast = nums[nums[fast]];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fast = 0;</span><br><span class="line">		while (fast != slow)&#123;</span><br><span class="line">			fast = nums[fast];</span><br><span class="line">			slow = nums[slow];</span><br><span class="line">		&#125;</span><br><span class="line">		return slow;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ä½¿ç”¨ä¸¤ä¸ªæŒ‡é’ˆï¼Œfastæ¯æ¬¡èµ°ä¸¤æ­¥ï¼Œslowæ¯æ¬¡èµ°ä¸€æ­¥ï¼Œfast==slowæ—¶è¯´æ˜Žåœ¨çŽ¯ä¸­ï¼Œåªè¦æ‰¾åˆ°çŽ¯çš„èµ·å§‹ä½ç½®ï¼Œæ­¤æ—¶fastä¸º0,åŒæ­¥æœç´¢ã€‚å†æ¬¡ç›¸ç­‰æ—¶å°±æ˜¯ç­”æ¡ˆã€‚</p>
<h3 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4    Median of Two Sorted Arrays"></a>4    Median of Two Sorted Arrays</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">       int m = nums1.length, n = nums2.length, left = (m + n + 1) / 2, right = (m + n + 2) / 2;</span><br><span class="line">       return (findKth(nums1, nums2, left) + findKth(nums1, nums2, right)) / 2.0;</span><br><span class="line">   &#125;</span><br><span class="line">   int findKth(int[] nums1, int[] nums2, int k) &#123;</span><br><span class="line">       int m = nums1.length, n = nums2.length;</span><br><span class="line">       if (m == 0) return nums2[k - 1];</span><br><span class="line">       if (n == 0) return nums1[k - 1];</span><br><span class="line">       if (k == 1) return Math.min(nums1[0], nums2[0]);</span><br><span class="line">       int i = Math.min(m, k / 2), j = Math.min(n, k / 2);</span><br><span class="line">       if (nums1[i - 1] &gt; nums2[j - 1]) &#123;</span><br><span class="line">           return findKth(nums1, Arrays.copyOfRange(nums2, j, n), k - j);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return findKth(Arrays.copyOfRange(nums1, i, m), nums2, k - i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆæˆ‘ä»¬è¦åˆ¤æ–­æ•°ç»„æ˜¯å¦ä¸ºç©ºï¼Œä¸ºç©ºçš„è¯ï¼Œç›´æŽ¥åœ¨å¦ä¸€ä¸ªæ•°ç»„æ‰¾ç¬¬Kä¸ªå³å¯ã€‚è¿˜æœ‰ä¸€ç§æƒ…å†µæ˜¯å½“ K = 1 æ—¶ï¼Œè¡¨ç¤ºæˆ‘ä»¬è¦æ‰¾ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œåªè¦æ¯”è¾ƒä¸¤ä¸ªæ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ ï¼Œè¿”å›žè¾ƒå°çš„é‚£ä¸ªå³å¯ã€‚è¿™é‡Œæˆ‘ä»¬åˆ†åˆ«å–å‡ºä¸¤ä¸ªæ•°ç»„çš„ç¬¬ K/2 ä¸ªæ•°å­—çš„ä½ç½®åæ ‡iå’Œjï¼Œä¸ºäº†é¿å…æ•°ç»„æ²¡æœ‰ç¬¬ K/2 ä¸ªæ•°ç»„çš„æƒ…å†µï¼Œæˆ‘ä»¬æ¯æ¬¡éƒ½å’Œæ•°ç»„é•¿åº¦åšæ¯”è¾ƒï¼Œå–å‡ºè¾ƒå°å€¼ã€‚</p>
<h3 id="289-Game-of-Life"><a href="#289-Game-of-Life" class="headerlink" title="289    Game of Life"></a>289    Game of Life</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void gameOfLife(int[][] board) &#123;</span><br><span class="line">    if (board == null || board.length == 0) return;</span><br><span class="line">    int m = board.length, n = board[0].length;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            int lives = liveNeighbors(board, m, n, i, j);</span><br><span class="line"></span><br><span class="line">            // In the beginning, every 2nd bit is 0;</span><br><span class="line">            // So we only need to care about when will the 2nd bit become 1.</span><br><span class="line">            if (board[i][j] == 1 &amp;&amp; lives &gt;= 2 &amp;&amp; lives &lt;= 3) &#123;  </span><br><span class="line">                board[i][j] = 3; // Make the 2nd bit 1: 01 ---&gt; 11</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[i][j] == 0 &amp;&amp; lives == 3) &#123;</span><br><span class="line">                board[i][j] = 2; // Make the 2nd bit 1: 00 ---&gt; 10</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            board[i][j] &gt;&gt;= 1;  // Get the 2nd state.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int liveNeighbors(int[][] board, int m, int n, int i, int j) &#123;</span><br><span class="line">    int lives = 0;</span><br><span class="line">    for (int x = Math.max(i - 1, 0); x &lt;= Math.min(i + 1, m - 1); x++) &#123;</span><br><span class="line">        for (int y = Math.max(j - 1, 0); y &lt;= Math.min(j + 1, n - 1); y++) &#123;</span><br><span class="line">            lives += board[x][y] &amp; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lives -= board[i][j] &amp; 1;</span><br><span class="line">    return lives;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ç”¨1234çºªå½•çŠ¶æ€ï¼Œ&gt;&gt;1 æ¥èŽ·å¾—æœ€ç»ˆçŠ¶æ€ã€‚ liveNeighborsç»Ÿè®¡å‘¨è¾¹æ´»ç€çš„é‚»å±…ã€‚</p>
<h3 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57    Insert Interval"></a>57    Insert Interval</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int[][] insert(int[][] intervals, int[] newInterval) &#123;</span><br><span class="line">        // Time : O(n) Space : O(n)</span><br><span class="line">        if(newInterval == null) return intervals;</span><br><span class="line">        int[][] list = new int[intervals.length + 1][2];</span><br><span class="line">        int i = 0;</span><br><span class="line">        int idx = 0;</span><br><span class="line">        while(i &lt; intervals.length &amp;&amp; intervals[i][1] &lt; newInterval[0]) &#123;</span><br><span class="line">            list[idx][0] = intervals[i][0];</span><br><span class="line">            list[idx++][1] = intervals[i++][1];</span><br><span class="line">        &#125;</span><br><span class="line">        while(i &lt; intervals.length &amp;&amp; intervals[i][0] &lt;= newInterval[1]) &#123;</span><br><span class="line">            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);</span><br><span class="line">            newInterval[1] = Math.max(newInterval[1], intervals[i++][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        list[idx][0] = newInterval[0];</span><br><span class="line">        list[idx++][1] = newInterval[1];</span><br><span class="line">        while(i &lt; intervals.length) &#123;</span><br><span class="line">            list[idx][0] = intervals[i][0];</span><br><span class="line">            list[idx++][1] = intervals[i++][1];</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] res = new int[idx][2];</span><br><span class="line">        for(int j = 0; j &lt; idx; j++) &#123;</span><br><span class="line">            res[j][0] = list[j][0];</span><br><span class="line">            res[j][1] = list[j][1];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>é¦–å…ˆå¦‚æžœåŽŸæ¥çš„intervalçš„ç¬¬iä¸ªæ•°å¯¹çš„ç¬¬2ä¸ªæ•°å°äºŽnewIntervalçš„ç¬¬ä¸€ä¸ªæ•°ï¼Œè¯´æ˜Žä¸é‡å ï¼Œç›´æŽ¥åŠ å…¥æ–°çš„listã€‚å¦‚æžœåŽŸæ¥çš„intervalçš„ç¬¬iä¸ªæ•°å¯¹çš„ç¬¬1ä¸ªæ•°å°äºŽç­‰äºŽnewIntervalçš„ç¬¬äºŒä¸ªæ•°ï¼Œè¯´æ˜Žé‡å ï¼Œå°†ä¸¤è¾¹çš„æœ€å°å’Œæœ€å¤§å€¼è®°å½•åˆ°newintervalã€‚ç„¶åŽæ’å…¥listã€‚æœ€åŽå°†intervalå‰©ä¸‹çš„å€¼éƒ½æ’å…¥listï¼Œå†å°†listçš„å‰idxä¸ªæ•°å¯¹å–å‡ºï¼Œå°±æ˜¯ç­”æ¡ˆã€‚</p>
<h3 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56    Merge Intervals"></a>56    Merge Intervals</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int[][] merge(int[][] intervals) &#123;</span><br><span class="line">        List&lt;int[]&gt; arr = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals, new Comparator&lt;int[]&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(int[] a, int[] b)&#123;</span><br><span class="line">                return a[0] - b[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        for(int i = 0; i &lt; intervals.length;i++)&#123;</span><br><span class="line">            int[] interval = new int[2];</span><br><span class="line">            interval[0] = intervals[i][0];</span><br><span class="line">            int max = intervals[i][1];</span><br><span class="line">            while(i &lt; intervals.length-1 &amp;&amp; max &gt;= intervals[i+1][0])&#123;</span><br><span class="line">                max = Math.max(max, intervals[i+1][1]);</span><br><span class="line">                i=i+1;</span><br><span class="line">            &#125;</span><br><span class="line">            interval[1] = max;</span><br><span class="line">            arr.add(interval);</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] answer = new int[arr.size()][2];</span><br><span class="line">        for(int i = 0; i &lt; arr.size(); i++)&#123;</span><br><span class="line">            answer[i] = arr.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>é‡å†™äº†compareæ–¹æ³•ï¼Œè¿”å›žç¬¬ä¸€ä¸ªæ•°ç›¸å‡çš„ç»“æžœã€‚ç„¶åŽå°†intervalsæŽ’åºï¼ŒéåŽ†æ¯ä¸ªæ•°å¯¹ï¼Œè®°å½•æœ€å¤§å€¼maxï¼Œå®žçŽ°æŠŠé‡å çš„mergeçš„æ“ä½œï¼Œå°†æ¯ä¸ªæ•°å¯¹åŠ å…¥arrã€‚</p>
<h3 id="252-Meeting-Rooms"><a href="#252-Meeting-Rooms" class="headerlink" title="252    Meeting Rooms"></a>252    Meeting Rooms</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//è¢«é”åªèƒ½æ‰¾C++è§£æ³•</span><br><span class="line">bool canAttendMeetings(vector&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](const Interval &amp;a, const Interval &amp;b)&#123;return a.start &lt; b.start;&#125;);</span><br><span class="line">        for (int i = 1; i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">            if (intervals[i].start &lt; intervals[i - 1].end) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>å…ˆæŽ’åºï¼Œå¦‚æžœåŒºé—´çš„å¼€å§‹å°äºŽå‰ä¸€ä¸ªåŒºé—´çš„ç»“æŸè¯´æ˜Žé‡å ã€‚</p>
<h3 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253    Meeting Rooms II"></a>253    Meeting Rooms II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//è¢«é”åªèƒ½æ‰¾C++è§£æ³•</span><br><span class="line">int minMeetingRooms(vector&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        map&lt;int, int&gt; m;</span><br><span class="line">        for (auto a : intervals) &#123;</span><br><span class="line">            ++m[a.start];</span><br><span class="line">            --m[a.end];</span><br><span class="line">        &#125;</span><br><span class="line">        int rooms = 0, res = 0;</span><br><span class="line">        for (auto it : m) &#123;</span><br><span class="line">            res = max(res, rooms += it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>éåŽ†æ—¶é—´åŒºé—´ï¼Œå¯¹äºŽèµ·å§‹æ—¶é—´ï¼Œæ˜ å°„å€¼è‡ªå¢ž1ï¼Œå¯¹äºŽç»“æŸæ—¶é—´ï¼Œæ˜ å°„å€¼è‡ªå‡1ï¼Œç„¶åŽå®šä¹‰ç»“æžœå˜é‡ resï¼Œå’Œæˆ¿é—´æ•° roomsï¼ŒéåŽ† TreeMapï¼Œæ—¶é—´ä»Žå°åˆ°å¤§ï¼Œæˆ¿é—´æ•°æ¯æ¬¡åŠ ä¸Šæ˜ å°„å€¼ï¼Œç„¶åŽæ›´æ–°ç»“æžœ resï¼Œé‡åˆ°èµ·å§‹æ—¶é—´ï¼Œæ˜ å°„æ˜¯æ­£æ•°ï¼Œåˆ™æˆ¿é—´æ•°ä¼šå¢žåŠ ï¼Œå¦‚æžœä¸€ä¸ªæ—¶é—´æ˜¯ä¸€ä¸ªä¼šè®®çš„ç»“æŸæ—¶é—´ï¼Œä¹Ÿæ˜¯å¦ä¸€ä¸ªä¼šè®®çš„å¼€å§‹æ—¶é—´ï¼Œåˆ™æ˜ å°„å€¼å…ˆå‡åŽåŠ ä»ä¸º0ï¼Œå¹¶ä¸ç”¨åˆ†é…æ–°çš„æˆ¿é—´ï¼Œè€Œç»“æŸæ—¶é—´çš„æ˜ å°„å€¼ä¸ºè´Ÿæ•°æ›´ä¸ä¼šå¢žåŠ æˆ¿é—´æ•°ã€‚</p>
<h3 id="352-Data-Stream-as-Disjoint-Intervals"><a href="#352-Data-Stream-as-Disjoint-Intervals" class="headerlink" title="352    Data Stream as Disjoint Intervals"></a>352    Data Stream as Disjoint Intervals</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">//è€é¢˜ç›®ç”¨Intervalæ—¶</span><br><span class="line">class SummaryRanges &#123;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">     Map&lt;Integer, Interval&gt; smap;</span><br><span class="line">    Map&lt;Integer, Interval&gt; emap;</span><br><span class="line">    Set&lt;Integer&gt; added;</span><br><span class="line"></span><br><span class="line">    public SummaryRanges() &#123;</span><br><span class="line">        smap = new TreeMap&lt;&gt;();</span><br><span class="line">        emap = new TreeMap&lt;&gt;();</span><br><span class="line">        added = new HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addNum(int val) &#123;</span><br><span class="line">        </span><br><span class="line">        if(added.contains(val)) return;</span><br><span class="line">        added.add(val);</span><br><span class="line">        </span><br><span class="line">        Interval s = smap.get(val+1);</span><br><span class="line">        Interval e = emap.get(val-1);</span><br><span class="line">        </span><br><span class="line">        smap.remove(val+1);</span><br><span class="line">        emap.remove(val-1);</span><br><span class="line"> </span><br><span class="line">        Interval n = new Interval(e!=null?e.start:val, s!=null?s.end:val);</span><br><span class="line">        smap.put(n.start, n);</span><br><span class="line">        emap.put(n.end, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public List&lt;Interval&gt; getIntervals() &#123;</span><br><span class="line">        return new ArrayList&lt;&gt;(smap.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//æ–°é¢˜ç›®ç”¨int[][]æ—¶</span><br><span class="line">class SummaryRanges &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;int[]&gt; intervals;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    public SummaryRanges() &#123;</span><br><span class="line">        intervals = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addNum(int val) &#123;</span><br><span class="line">        boolean find = false;</span><br><span class="line">        for (int[] interval : intervals) &#123;</span><br><span class="line">            if (val == interval[0] - 1) &#123;</span><br><span class="line">                interval[0] = val;</span><br><span class="line">                find = true;</span><br><span class="line">            &#125; else if (val == interval[1] + 1) &#123;</span><br><span class="line">                interval[1] = val;</span><br><span class="line">                find = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!find) &#123;</span><br><span class="line">            int[] tmp = new int[2];</span><br><span class="line">            tmp[0] = val;</span><br><span class="line">            tmp[1] = val;</span><br><span class="line">            intervals.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int[][] getIntervals() &#123;</span><br><span class="line">        Collections.sort(intervals, (a, b) -&gt; &#123;</span><br><span class="line">            if (a[0] == b[0]) &#123;</span><br><span class="line">                return a[1] - b[1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return a[0] - b[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //merge</span><br><span class="line">        List&lt;int[]&gt; merged = new ArrayList&lt;&gt;();</span><br><span class="line">        int[] prev = null;</span><br><span class="line">        for (int[] cur : intervals) &#123;</span><br><span class="line">            if (prev == null || cur[0] &gt; prev[1] + 1) &#123;</span><br><span class="line">                merged.add(cur);</span><br><span class="line">                prev = cur;</span><br><span class="line">            &#125; else if (cur[1] &gt; prev[1]) &#123;</span><br><span class="line">                prev[1] = cur[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals = merged;</span><br><span class="line">        int[][] res = new int[merged.size()][2];</span><br><span class="line">        for (int i = 0; i &lt; merged.size(); i++) &#123;</span><br><span class="line">            res[i] = merged.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>å½“addNumæ—¶ï¼Œ å…ˆä»Žstartmapå’Œendmapé‡Œé¢å°è¯•getï¼Œå¦‚æžœæœ‰å°±ç”¨åŽŸæ¥çš„start/endå€¼ä½œä¸ºæ–°çš„åŒºé—´ï¼Œæ²¡æœ‰å°±ç”¨valä½œä¸ºæ–°çš„åŒºé—´å¹¶putè¿›smapå’Œemapã€‚æ–°é¢˜ç›®æ€æƒ³ä¸€æ ·ï¼Œå¤šäº†åœ¨getIntervalä¸­ mergç­‰ç­‰è¿‡ç¨‹ï¼Œå¦‚æžœcur[0]å¤§äºŽå‰ä¸€ä¸ªçš„end+1æˆ–è€…å‰ä¸€ä¸ªä¸ºnullåˆ™ç›´æŽ¥addï¼Œå¦åˆ™å‰ä¸€ä¸ªçš„endä¸ºçŽ°åœ¨çš„endã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 5]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/04/Everyday-Leetcode-5/</url>
      <content type="html"><![CDATA[<h3 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188    Best Time to Buy and Sell Stock IV"></a>188    Best Time to Buy and Sell Stock IV</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">int n = prices.length;</span><br><span class="line">if (n &lt;= 1)</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">if (k &gt;=  n/2) &#123;</span><br><span class="line">	int maxPro = 0;</span><br><span class="line">	for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">		if (prices[i] &gt; prices[i-1])</span><br><span class="line">			maxPro += prices[i] - prices[i-1];</span><br><span class="line">	&#125;</span><br><span class="line">	return maxPro;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   int[][] dp = new int[k+1][n];</span><br><span class="line">   for (int i = 1; i &lt;= k; i++) &#123;</span><br><span class="line">   	int localMax = dp[i-1][0] - prices[0];</span><br><span class="line">   	for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">   		dp[i][j] = Math.max(dp[i][j-1],  prices[j] + localMax);</span><br><span class="line">   		localMax = Math.max(localMax, dp[i-1][j] - prices[j]);</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return dp[k][n-1];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>å¦‚æžœKå¤§äºŽN/2,è¯´æ˜Žå¯ä»¥åšæœ€å¤šçš„äº¤æ˜“æ¬¡æ•°ï¼Œä¹Ÿå°±æ˜¯N/2ï¼Œæ­¤æ—¶åªè¦æ˜¯ç›ˆåˆ©çš„äº¤æ˜“éƒ½åšï¼Œå¾—åˆ°æœ€å¤§çš„æ”¶ç›Šã€‚ elseçš„è¯è¿›è¡Œdpã€‚dp[i][j-1]æ˜¯ä¸äº¤æ˜“çš„æƒ…å†µï¼Œprices[j]+localMaxæ˜¯åœ¨jå¤©äº¤æ˜“çš„æƒ…å†µã€‚<br><a id="more"></a></p>
<h3 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309    Best Time to Buy and Sell Stock with Cooldown"></a>309    Best Time to Buy and Sell Stock with Cooldown</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">   if(prices.length==0 ||prices==null) return 0;</span><br><span class="line">   int buy=Integer.MIN_VALUE;</span><br><span class="line">   int presell=0,prebuy=0,sell=0;</span><br><span class="line">       for(int i: prices)&#123;</span><br><span class="line">           prebuy=buy;</span><br><span class="line">           buy=Math.max(presell-i,prebuy);</span><br><span class="line">           presell=sell;</span><br><span class="line">           sell=Math.max(prebuy+i,presell);</span><br><span class="line">       &#125;</span><br><span class="line">   return sell;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>é€’æŽ¨å¼ï¼š buyçš„æƒ…å†µï¼Œè¦ä¹ˆä¸ä¹°ï¼ˆprebuy,è®°å½•i-1å¤©ï¼‰ï¼Œè¦ä¹ˆåœ¨i-2å¤©å‰sellï¼Œç„¶åŽåœ¨iå¤©buyã€‚ sellçš„æƒ…å†µï¼Œè¦ä¹ˆä¸å–ï¼ˆpresellï¼Œè®°å½•i-1å¤©ï¼‰ï¼Œè¦ä¹ˆåœ¨ï¼ˆi-1å¤©ï¼‰buyï¼Œç„¶åŽåœ¨iå¤©sellã€‚</p>
<h3 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11    Container With Most Water"></a>11    Container With Most Water</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//è‡ªå·±çš„åˆå§‹æƒ³æ³• ä»…ä»…æˆ˜èƒœ5.02%</span><br><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">        if(height==null || height.length&lt;=1) return 0;</span><br><span class="line">        int ans=Integer.MIN_VALUE;</span><br><span class="line">        for(int i=height.length-1;i&gt;=0;i--)</span><br><span class="line">            for(int j=0;j&lt;height.length;j++)&#123;</span><br><span class="line">                ans=Math.max(Math.min(height[i],height[j])*(i-j),ans);</span><br><span class="line">            &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">//ä¼˜åŒ–åŽ faster than 97.7%</span><br><span class="line"> public int maxArea(int[] height) &#123;</span><br><span class="line">        if(height==null || height.length&lt;=1) return 0;</span><br><span class="line">        int left = 0, right = height.length - 1;</span><br><span class="line">	    int maxArea = 0;</span><br><span class="line"></span><br><span class="line">	    while (left &lt; right) &#123;</span><br><span class="line">		maxArea = Math.max(maxArea, Math.min(height[left], height[right])</span><br><span class="line">				* (right - left));</span><br><span class="line">		if (height[left] &lt; height[right])</span><br><span class="line">			left++;</span><br><span class="line">		else</span><br><span class="line">			right--;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>å¼€å§‹æƒ³æ³•å¤ªç²—æš´ï¼Œå…¶å®žåªè¦ä¸¤å¤´å¾€ä¸­é—´ç›¸é‡ï¼ŒéåŽ†ä¸€éå³å¯ã€‚</p>
<h3 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42    Trapping Rain Water"></a>42    Trapping Rain Water</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] A)&#123;</span><br><span class="line">    int a=0;</span><br><span class="line">    int b=A.length-1;</span><br><span class="line">    int max=0;</span><br><span class="line">    int leftmax=0;</span><br><span class="line">    int rightmax=0;</span><br><span class="line">    while(a&lt;=b)&#123;</span><br><span class="line">        leftmax=Math.max(leftmax,A[a]);</span><br><span class="line">        rightmax=Math.max(rightmax,A[b]);</span><br><span class="line">        if(leftmax&lt;rightmax)&#123;</span><br><span class="line">            max+=(leftmax-A[a]);       // leftmax is smaller than rightmax, so the (leftmax-A[a]) water can be stored</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            max+=(rightmax-A[b]);</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ä¹Ÿæ˜¯ä¸¤å¤´å¾€ä¸­é—´ç›¸é‡ï¼Œæ¯æ ¼çš„é¢ç§¯åˆšå¥½æ˜¯leftmax-A[a]æˆ–è€…rightmax-A[b] ä¹˜ä»¥1ã€‚</p>
<h3 id="334-Increasing-Triplet-Subsequence"><a href="#334-Increasing-Triplet-Subsequence" class="headerlink" title="334    Increasing Triplet Subsequence"></a>334    Increasing Triplet Subsequence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public boolean increasingTriplet(int[] nums) &#123;</span><br><span class="line">         int small = Integer.MAX_VALUE, big = Integer.MAX_VALUE;</span><br><span class="line">        for (int n : nums) &#123;</span><br><span class="line">            if (n &lt;= small) &#123; small = n; &#125;</span><br><span class="line">            else if (n &lt;= big) &#123; big = n; &#125; </span><br><span class="line">            else return true; </span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>å­˜å‚¨éåŽ†è¿‡ç¨‹ä¸­çš„æœ€å°å€¼ä¸Žå¤§äºŽæœ€å°å€¼å°äºŽæœ€å¤§å€¼çš„å€¼ã€‚å¦‚æžœæ‰¾åˆ°èƒ½æž„æˆåºåˆ—çš„ä¸‰ä¸ªnåˆ™return trueï¼Œå¦åˆ™return falseã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 4]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/03/Everyday-Leetcode-4/</url>
      <content type="html"><![CDATA[<h3 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55    Jump Game"></a>55    Jump Game</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     public boolean canJump(int[] nums) &#123;</span><br><span class="line">        if(nums.length&lt;2)</span><br><span class="line">            return true;</span><br><span class="line">        if(nums[0]&lt;1)</span><br><span class="line">            return false;</span><br><span class="line">        int curr=nums[0];</span><br><span class="line">        for(int i =1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(nums[i]&gt;=curr) curr=nums[i];   </span><br><span class="line">            else curr--;</span><br><span class="line">            if(curr&lt;=0&amp;&amp;i!=nums.length-1) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>éåŽ†æ•°ç»„ï¼Œå¦‚æžœä¸‹ä¸€æ­¥èƒ½æ¯”currentèµ°å¾—è¿œå°±èµ°ï¼Œå¦åˆ™current-1ï¼ˆæ¯ä¸€æ­¥èŠ±çš„è·ç¦»ï¼‰ã€‚å¦‚æžœcurrent&lt;=0æ—¶è¿˜æ²¡æœ‰èµ°åˆ°å°½å¤´ï¼Œè¯´æ˜Žæ— æ³•è·³åˆ°ã€‚å¦‚æžœæ²¡æœ‰return falseè¯´æ˜Žå¯ä»¥è·³åˆ°ã€‚æ­¤å¤„greedyæ¯”dpæ›´å¥½ã€‚<br><a id="more"></a></p>
<h3 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45    Jump Game II"></a>45    Jump Game II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int jump(int[] nums) &#123;</span><br><span class="line">       int end = 0;</span><br><span class="line">       int furthest =0;</span><br><span class="line">       int result=0;</span><br><span class="line">       </span><br><span class="line">       for(int i=0;i&lt;nums.length-1;i++)&#123;</span><br><span class="line">           furthest = Math.max(furthest, i+nums[i]);</span><br><span class="line">           if(i==end)&#123;</span><br><span class="line">               result+=1;</span><br><span class="line">               end = furthest;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>æ¯ä¸€æ­¥èµ°æœ€è¿œï¼Œè®°å½•ä¸‹æ­¥æ•°åˆ°resultï¼Œæ›´æ–°endåˆ°æœ€è¿œã€‚ ä¹Ÿæ˜¯greedyã€‚</p>
<h3 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121    Best Time to Buy and Sell Stock"></a>121    Best Time to Buy and Sell Stock</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">       int buy=0;</span><br><span class="line">       int sell=1;</span><br><span class="line">       int maxProfit=0;</span><br><span class="line">       while(sell&lt;prices.length)&#123;</span><br><span class="line">           int profit=prices[sell]-prices[buy];</span><br><span class="line">           maxProfit=Math.max(maxProfit,profit);</span><br><span class="line">           if(profit&lt;0) buy=sell;</span><br><span class="line">           sell++;</span><br><span class="line">       &#125;</span><br><span class="line">       return maxProfit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>éåŽ†æ‰€æœ‰ç›ˆåˆ©æœ€å¤§å€¼å¹¶å­˜å‚¨ï¼Œå¦‚æžœæ— æ³•profitå°±æŠŠbuyè®¾ç½®æˆé‚£å¤©ï¼ˆä»·æ ¼ä½Žï¼‰ã€‚è¿™æ ·å¯ä»¥åœ¨æœ€ä½Žçš„ä»·æ ¼ä¹°å…¥ã€‚</p>
<h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122    Best Time to Buy and Sell Stock II"></a>122    Best Time to Buy and Sell Stock II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">     int result = 0;</span><br><span class="line">     for(int i=1;i&lt;prices.length;i++)</span><br><span class="line">     result=Math.max(result+prices[i]-prices[i-1],result);</span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>åªè¦ç›ˆåˆ©å°±åšå–å‡ºæ“ä½œï¼ŒéåŽ†åŽå³å¯å¾—åˆ°æœ€å¤§æ”¶ç›Šã€‚</p>
<h3 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123    Best Time to Buy and Sell Stock III"></a>123    Best Time to Buy and Sell Stock III</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123; </span><br><span class="line">       if (prices == null || prices.length &lt;= 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">       int cost1 = Integer.MAX_VALUE, cost2 = Integer.MAX_VALUE, profit1 = 0, profit2 = 0;</span><br><span class="line"></span><br><span class="line">       for (int price : prices)&#123;</span><br><span class="line">           cost1 = Math.min(cost1, price);</span><br><span class="line">           profit1 = Math.max(profit1, price - cost1);</span><br><span class="line">           cost2 = Math.min(cost2, price - profit1);</span><br><span class="line">           profit2 = Math.max(profit2, price - cost2);</span><br><span class="line">       &#125;</span><br><span class="line">       return profit2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>è¯¥åšæ³•è¾ƒç›´è§‚ï¼Œå…¶å®ždpä¹Ÿå¯ä»¥ã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 3]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/04/30/Everyday-Leetcode-3/</url>
      <content type="html"><![CDATA[<h3 id="277-Find-the-Celebrity"><a href="#277-Find-the-Celebrity" class="headerlink" title="277    Find the Celebrity"></a>277    Find the Celebrity</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int findCelebrity(int n) &#123;</span><br><span class="line">        for (int i = 0, j = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (i != j &amp;&amp; (knows(i, j) || !knows(j, i))) break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j == n) return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>éåŽ†ï¼Œå¦‚æžœé‡åˆ° iè®¤è¯†jæˆ–è€…jä¸è®¤è¯†iå°±breakï¼Œå®Œæ•´å¾ªçŽ¯ä¸‹æ¥çš„å°±æ˜¯celebrityã€‚<br><a id="more"></a></p>
<h3 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217    Contains Duplicate"></a>217    Contains Duplicate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsDuplicate(int[] nums) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;();</span><br><span class="line">        for(int i:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            if(hs.contains(i)) return true;</span><br><span class="line">            else hs.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hashsetéåŽ†ï¼Œå¦‚æžœåŒ…å«å°±è¿”å›žtrueï¼Œå¦åˆ™å°±åŠ å…¥hashsetã€‚</p>
<h3 id="243-Shortest-Word-Distance"><a href="#243-Shortest-Word-Distance" class="headerlink" title="243    Shortest Word Distance"></a>243    Shortest Word Distance</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int shortestDistance(vector&lt;string&gt;&amp; words, string word1, string word2) &#123;</span><br><span class="line">        int p1 = -1, p2 = -1, res = INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; words.size(); ++i) &#123;</span><br><span class="line">            if (words[i] == word1) p1 = i;</span><br><span class="line">            else if (words[i] == word2) p2 = i;</span><br><span class="line">            if (p1 != -1 &amp;&amp; p2 != -1) res = min(res, abs(p1 - p2));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>éåŽ†ä¸€æ¬¡æ•°ç»„æ‰¾å‡ºp1,p2ï¼Œå¾—å‡ºç»“æžœã€‚</p>
<h3 id="244-Shortest-Word-Distance-II"><a href="#244-Shortest-Word-Distance-II" class="headerlink" title="244    Shortest Word Distance II"></a>244    Shortest Word Distance II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class WordDistance &#123;</span><br><span class="line">public:</span><br><span class="line">    WordDistance(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        for (int i = 0; i &lt; words.size(); ++i) &#123;</span><br><span class="line">            m[words[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int shortest(string word1, string word2) &#123;</span><br><span class="line">        int res = INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; m[word1].size(); ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m[word2].size(); ++j) &#123;</span><br><span class="line">                res = min(res, abs(m[word1][i] - m[word2][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;string, vector&lt;int&gt; &gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>hashmapè§£æ³•ã€‚</p>
<h3 id="245-Shortest-Word-Distance-III"><a href="#245-Shortest-Word-Distance-III" class="headerlink" title="245    Shortest Word Distance III"></a>245    Shortest Word Distance III</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int shortestWordDistance(vector&lt;string&gt;&amp; words, string word1, string word2) &#123;</span><br><span class="line">       int p1 = words.size(), p2 = -words.size(), res = INT_MAX;</span><br><span class="line">       for (int i = 0; i &lt; words.size(); ++i) &#123;</span><br><span class="line">           if (words[i] == word1) p1 = word1 == word2 ? p2 : i;</span><br><span class="line">           if (words[i] == word2) p2 = i;</span><br><span class="line">           res = min(res, abs(p1 - p2));</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>å¦‚æžœp1å’Œp2ç›¸ç­‰ï¼Œç»“æžœä¸ºp2-iã€‚ä¸ç›¸ç­‰åˆ™åŒ243çš„åšæ³•ã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 2]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/04/29/Everyday-Leetcode-2/</url>
      <content type="html"><![CDATA[<h3 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41    First Missing Positive"></a>41    First Missing Positive</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int firstMissingPositive(int[] nums) &#123;</span><br><span class="line">        HashMap map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i:nums)&#123;</span><br><span class="line">            map.put(i,1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j=1;j&lt;Integer.MAX_VALUE;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!map.containsKey(j))&#123;</span><br><span class="line">                return j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ç¬¬ä¸€é“è‡ªå·±åšå‡ºçš„Hardï¼Œå¯èƒ½æ˜¯æœ€ç®€å•çš„Hardã€‚ faster than 83.02%ï¼Œless than 86.32%.<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public int firstMissingPositive(int[] nums) &#123;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    </span><br><span class="line">    // 1. mark numbers (num &lt; 0) and (num &gt; n) with a special marker number (n+1) </span><br><span class="line">    // (we can ignore those because if all number are &gt; n then we&apos;ll simply return 1)</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (nums[i] &lt;= 0 || nums[i] &gt; n) &#123;</span><br><span class="line">            nums[i] = n + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // note: all number in the array are now positive, and on the range 1..n+1</span><br><span class="line">    </span><br><span class="line">    // 2. mark each cell appearing in the array, by converting the index for that number to negative</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int num = Math.abs(nums[i]);</span><br><span class="line">        if (num &gt; n) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        num--; // -1 for zero index based array (so the number 1 will be at pos 0)</span><br><span class="line">        if (nums[num] &gt; 0) &#123; // prevents double negative operations</span><br><span class="line">            nums[num] = -1 * nums[num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3. find the first cell which isn&apos;t negative (doesn&apos;t appear in the array)</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (nums[i] &gt;= 0) &#123;</span><br><span class="line">            return i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4. no positive numbers were found, which means the array contains all numbers 1..n</span><br><span class="line">    return n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>æœ€ä½³è§£ã€‚</p>
<h3 id="299-Bulls-and-Cows"><a href="#299-Bulls-and-Cows" class="headerlink" title="299    Bulls and Cows"></a>299    Bulls and Cows</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public String getHint(String secret, String guess) &#123;</span><br><span class="line">    int bulls = 0;</span><br><span class="line">    int cows = 0;</span><br><span class="line">    int[] numbers = new int[10];</span><br><span class="line">    for (int i = 0; i&lt;secret.length(); i++) &#123;</span><br><span class="line">        int s = Character.getNumericValue(secret.charAt(i));</span><br><span class="line">        int g = Character.getNumericValue(guess.charAt(i));</span><br><span class="line">        if (s == g) bulls++;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (numbers[s] &lt; 0) cows++;</span><br><span class="line">            if (numbers[g] &gt; 0) cows++;</span><br><span class="line">            numbers[s] ++;</span><br><span class="line">            numbers[g] --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return bulls + &quot;A&quot; + cows + &quot;B&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>å¾ˆå‘çˆ¹çš„é¢˜ï¼Œé¢˜ç›®è¡¨ç¤ºä¸æ¸…æ¥šã€‚ä¸ºä»€ä¹ˆ1123ï¼Œ0111æ˜¯1Bï¼Œ1122ï¼Œ2211å´æ˜¯4Bã€‚</p>
<h3 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134    Gas Station"></a>134    Gas Station</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">    int res=-1;</span><br><span class="line">        for (int i=0;i&lt;gas.length;i++)&#123;</span><br><span class="line">            int tank=gas[i];</span><br><span class="line">            int j=i;</span><br><span class="line">            </span><br><span class="line">            while(tank-cost[j]&gt;=0)&#123;</span><br><span class="line">                if(j==gas.length-1)</span><br><span class="line">                tank=tank-cost[j]+gas[0];</span><br><span class="line">                else</span><br><span class="line">                tank=tank-cost[j]+gas[j+1];</span><br><span class="line">                j++;</span><br><span class="line">                if(j==gas.length) j=0;</span><br><span class="line">                if(j==i) return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>æ€è·¯å¾ˆç®€å•ï¼Œä½†æ˜¯è¦å°å¿ƒcorner caseã€‚</p>
<h3 id="274-H-Index"><a href="#274-H-Index" class="headerlink" title="274    H-Index"></a>274    H-Index</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int hIndex(int[] citations) &#123;</span><br><span class="line">    int n = citations.length;</span><br><span class="line">    int[] buckets = new int[n+1];</span><br><span class="line">    for(int c : citations) &#123;</span><br><span class="line">        if(c &gt;= n) &#123;</span><br><span class="line">            buckets[n]++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            buckets[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for(int i = n; i &gt;= 0; i--) &#123;</span><br><span class="line">        count += buckets[i];</span><br><span class="line">        if(count &gt;= i) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>bucket sortï¼Œç©ºé—´æ¢æ—¶é—´ã€‚é¦–å…ˆä¸ºé•¿åº¦ä¸ºnçš„æ•°ç»„è®¾ç½®n+1ä¸ªæ¡¶ï¼Œå¤§äºŽné•¿åº¦çš„å¼•ç”¨æ•°éƒ½æ”¾åˆ°n+1ä¸ªæ¡¶é‡Œï¼Œç„¶åŽä»Žå°¾åˆ°å¤´éåŽ†ï¼Œå¦‚æžœcount&gt;=indexï¼Œè¿™è¯´æ˜Žæˆ‘ä»¬å¾—åˆ°äº†é¢˜ç›®è¦æ±‚çš„å¼•ç”¨æ•°&gt;=indexçš„indexã€‚</p>
<h3 id="275-H-Index-II"><a href="#275-H-Index-II" class="headerlink" title="275    H-Index II"></a>275    H-Index II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int hIndex(int[] citations) &#123;</span><br><span class="line">        int len = citations.length, left = 0, right = len - 1;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = 0.5 * (left + right);</span><br><span class="line">            if (citations[mid] == len - mid) return len - mid;</span><br><span class="line">            else if (citations[mid] &gt; len - mid) right = mid - 1;</span><br><span class="line">            else left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return len - left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>ç”¨bucket sortä¹Ÿå¯ä»¥ï¼Œä½†è¿™é‡Œæ›´é€‚åˆbinary searchï¼Œå› ä¸ºæ˜¯æœ‰åºæ•°ç»„ã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 1]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/04/28/Everyday-Leetcode-1/</url>
      <content type="html"><![CDATA[<h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1 Two Sum"></a>1 Two Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; ans= new HashMap&lt;&gt;();</span><br><span class="line">        for (int i=0; i&lt;nums.length;i++)&#123;</span><br><span class="line">          int diff=target-nums[i];</span><br><span class="line">              if (ans.containsKey(diff))</span><br><span class="line">              &#123;</span><br><span class="line">                  </span><br><span class="line">                  return new int[]&#123;ans.get(diff),i&#125;;</span><br><span class="line">              &#125;</span><br><span class="line">            ans.put(nums[i],i);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       throw new IllegalArgumentException();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ç”¨åˆ°hashmapï¼Œå¤§å¤§æé«˜äº†æ•ˆçŽ‡ã€‚ å¯ä»¥ç”¨throw new IlleaglArgumentExceptionçš„åŠžæ³•è·³è¿‡å¿…é¡»returnçš„æ£€æŸ¥ã€‚<br><a id="more"></a></p>
<h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27    Remove Element"></a>27    Remove Element</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">       int ans=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(nums[i]!=val)&#123;</span><br><span class="line">                nums[ans]=nums[i];</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>æ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚</p>
<h3 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26    Remove Duplicates from Sorted Array"></a>26    Remove Duplicates from Sorted Array</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if (nums[i]!=nums[ans])</span><br><span class="line">                nums[++ans]=nums[i];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return ++ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>æ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚</p>
<h3 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="80    Remove Duplicates from Sorted Array II"></a>80    Remove Duplicates from Sorted Array II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    for (int i : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ans&lt;2 ||i&gt;nums[ans-2])</span><br><span class="line">            nums[ans++]=i;</span><br><span class="line">    &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>æ²¡ä»€ä¹ˆå¥½è¯´çš„ã€‚</p>
<h3 id="189-Rotate-Array"><a href="#189-Rotate-Array" class="headerlink" title="189    Rotate Array"></a>189    Rotate Array</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void rotate(int[] nums, int k) &#123;</span><br><span class="line">        </span><br><span class="line">    k %= nums.length;</span><br><span class="line">    reverse(nums, 0, nums.length - 1);</span><br><span class="line">    reverse(nums, 0, k - 1);</span><br><span class="line">    reverse(nums, k, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void reverse(int[] nums, int start, int end) &#123;</span><br><span class="line">    while (start &lt; end) &#123;</span><br><span class="line">        int temp = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>kå¯èƒ½å¤§äºŽnums.length,æ‰€ä»¥å°±éœ€è¦%=ä¸€ä¸‹ã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode Record]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/04/28/Leetcode-Record/</url>
      <content type="html"><![CDATA[<ul>
<li>[x] 1     Two Sum</li>
<li>[x] 27    Remove Element</li>
<li>[x] 26    Remove Duplicates from Sorted Array</li>
<li>[x] 80    Remove Duplicates from Sorted Array II</li>
<li>[x] 189    Rotate Array</li>
<li>[x] 41    First Missing Positive</li>
<li>[x] 299    Bulls and Cows</li>
<li>[x] 134    Gas Station</li>
<li>[x] 274    H-Index</li>
<li>[x] 275    H-Index II<a id="more"></a></li>
<li>[x] 277    Find the Celebrity</li>
<li>[x] 217    Contains Duplicate</li>
<li>[x] 243    Shortest Word Distance</li>
<li>[x] 244    Shortest Word Distance II</li>
<li>[x] 245    Shortest Word Distance III</li>
<li>[x] 55    Jump Game</li>
<li>[x] 45    Jump Game II</li>
<li>[x] 121    Best Time to Buy and Sell Stock</li>
<li>[x] 122    Best Time to Buy and Sell Stock II</li>
<li>[x] 123    Best Time to Buy and Sell Stock III</li>
<li>[x] 188    Best Time to Buy and Sell Stock IV</li>
<li>[x] 309    Best Time to Buy and Sell Stock with Cooldown</li>
<li>[x] 11    Container With Most Water</li>
<li>[x] 42    Trapping Rain Water</li>
<li>[x] 334    Increasing Triplet Subsequence</li>
<li>[x] 128    Longest Consecutive Sequence</li>
<li>[x] 164    Maximum Gap</li>
<li>[x] 287    Find the Duplicate Number</li>
<li>[x] 4        Median of Two Sorted Arrays</li>
<li>[x] 289    Game of Life</li>
<li>[x] 57    Insert Interval</li>
<li>[x] 56    Merge Intervals</li>
<li>[x] 252    Meeting Rooms</li>
<li>[x] 253    Meeting Rooms II</li>
<li>[x] 352    Data Stream as Disjoint Intervals</li>
<li>[x] 239    Sliding Window Maximum</li>
<li>[x] 295    Find Median from Data Stream</li>
<li>[x] 53    Maximum Subarray</li>
<li>[x] 325    Maximum Size Subarray Sum Equals k</li>
<li>[x] 209    Minimum Size Subarray Sum</li>
<li>[x] 238    Product of Array Except Self</li>
<li>[x] 152    Maximum Product Subarray</li>
<li>[x] 228    Summary Ranges</li>
<li>[x] 163    Missing Ranges</li>
<li>[x] 88    Merge Sorted Array</li>
<li>[x] 75    Sort Colors</li>
<li>[x] 283    Move Zeroes</li>
<li>[x] 376    Wiggle Subsequence</li>
<li>[x] 280    Wiggle Sort</li>
<li>[x] 324    Wiggle Sort II</li>
<li>[x] 28    Implement strStr()    </li>
<li>[x] 14    Longest Common Prefix    </li>
<li>[x] 58    Length of Last Word    </li>
<li>[x] 387    First Unique Character in a String    </li>
<li>[x] 383    Ransom Note</li>
<li>[x] 344    Reverse String    </li>
<li>[x] 151    Reverse Words in a String    </li>
<li>[x] 186    Reverse Words in a String II    </li>
<li>[x] 345    Reverse Vowels of a String    </li>
<li>[x] 205    Isomorphic Strings</li>
<li>[x] 293    Flip Game    </li>
<li>[x] 294    Flip Game II    </li>
<li>[x] 290    Word Pattern    </li>
<li>[x] 242    Valid Anagram    </li>
<li>[x] 49    Group Anagrams</li>
<li>[x] 249    Group Shifted Strings    </li>
<li>[x] 87    Scramble String</li>
<li>[x] 161    One Edit Distance    </li>
<li>[x] 38    Count and Say    </li>
<li>[x] 358    Rearrange String k Distance Apart</li>
<li>[x] 316    Remove Duplicate Letters    </li>
<li>[x] 271    Encode and Decode Strings    </li>
<li>[x] 168    Excel Sheet Column Title    </li>
<li>[x] 171    Excel Sheet Column Number    </li>
<li>[x] 13    Roman to Integer</li>
<li>[x] 12    Integer to Roman    </li>
<li>[x] 273    Integer to English Words    </li>
<li>[x] 246    Strobogrammatic Number    </li>
<li>[x] 247    Strobogrammatic Number II</li>
<li>[x] 68    Text Justification</li>
<li>[x] 65    Valid Number    </li>
<li>[x] 157    Read N Characters Given Read4    </li>
<li>[x] 158    Read N Characters Given Read4 II - Call multiple times</li>
<li>[x] 76    Minimum Window Substring    </li>
<li>[x] 30    Substring with Concatenation of All Words</li>
<li>[x] 3        Longest Substring Without Repeating Characters    </li>
<li>[x] 340    Longest Substring with At Most K Distinct Characters    </li>
<li>[x] 395    Longest Substring with At Least K Repeating Characters    </li>
<li>[x] 159    Longest Substring with At Most Two Distinct Characters    </li>
<li>[x] 125    Valid Palindrome</li>
<li>[x] 266    Palindrome Permutation    </li>
<li>[x] 5    Longest Palindromic Substring    </li>
<li>[x] 9    Palindrome Number    </li>
<li>[x] 214    Shortest Palindrome    </li>
<li>[x] 336    Palindrome Pairs</li>
<li>[x] 131    Palindrome Partitioning    </li>
<li>[x] 132    Palindrome Partitioning II    </li>
<li>[x] 267    Palindrome Permutation II</li>
<li>[x] 20    Valid Parentheses    </li>
<li>[x] 22    Generate Parentheses</li>
<li>[x] 32    Longest Valid Parentheses    </li>
<li>[x] 241    Different Ways to Add Parentheses    </li>
<li>[x] 301    Remove Invalid Parentheses        </li>
<li>[x] 392    Is Subsequence    </li>
<li>[x] 115    Distinct Subsequences</li>
<li>[x] 7        Reverse Integer    </li>
<li>[x] 165    Compare Version Numbers    </li>
<li>[x] 66    Plus One    </li>
<li>[x] 8        String to Integer (atoi)    </li>
<li>[x] 258    Add Digits</li>
<li>[x] 67    Add Binary    </li>
<li>[x] 43    Multiply Strings    </li>
<li>[x] 29    Divide Two Integers    </li>
<li>[x] 69    Sqrt(x)</li>
<li>[x] 50    Pow(x, n)    </li>
<li>[x] 367    Valid Perfect Square    </li>
<li>[x] 365    Water and Jug Problem    </li>
<li>[x] 204    Count Primes</li>
<li>[x] 1        Two Sum    </li>
<li>[x] 167    Two Sum II - Input array is sorted</li>
<li>[x] 15    3Sum</li>
<li>[x] 18    4Sum</li>
<li>[x] 144    Binary Tree Preorder Traversal    </li>
<li>[x] 94    Binary Tree Inorder Traversal    </li>
<li>[x] 145    Binary Tree Postorder Traversal</li>
<li>[x] 100    Same Tree        </li>
<li>[x] 101    Symmetric Tree    </li>
<li>[x] 226    Invert Binary Tree    </li>
<li>[x] 257    Binary Tree Paths    </li>
<li>[x] 112    Path Sum</li>
<li>[x] 113    Path Sum II    </li>
<li>[x] 129    Sum Root to Leaf Numbers    </li>
<li>[x] 298    Binary Tree Longest Consecutive Sequence    </li>
<li>[x] 111    Minimum Depth of Binary Tree</li>
<li>[x] 104    Maximum Depth of Binary Tree</li>
<li>[x] 110   Balanced Binary Tree</li>
<li>[x] 235   Lowest Common Ancestor of a Binary Search Tree     </li>
<li>[x] 236   Lowest Common Ancestor of a Binary Tree    </li>
<li>[x] 108   Convert Sorted Array to Binary Search tree</li>
<li>[x] 109   Convert Sorted List to Binary Search tree</li>
<li>[x] 173    Binary Search Tree Iterator</li>
<li>[x] 230    Kth Smallest Element in a BST    </li>
<li>[x] 297    Serialize and Deserialize Binary Tree    </li>
<li>[x] 285    Inorder Successor in BST    </li>
<li>[x] 270    Closest Binary Search Tree Value</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[æ™®é€šäººçš„19fall cs master DIYæ€»ç»“]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/04/15/%E6%99%AE%E9%80%9A%E4%BA%BA%E7%9A%8419fall-cs-master-DIY%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="å‰è¨€"><a href="#å‰è¨€" class="headerlink" title="å‰è¨€"></a>å‰è¨€</h1><p>å…ˆå¯¹æˆ‘çš„æƒ…å†µåšä¸ªè¯´æ˜Žï¼Œåº”è¯¥æ˜¯åœ°é‡Œçš„æ™®é€šäººæ ·æœ¬ï¼Œæˆ–è€…å¯ä»¥ç®—æ˜¯å°‘æ•°çš„åä¸‹çš„æ ·æœ¬ã€‚åŒéžï¼ˆå¹¶éžä¸­å¤–åˆä½œçš„åŒéžï¼‰ã€ä½Žgpaï¼ˆ3.3/4ï¼‰ã€æ™®é€šTGï¼ˆ101ã€320+3.5ï¼‰ã€æ— ç§‘ç ”æ— å®žä¹ ï¼Œåªæœ‰ä¸€æ®µUCRäº¤æµï¼Œç»©ç‚¹è¿˜å¾ˆä½Žï¼ˆ2.7ï¼‰ã€‚æ‰€ä»¥å¾ˆæ˜¾è€Œæ˜“è§åœ°ï¼Œæœ¬æ–‡çš„è¯»è€…ä¸åº”è¯¥æ˜¯åœ°é‡Œé‚£äº›æ¡ä»¶æ¯”æˆ‘å¥½å¤ªå¤šçš„å¤§ç¥žä»¬ã€‚å†™è¿™ç¯‡ä¹Ÿæ˜¯ä¸ºäº†ç»™å°†æ¥çš„å’Œæˆ‘ä¸€æ ·çš„æ™®é€šäººä»¬åšä¸ªå‚è€ƒï¼ŒåŒæ—¶ç»™è¿™æ®µåŽ†ç¨‹åšä¸ªè®°å½•ï¼Œå¦‚æžœèƒ½å¯¹åˆ«äººæœ‰ç‚¹å¸®åŠ©å°±å¥½äº†ã€‚åº”è¯¥ä¼šæœ‰ç‚¹é•¿ã€‚</p>
<p>å…ˆä¸Šç»“æžœï¼Œå‡ä¸ºCS msï¼ˆæŒ‰æ—¶é—´é¡ºåºï¼‰ï¼š<br>6ADï¼šé›ªåŸŽï¼ŒGWUï¼ŒBuffaloï¼ŒASUï¼ŒNCSUï¼ˆæœ€åŽå†³å®šåŽ»çš„å­¦æ ¡ï¼‰ï¼ŒWPI<br>9Rejï¼šUTDï¼Œ Brandeisï¼ŒRochesterï¼ŒUSCï¼ŒCU-Boulderï¼ŒWUSTLï¼ŒRutgersï¼ŒBUï¼ŒNEUï¼ˆBUå’ŒNEUä»Šå¤©è¿˜æ²¡æ¥æ‹’ä¿¡ï¼Œç®—ä½œé»˜æ‹’å§ï¼‰<br><a id="more"></a><br>æ—¶é—´çº¿ï¼š<br>2018.9.26 è€ƒæœ€åŽä¸€æ¬¡æ‰˜ç¦ ç»“æžœæ˜¯101ï¼ˆä¹‹å‰æœ€å¥½95ï¼‰<br>9.26-11.3 å‡†å¤‡GREçš„åŒæ—¶å†™æ–‡ä¹¦<br>2018.11.3 è€ƒæœ€åŽä¸€æ¬¡GRE ç»“æžœ320+3.5 ï¼ˆä¹‹å‰æœ€å¥½316+3ï¼‰<br>11.3-11.12 ç­‰ä½œæ–‡æˆç»©åŒæ—¶å†™æ–‡ä¹¦<br>2018.11.12 å‡ºä½œæ–‡æˆç»©ï¼Œå®Œæˆå…¨éƒ¨15æ‰€å­¦æ ¡çš„ç½‘ç”³å¡«å†™å’ŒGTé€åˆ†ï¼Œç„¶åŽå¿™æŽ¨èä¿¡ã€‚<br>2018.11.20  å¤§æ¦‚æ˜¯æ‰€æœ‰æŽ¨èä¿¡æžå®šçš„æ—¥æœŸ<br>2018.11.28  UTDæ‹’ä¿¡ï¼Œæœ‰ç‚¹å°éƒé—·ã€‚<br>2018.12.3    ç¬¬ä¸€ä¸ªadï¼Œé›ªåŸŽï¼Œè¿˜ç»™äº†30%å°å¥–ã€‚<br>2019.1.17   GWU ad<br>2019.2.8    Brandeis rej<br>å¤§å¹´åˆä¸€   Buffalo ad<br>æƒ…äººèŠ‚      ASU ad<br>2019.2.26 NCSU ad<br>2019 ä¸‰æœˆ  Rochesterï¼Œ USCï¼ŒCU-Boulderï¼ŒWUSTL å››è¿žæ‹’ æœˆåº•æ”¶åˆ°WPI<br>2019 å››æœˆ ç›®å‰å°±Rutgers rejï¼Œå…¶ä»–å°±å½“ä½œé»˜æ‹’å§ã€‚</p>
<h1 id="ç¬¬ä¸€éƒ¨åˆ†-å¿ƒç†å‡†å¤‡ä¸Žä¸ºä»€ä¹ˆDIY"><a href="#ç¬¬ä¸€éƒ¨åˆ†-å¿ƒç†å‡†å¤‡ä¸Žä¸ºä»€ä¹ˆDIY" class="headerlink" title="ç¬¬ä¸€éƒ¨åˆ† å¿ƒç†å‡†å¤‡ä¸Žä¸ºä»€ä¹ˆDIY"></a>ç¬¬ä¸€éƒ¨åˆ† å¿ƒç†å‡†å¤‡ä¸Žä¸ºä»€ä¹ˆDIY</h1><blockquote>
<p>â€œAm I wrong for saying that Iâ€™ll choose another way?â€<br>&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; â€“Nico &amp; Vinzã€ŠAm I Wrongã€‹</p>
</blockquote>
<p>æˆ‘è§‰å¾—åœ¨å¼€å§‹ç”³è¯·ä¹‹å‰çš„å¾ˆé‡è¦çš„ä¸€ä»¶äº‹æ˜¯ï¼Œåšå®šè‡ªå·±è¦å‡ºå›½çš„ä¿¡å¿µã€‚å¦‚æžœæ²¡æœ‰åšå®šçš„ä¿¡å¿µï¼Œåœ¨ç”³è¯·é€”ä¸­é‡åˆ°å¾ˆå¤šå›°éš¾çš„æ—¶å€™éƒ½ä¼šåŠ¨æ‘‡ä»Žè€Œå½±å“ç”³è¯·ï¼Œæ›´åˆ«æä¹‹åŽçš„ç•™å­¦ä¸Žæ‰¾å·¥ç”Ÿæ¶¯ã€‚åšå®šä¿¡å¿µçš„æ–¹æ³•å¾ˆç®€å•ï¼Œæ‰¾ä¸€ä¸ªè¶³å¤Ÿå……åˆ†çš„ç†ç”±è¯´æœè‡ªå·±ï¼Œå¯¹æˆ‘æ¥è¯´è¿™ä¸ªç†ç”±åº”è¯¥æ˜¯å›½å†…æ™®éçš„996é£Žæ°”ã€‚<br>å…³äºŽä¸ºä»€ä¹ˆè¦DIYï¼Œå…¶å®žä¸€å¼€å§‹ä¹ŸåŠ¨è¿‡æ‰¾ä¸­ä»‹çš„æƒ³æ³•ã€‚å¯¹è‡ªå·±æœ‰ç‚¹ç¼ºä¹ä¿¡å¿ƒï¼Œä½†è¢«çˆ¸å¦ˆåŠä½äº†ï¼Œå·®ç‚¹å°±æ‰¾äº†ä¸€ä¸ªå°ä¸­ä»‹ï¼ˆè¢«åœ°é‡Œåæ§½è¿‡çš„çŽ‹Xï¼‰ã€‚ä¸­ä»‹èƒ½å¸®ä½ çš„æ— éžå°±ä¸¤ç‚¹ï¼Œä¸€é€‰æ ¡ï¼ŒäºŒæ–‡ä¹¦ã€‚ä¸€å¯ä»¥é€šè¿‡èŠ±æ—¶é—´è‡ªå·±æ‰¾èµ„æ–™è§£å†³ï¼ŒäºŒå¯ä»¥é€šè¿‡èŠ±æ—¶é—´è‡ªå·±å†™è§£å†³ã€‚ä¸­ä»‹é€‰çš„æ ¡ã€å†™çš„æ–‡ä¹¦ä¸€å®šæ¯”ä½ é€‰çš„å’Œå†™çš„å¥½ä¹ˆï¼Ÿæˆ‘åªå»ºè®®çœŸçš„æ²¡æœ‰æ—¶é—´çš„äººæ‰¾ä¸­ä»‹ï¼Œåªè¦ä½ æœ‰æ—¶é—´ï¼ŒDIYæ˜¯å®Œå…¨å¯ä»¥çš„ã€‚ä¸­ä»‹å‰©ä¸‹æ¥çš„å‡ ä¸‡å—ï¼Œå‡åŽ»æ–‡ä¹¦æ¶¦è‰²çš„å‡ åƒå—ï¼ˆè‡ªå·±å†™çš„å¥½çš„è¯å¯ä»¥å°‘å¾ˆå¤šï¼‰åŽè¶³å¤Ÿå¤šç”³å¥½å¤šæ‰€å­¦æ ¡ï¼ˆæ¯æ‰€æ‰ä¸€ç™¾å¤šåˆ€ï¼‰ã€‚å¦‚æžœä½ ä¸ç›¸ä¿¡é è‡ªå·±èƒ½å®Œæˆæ•´ä¸ªç”³è¯·ï¼Œé‚£ä¹ˆä¹‹åŽçš„ç•™å­¦ä¸Žæ‰¾å·¥åˆæ€Žä¹ˆåŠžå‘¢ï¼Ÿæˆ‘å¾ˆæ„Ÿæ¿€çˆ¶æ¯åœ¨æ•´ä¸ªç”³è¯·è¿‡ç¨‹ä¸­ç»™æˆ‘çš„100%çš„ä¿¡ä»»ã€‚åˆ°æœ€åŽï¼Œæ¯ä¸ªäººéƒ½è¦ä¸ºè‡ªå·±çš„é€‰æ‹©è´Ÿè´£ã€‚é è‡ªå·±åŽ»æƒ³åŽ»çš„åœ°æ–¹ï¼Œåšæƒ³åšçš„äº‹æƒ…æ˜¯æœ€é…·çš„ã€‚</p>
<h1 id="ç¬¬äºŒéƒ¨åˆ†-é€‰æ ¡ã€æ–‡ä¹¦ä¸ŽGT"><a href="#ç¬¬äºŒéƒ¨åˆ†-é€‰æ ¡ã€æ–‡ä¹¦ä¸ŽGT" class="headerlink" title="ç¬¬äºŒéƒ¨åˆ† é€‰æ ¡ã€æ–‡ä¹¦ä¸ŽGT"></a>ç¬¬äºŒéƒ¨åˆ† é€‰æ ¡ã€æ–‡ä¹¦ä¸ŽGT</h1><blockquote>
<p>â€œI know what I have to do nowâ€<br> &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; â€”Lenny code fictionã€ŠMake my storyã€‹</p>
</blockquote>
<p>é€‰æ ¡æ–¹é¢ï¼šæœé›†èµ„æ–™ç„¶åŽå†³å®šã€‚ä¿¡æ¯æ¥æºæœ‰çŸ¥ä¹Žã€åœ°é‡Œçš„å¾€å±Šå½•å–æƒ…å†µå’Œé™¢ç³»ä»‹ç»ç­‰ã€Quoraç­‰ç­‰ã€‚ä¹‹å‰çœ‹åœ°é‡Œè¯´ä¿åº•å››å°é¾™UTDï¼Œé›ªåŸŽï¼ŒGWUï¼ŒSITéƒ½ç”³ä¸å¯èƒ½å¤±å­¦ï¼Œé™¤äº†SITå› ä¸ºç½‘ç«™å¤ªä¸‘æ²¡ç”³ï¼Œæˆ‘ä¸­äº†ä¸¤ä¸ªï¼Œè¿˜æ˜¯è›®å‡†çš„ã€‚ç„¶åŽå°±æ˜¯ä¸»åŠ›ï¼Œæˆ‘é€‰æ‹©äº†ASUã€NCSUè¿™ç§ä¾¿å®œæ€§ä»·æ¯”é«˜çš„ã€‚å½©ç¥¨å°±éšä¾¿äº†ï¼Œåæ­£çœä¸‹æ¥çš„ä¸­ä»‹è´¹å¯ä»¥å¤šæŠ¥å‡ ä¸ªã€‚çŽ°åœ¨å›žè¿‡å¤´çœ‹çœ‹ï¼Œæ„Ÿè§‰æ²¡æœ‰å¾ˆå¤§çš„å¤±è¯¯ï¼Œä»¥æˆ‘çš„æ¡ä»¶ï¼Œè¿™æ ·çš„é€‰æ ¡å’Œç»“æžœåº”è¯¥å¯ä»¥æŽ¥å—ã€‚<br>æ–‡ä¹¦çš„è¯ï¼Œé‡è¦çš„ä¸€ç‚¹æ˜¯æ•´ä½“é€»è¾‘è¦å®Œæ•´æœ‰è¯´æœåŠ›ï¼ŒåŒæ—¶åˆä¸è½ä¿—å¥—ã€‚æˆ‘çš„è¯ä¸»è¦å°±æ˜¯è®²è¿°åŽ»UCRçš„ç»åŽ†ï¼Œç„¶åŽåŠ ä¸Šäº†Why Schooléƒ¨åˆ†ã€‚åœ¨å†™åäº”ä¸ªå­¦æ ¡çš„why schooléƒ¨åˆ†çš„æ—¶å€™ï¼Œå†™åˆ°åŽé¢ç¡®å®žæœ‰ç‚¹æ™•äº†ï¼Œå¼€å§‹å¤åˆ¶ç²˜è´´ï¼Œè¢«æ–‡ä¹¦æ¶¦è‰²çš„ç¼–è¾‘æ‰¹è¯„äº†ã€‚åŽé¢é‡æ–°æŸ¥èµ„æ–™å†™è¿‡ã€‚æ€»ä¹‹why schoolè¦è‡ªå·±æŸ¥èµ„æ–™ï¼ˆå®˜ç½‘ã€ç»´åŸºç™¾ç§‘ç­‰ï¼‰ï¼Œé«˜åº¦â€œç§äººå®šåˆ¶â€ã€‚æ–‡ä¹¦æ¶¦è‰²æœºæž„æˆ‘é€‰çš„æ˜¯æœ€ä¾¿å®œçš„papersoxxxï¼Œè¿˜è¡Œï¼Œå¯¹å¾—èµ·ä»·æ ¼ã€‚å‰åŽå¤§æ¦‚èŠ±äº†2kå·¦å³ï¼Œæ”¹äº†7æ¬¡ã€‚æ¯”å‡ ä¸‡çš„ä¸­ä»‹è´¹ä¾¿å®œå¤ªå¤šã€‚<br>GTè¿™æ–¹é¢çœŸçš„è®²ä¸æ¥ï¼Œå¤ªèœäº†ï¼Œä¸¤ä¸ªéƒ½æ˜¯ä¸‰æˆ˜ã€‚æœ€åŽéƒ½æ˜¯èƒŒæ°´ä¸€æˆ˜ä¾¥å¹¸è¿‡å…³ã€‚åæ­£å°±å¤šç»ƒTPOæœºç»ï¼Œgreä¹Ÿå¾—å¤šç»ƒã€‚</p>
<h1 id="ç¬¬ä¸‰éƒ¨åˆ†-æäº¤åŽçš„æ¼«é•¿ç­‰å¾…ä¸Žæœ€åŽæ„Ÿæƒ³"><a href="#ç¬¬ä¸‰éƒ¨åˆ†-æäº¤åŽçš„æ¼«é•¿ç­‰å¾…ä¸Žæœ€åŽæ„Ÿæƒ³" class="headerlink" title="ç¬¬ä¸‰éƒ¨åˆ† æäº¤åŽçš„æ¼«é•¿ç­‰å¾…ä¸Žæœ€åŽæ„Ÿæƒ³"></a>ç¬¬ä¸‰éƒ¨åˆ† æäº¤åŽçš„æ¼«é•¿ç­‰å¾…ä¸Žæœ€åŽæ„Ÿæƒ³</h1><blockquote>
<p>â€œçœŸçˆ±å¹¶éžä¸æ¥ å®ƒåªæ˜¯è¢«æ— é¢„è­¦çš„æ¶æ„çš„å»¶è¿Ÿâ€<br> &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; â€”çºµè´¯çº¿ã€Šäº¡å‘½ä¹‹å¾’ã€‹</p>
</blockquote>
<p>å…¶å®žæ¯”èµ·å¤§å¤šæ•°äººæ¥è¯´æˆ‘åº”è¯¥æ˜¯ç»“æžœå‡ºçš„æ¯”è¾ƒæ—©çš„äººï¼Œä¸è¿‡æœ€åŽä¹Ÿæ˜¯ç­‰åˆ°2019.4.10æ‰åšäº†å†³å®šã€‚ç­‰åˆ°äº†3æœˆä»½çš„ä¸€æ³¢æ‹’ä¿¡ï¼Œç„¶åŽä¸€ç›´æ²¡æœ‰ç­‰åˆ°BUçš„æ‹’ä¿¡ï¼Œä¸‹å®šå†³å¿ƒåŽ»äº†NCSUã€‚æˆ‘çŸ¥é“å¾ˆå¤šäººå¯èƒ½ä¸€ç›´åœ¨ç­‰å¾…çš„è¿‡ç¨‹ä¸­é¥±å—ç…Žç†¬ï¼Œè¿™æ˜¯æ¯ä¸ªç”³è¯·è€…éƒ½ä¼šé‡åˆ°çš„äº‹æƒ…ï¼Œä½†è¯·ç›¸ä¿¡æœ€åŽçš„æœ€åŽä¼šæœ‰å¥½çš„ç»“æžœã€‚ç”³è¯·å­£å°±è¿™æ ·ç»“æŸäº†ï¼ŒæŽ¥ä¸‹æ¥è¦æ›´åŠªåŠ›å•Šã€‚æ„¿æˆ‘ä»¬åœ¨åˆ°è¾¾è·¯çš„æœ«ç«¯çš„æ—¶å€™ï¼Œéƒ½ä¸ä¼šåŽæ‚”ã€‚</p>
]]></content>
      
        <categories>
            
            <category> ç•™å­¦ </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ç”³è¯·æ€»ç»“ </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W22repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/12/23/W22repo/</url>
      <content type="html"><![CDATA[<p>ä¹‹å‰æ¼äº†ä¸€å‘¨ï¼Œæœ‰ç‚¹ç½ªæ¶ã€‚è¿™å‘¨å›žå®¶äº†ã€‚å›žå®¶åŽå¤§æ¦‚å°±åˆ·cs61bã€æ¯•è®¾å’Œleetcodeäº†ã€‚åŠ æ²¹ï¼Œ2019<br>å†²å†²å†²ï¼</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W20repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/12/10/W20repo/</url>
      <content type="html"><![CDATA[<p>æœ¬å‘¨å­¦ä¹ Goä¸‰åå…­è®²åˆ°9.</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W19repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/12/02/W19repo/</url>
      <content type="html"><![CDATA[<p>æœ¬å‘¨å­¦ä¹ äº†Goçš„httpåŒ…ç›¸å…³</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W18repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/11/25/W18repo/</url>
      <content type="html"><![CDATA[<p>Goçš„sturctï¼Œé¢å‘å¯¹è±¡ï¼Œinterfaceï¼Œ å­¦ä¹ å®Œæˆã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W17repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/11/18/W17repo/</url>
      <content type="html"><![CDATA[<p>æ–°çš„ç”Ÿæ´»ï¼Œæ–°çš„è‹¦ç»ƒ</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W16repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/11/11/W16repo/</url>
      <content type="html"><![CDATA[<p>ä¸‡äº‹ä¿±å¤‡ï¼Œåªå·®é€åˆ†ã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W15repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/11/05/W15repo/</url>
      <content type="html"><![CDATA[<p>å…¨åŠ›æŠ•å…¥ç”³è¯·ï¼Œ11æœˆå¿…é¡»å®Œæˆã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W14repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/10/29/W14repo/</url>
      <content type="html"><![CDATA[<p>æœ€åŽä¸€å‘¨ï¼ŒåŠ æ²¹ï¼</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W13repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/10/22/W13repo/</url>
      <content type="html"><![CDATA[<p>å•è¯å·®ä¸å¤šèƒŒå®Œï¼Œå¼€å§‹åˆ·é¢˜ã€‚<br>åŠ æ²¹ã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W12repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/10/14/W12repo/</url>
      <content type="html"><![CDATA[<p>æš‚æ—¶å…¨åŠ›å‡†å¤‡GREï¼Œç­‰è€ƒå®Œå†PSã€‚<br>åŠ æ²¹ã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W11repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/10/07/W11repo/</url>
      <content type="html"><![CDATA[<p>DLå·²ç¡®è®¤ï¼ŒæŽ¥ä¸‹æ¥æžå®šPSå’ŒCVã€‚<br>GREåŠ æ²¹ï¼ï¼</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W10repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/10/01/W10repo/</url>
      <content type="html"><![CDATA[<p>å›½åº†ï¼š æŽ¨èä¿¡ PS CV é€åˆ†<br>ç„¶åŽè·³è¿›GRE<br>ç»§ç»­åŠ æ²¹ã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W9repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/09/24/W9repo/</url>
      <content type="html"><![CDATA[<p>ç¦»å›½åº†ä¸€å‘¨ï¼Œæ”¶å¿ƒã€‚<br>æŽ¥ä¸‹æ¥ä¸»è¦æ˜¯æ”¹PSï¼ŒCVï¼Œé€åˆ†GREå’Œç”³è¯·äº†ã€‚<br>ç„¶åŽå°±åŠªåŠ›codingã€‚<br>åŠ æ²¹ã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W8repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/09/19/W8repo/</url>
      <content type="html"><![CDATA[<p>æ‰˜ç¦è€ƒå®Œï¼Œç«Ÿæœ‰äº›â€œåœ†æ»¡â€çš„æ„Ÿè§‰ã€‚<br>åˆæ„Ÿå†’äº†ã€‚<br>ç»§ç»­åŠªåŠ›ï¼Œè´Ÿé‡å‰è¡Œã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W7repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/09/09/W7repo/</url>
      <content type="html"><![CDATA[<p>ä¸‹å‘¨æ‰˜ç¦ã€‚<br>å¿«ç­‹ç–²åŠ›å°½çš„æ—¶å€™æ’‘ä¸€æ’‘ï¼Œå¸Œæœ›å°±åœ¨å‰æ–¹ã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W6repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/09/03/W6repo/</url>
      <content type="html"><![CDATA[<p>å›žå­¦æ ¡å•¦ï¼Œå›¾åƒå¤„ç†çš„å†…å®¹çœ‹èµ·æ¥ä¸è½»æ¾ï¼ŒåŒæ—¶è¿˜è¦å‡†å¤‡æ‰˜ç¦GREå’Œæˆç»©å•æŽ¨èä¿¡ï¼Œå¾ˆç´¯ã€‚<br>åœ¨è¿™å‡ å¹´ç§ä¸‹çš„ç§å­ï¼Œå¸Œæœ›è¿‡å‡ ä¸ªæœˆèƒ½æ”¶èŽ·ã€‚<br>åŠ æ²¹ã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W5repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/08/27/W5repo/</url>
      <content type="html"><![CDATA[<p>è¿™å‘¨å­¦äº†ä¸€äº›github lab çš„å°è¯¾ã€‚<br>æ–‡ä¹¦ç›®å‰v1.1.<br>åˆ åŽ»äº†ä¸€äº›å­¦æ ¡ã€‚<br>ç»§ç»­åŠªåŠ›ã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W4repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/08/19/W4repo/</url>
      <content type="html"><![CDATA[<p>æœ¬å‘¨é‡æ„Ÿå†’ï¼Œå¸Œæœ›ä¹‹åŽå¥½å¥½è¡¥ä¸Šæœ¬å‘¨æ‹‰ä¸‹çš„ã€‚ä¸Šåˆæ–‡ä¹¦ï¼Œä¸‹åˆè‹±è¯­ï¼Œæ™šä¸Šç¼–ç¨‹ã€‚<br>åŠ æ²¹ã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W3repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/08/12/W3repo/</url>
      <content type="html"><![CDATA[<p>è¿™å‘¨ä¹°äº†æžå®¢æ—¶é—´ä¸Šçš„å‡ é—¨è¯¾ï¼Œå¸Œæœ›ä»¥åŽèƒ½å¥½å¥½åˆ©ç”¨ã€‚<br>åŒæ—¶é“¶æ²³å¸å›½è¯»åˆ°ç¬¬åæœ¬ï¼Œæ„Ÿæ‚Ÿé¢‡å¤šã€‚è°¢é¡¿ä»£è¡¨çš„è‹±é›„å²è§‚ï¼Œæœ€åŽä»æ˜¯æœºå™¨äººåœ¨å¹•åŽæŽ¨åŠ¨çš„ç»“æžœï¼Œè€Œ<br>ç©¶å…¶åŽŸå› ï¼Œä»æ˜¯äººç±»è‡ªå·±ç§ä¸‹çš„å–„æžœã€‚äººç±»ç ”å‘å‡ºæ¯”è‡ªå·±æ›´å®Œç¾Žçš„å­˜åœ¨ï¼Œå°±è¿™ä¸€ç‚¹è€Œè¨€ï¼Œäººä¸Žç¥žä¸€æ ·<br>é«˜è´µã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W2repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/08/06/W2repo/</url>
      <content type="html"><![CDATA[<p>è¿™å‘¨ç»“æŸäº†å®žä¹ ï¼Œä¹Ÿç®—æœ‰ç‚¹æ”¶èŽ·ã€‚<br>å¯¹jspçš„è®¤è¯†æ›´æ·±å…¥äº†ã€‚<br>æ­£å¼å‡†å¤‡ç”³è¯·äº†ã€‚<br>å¸Œæœ›ä¹‹åŽä¹Ÿè¦åŠªåŠ›ã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W1repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/07/30/W1repo/</url>
      <content type="html"><![CDATA[<p>è¿™å‘¨çœ‹è¿‡çš„Mediumï¼š<br>1ã€åŽç«¯è·¯çº¿å›¾ï¼Œå·²Markã€‚<br>2ã€OOPçš„ç¼ºç‚¹ï¼Œä¸æ— é“ç†ï¼Œä½†è¿˜æœªåœ¨ç”Ÿäº§ä¸­ä½“ä¼šåˆ°ã€‚</p>
<p>è¿™å‘¨å¼€å§‹è¿›å…¥å·¥ä½œï¼Œé€æ¸ç†Ÿæ‚‰ä¸šåŠ¡ã€‚Mybaitsè¿˜æ˜¯å¾ˆä¸é”™çš„ï¼ŒåŒæ—¶ä¹Ÿç”¨åˆ°äº†CVSã€‚è¦è®°å¾—ï¼ŒMyEclipseå¦‚æžœæ‰“å¼€å¤šä¸ªé¡¹ç›®ï¼Œ<br>åŒåå‡½æ•°å¯èƒ½ä¼šäº§ç”Ÿå¹²æ‰°ã€‚è¿˜æœ‰å°±æ˜¯å¯¹jså’Œjspçš„ä¿®æ”¹ä¸ç”¨é‡å¯æœåŠ¡å™¨ï¼Œç›´æŽ¥åˆ·æ–°é¡µé¢å³å¯ã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W0repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/07/22/W0repo/</url>
      <content type="html"><![CDATA[<p>ä»Žä»Šå¤©å¼€å§‹å†™ç¬¬ä¸€ç¯‡å‘¨è®°,ä¸»è¦æ˜¯è®°å½•ä¸€å‘¨å†…çš„æŠ€æœ¯ç±»çš„æ„Ÿæ‚Ÿå’ŒMediumè¯»åŽæ„Ÿï¼Œå¦‚æ— æ„å¤–ä¸ä¼šé™„å¸¦ä»»<br>ä½•ç”Ÿæ´»çš„å†…å®¹ã€‚<br>è¿™å‘¨çœ‹è¿‡çš„Mediumå°è±¡æ·±åˆ»çš„æœ‰ï¼š<br>1ã€Pascalçš„é‚£å¥åè¨€ï¼šâ€œAll of humanityâ€™s problems stem from manâ€™s inability to<br>sit quietly in a room alone.â€ ç¡®å®žå‡»ä¸­äº†çŽ°ä»£äººçš„ç—›ç‚¹ï¼Œå­¤ç‹¬æ˜¯ä¸€ä¸ªæ°¸æ’çš„æ— æ³•æŽ’è§£çš„ä¼Ÿå¤§<br>è¯é¢˜ã€‚è¦å­¦ä¼šåˆ©ç”¨ç‹¬å¤„ï¼Œè€Œä¸ä»…ä»…æ˜¯æ…Žç‹¬ã€‚å¯¹æŠ—çš„æ€ç»´ä¼šè®©å­¤ç‹¬ä¾µèš€å¹¶æ¯äº†ä½ ã€‚<br>2ã€æœ€é‡è¦çš„æ˜¯è§£å†³é—®é¢˜çš„èƒ½åŠ›è€Œä¸æ˜¯è¯­æ³•ã€‚è¯´åˆ°åº•è¿˜æ˜¯é€»è¾‘èƒ½åŠ›ã€‚<br>3ã€æ ¹æ®<a href="https://hackernoon.com/learn-blockchains-by-building-one-117428612f46" target="_blank" rel="noopener">è¿™ç¯‡</a>â€œLearn Blockchains by Building Oneâ€æžäº†ä¸€ä¸ªç®€æ˜“çš„åŒºå—é“¾ï¼Œè¿˜æ˜¯è›®æœ‰æ„æ€çš„ã€‚<br>æ˜Žå¤©å¼€å§‹å®žä¹ äº†ï¼Œå¸Œæœ›èƒ½æœ‰æ‰€æ”¶èŽ·ã€‚</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ä¸€æˆ˜æ€»ç»“]]></title>
      <url>https://nbPeterWang.github.io/%20/2017/05/07/%E4%B8%80%E6%88%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>è™½ç„¶æ²¡æœ‰äººå“çˆ†å‘ï¼Œä¸è¿‡ä¹Ÿç®—è¿˜ä¸é”™ã€‚ R26L28S18W21 93<br>è¿˜æ˜¯è¦åŠªåŠ›ï¼Œå£å†™ä¸€å®šè¦ç¨³å•Šï¼Œä¸‹æ¬¡ã€‚<br><a id="more"></a><br>é¦–å…ˆè¦æ„Ÿè°¢å¬åŠ›çš„é™†å®é¾™è€å¸ˆï¼Œæ•™å­¦è®¤çœŸè´Ÿè´£ï¼Œå¹¶ä¸”å¯Œæœ‰è¶£å‘³ã€‚ä»–æŠŠæˆ‘ä»Žä¸€ä¸ªå®Œå…¨ä¸çŸ¥é“æ€Žä¹ˆè®°ç¬”è®°çš„äººé”»ç»ƒæˆäº†ç¨å¾®ä¼šè®°ä¸€ç‚¹ç¬”è®°çš„äººï¼Œæˆ‘å·²ç»å¾ˆæ»¡æ„äº†ã€‚å…¶å®žè®°ç¬”è®°å¹¶ä¸æ˜¯è¦æŠŠå¬åˆ°çš„å…¨éƒ¨è®°ä¸‹æ¥ï¼Œè€Œæ˜¯è¦ç†æ¸…æ•´ç¯‡æ–‡ç« çš„è„‰ç»œã€‚æ¢å¥è¯è¯´å¦‚æžœä½ å¬æ‡‚äº†æ•´ç¯‡æ–‡ç« çš„è„‰ç»œï¼Œä¸è®°ç¬”è®°ä¹Ÿæ˜¯å¯ä»¥çš„ã€‚è®°ç¬”è®°ä¹Ÿæ˜¯ä¸€ç§è®©ä½ å¼ºåˆ¶é›†ä¸­æ³¨æ„åŠ›çš„æ–¹æ³•ï¼Œä½†ä¸å¯ä¸ºäº†è®°ç¬”è®°è€Œé”™è¿‡é‡è¦å†…å®¹ã€‚è¿™äº›éƒ½æ˜¯é™†è€å¸ˆå‘Šè¯‰æˆ‘çš„å®è´µç»éªŒã€‚å½“ç„¶ï¼Œå¬åŠ›ç¦»ä¸å¼€è‹¦ç»ƒï¼Œåªèƒ½è¯´ç»ƒäº†äºŒä¸‰åå¥—tpoæ˜¯ä¸ä¼šç™½ç»ƒçš„ã€‚æˆ‘æ‡’å¾—åšç²¾å¬ï¼Œæ‰€ä»¥æ¯ä¸€ééƒ½å½“è€ƒè¯•æ¥è®¤çœŸå¯¹å¾…ã€‚ç„¶åŽä¹Ÿå¾ˆæ„Ÿè°¢é˜…è¯»çš„è¢ç¿”è€å¸ˆï¼Œè®²çš„å¾ˆä»”ç»†ï¼Œå¯¹é¢˜åž‹çš„ç»†è‡´åˆ†æžå¸®åˆ°äº†æˆ‘å¾ˆå¤šã€‚å½“ç„¶è‡ªå·±çš„é˜…è¯»è¿˜æœ‰è¿›æ­¥çš„ç©ºé—´ã€‚æœ€åŽæ˜¯å£è¯­å’Œå†™ä½œï¼Œæˆ‘å‘æŒ¥å¾—ä¸å¥½ï¼Œä½†è¿™ä¸èƒ½æ€ªçŽ‹è€å¸ˆå’Œç«ºè€å¸ˆï¼Œå¥¹ä»¬çš„æ•™å­¦éƒ½å¾ˆè®¤çœŸè´Ÿè´£ï¼Œç‰¹åˆ«æ˜¯çŽ‹è€å¸ˆï¼Œåœ¨è¯¾åŽå¹³æ—¶ä¹Ÿç»™äº†æˆ‘å¾ˆå¤šæŒ‡å¯¼ï¼Œä¸åŽŒå…¶çƒ¦åœ°è§£ç­”æˆ‘çš„é—®é¢˜ï¼ŒçœŸçš„å¾ˆè°¢è°¢çŽ‹è€å¸ˆã€‚å¸Œæœ›ä¸‹æ¬¡æˆ‘çš„å£è¯­å’Œå†™ä½œèƒ½æœ‰è¿›æ­¥ã€‚</p>
]]></content>
      
        
        <tags>
            
            <tag> English </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[3æœˆæ€»ç»“]]></title>
      <url>https://nbPeterWang.github.io/%20/2017/03/26/3%E6%9C%88%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>ç»ˆäºŽåœ¨3æœˆ26å·è¿™ä¸€å¤©çœ‹è§äº†å¤ªé˜³ï¼Œèµ¶ç´§è¿›é»‘é­‚èµžç¾Žäº†ä¸€ä¸‹å¤ªé˜³ï¼ŒLong may the sunshine.<br>é˜´æ²‰çš„å¤©æ°”ï¼Œå®¹æ˜“è®©äººçš„å¿ƒæƒ…å˜å¾—æ²‰éƒèµ·æ¥ã€‚è¿™ä¹Ÿæ˜¯ä¸ºä»€ä¹ˆï¼Œå¤ªé˜³ä¸ç®¡åœ¨å†œä¸šæ„ä¹‰ä¸Šè¿˜æ˜¯åœ¨å¿ƒç†æ„ä¹‰ä¸Šï¼Œå¯¹äººç±»éƒ½æ˜¯å¦‚æ­¤çš„é‡è¦ã€‚<br>å¦‚æžœå¤ªä¹…åœ°è¿‡ä¸€ç§æ¨¡å¼åŒ–çš„ç”Ÿæ´»ï¼Œäººä¾¿ä¼šæ¸æ¸å¤±åŽ»ç”Ÿå‘½åŠ›ã€‚ç”Ÿå‘½é‡Œçš„å˜æ•°ï¼Œä¸ç®¡æ˜¯å¥½çš„åçš„ï¼Œç»™ä½ å¸¦æ¥å†²å‡»çš„é‚£ä¸€åˆ»ï¼Œè‡³å°‘è¯æ˜Žä½ è¿˜æ´»ç€ã€‚<br>è¿™ä¸ªæœˆæ€»ä½“æ¥è¯´æ•ˆçŽ‡è®©æˆ‘å¾ˆä¸æ»¡æ„ï¼Œå› ä¸ºæ¯æ¬¡æƒ³å¥½çš„è®¡åˆ’ï¼Œæ€»æ˜¯å› ä¸ºå¿ƒé‡Œä¸Šçš„æƒ°æ€§å®Œä¸æˆã€‚æ¯”èµ·æ‹–å»¶ï¼Œæ›´å¯æ€•çš„æ˜¯ä¸€ç‚¹ç‚¹å°å°çš„ä»˜å‡ºä¾¿è¶³ä»¥è¯´æœè‡ªå·±ä¼‘æ¯ï¼Œå¤±åŽ»æˆ˜æ–—çš„å‹‡æ°”å’Œå†³å¿ƒã€‚æƒ³åˆ°è¿™é‡Œï¼Œå¯¹è‡ªå·±çš„åŽŒæ¶ç¨‹åº¦é™¡ç„¶ä¸Šå‡ã€‚<br>å¯æ˜¯åˆæœ‰ä»€ä¹ˆåŠžæ³•å‘¢ï¼Ÿç”Ÿæ´»æ˜¯å¦‚æ­¤æ— èŠï¼Œå¦‚æ­¤æ²¡æœ‰æ„ä¹‰ã€‚<br>æœ‰æ—¶æƒ³æƒ³è‡ªå·±ä¸è¿‡æ˜¯è¿™å…·èº«ä½“ï¼Œè¿™ä¸ªä¸–ç•Œçš„è¿‡å®¢ã€‚å¦‚æžœçœŸæ˜¯å¦‚æ­¤ï¼Œå¦‚æžœæˆ‘ä»¬å…¶å®žåªæ˜¯ä»¥ç¬¬ä¸€äººç§°åœ¨â€œä½“éªŒâ€ä¸€ä¸ªå¦‚å°è¯´æˆ–ç”µå½±ä¸–ç•Œä¸­çš„äººç‰©ä¸€èˆ¬ï¼Œçœ‹ä¼¼æœ‰é€‰æ‹©çš„æœºä¼šï¼Œå®žåˆ™å‘½è¿æ“äºŽä½œè€…ä¹‹æ‰‹ï¼Œå¦‚æžœæ˜¯è¿™æ ·ï¼Œæ€Žä¹ˆåŠžï¼Ÿ<br>å¾ˆå¿«æˆ‘å°±è®°èµ·äº†ï¼Œå°±ç®—æ˜¯è¿™æ ·ï¼Œæœ‰æ—¶å€™ä½œè€…ä¹ŸæŽ§åˆ¶ä¸äº†ç¬”ä¸‹äººç‰©å’Œå‰§æƒ…çš„èµ°å‘ã€‚å¦‚æžœè¯´æˆ‘ä¸å±ˆæœäºŽè¿™ç§æ„å¿—ä¹Ÿæ˜¯ä½œè€…çš„è®¾å®šçš„è¯ï¼Œé‚£çœŸæ˜¯å†å¥½ä¸è¿‡ã€‚å› ä¸ºå¦‚æžœå’Œå…¶ä»–äººä¸€æ ·ï¼Œæˆ‘è¿™ä¸ªäººç‰©å°±å¤ªæ²¡æ„æ€äº†ã€‚<br>æœ€è¿‘å¾ˆå–œæ¬¢Oasisï¼Œæœ€å¥½çš„éŸ³ä¹ä¸€å®šæ˜¯èƒ½è®©ä½ æ²‰æµ¸çš„éŸ³ä¹ï¼Œå°½ç®¡åªæœ‰å‡ åˆ†é’Ÿï¼Œä¹Ÿæ˜¯æ— ä¸Šçš„å¹¸ç¦ã€‚<br>  Am I cracking upï¼Ÿ<br>  Or just getting older?<br>  Weâ€™re just getting older.</p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Words-Success & Work]]></title>
      <url>https://nbPeterWang.github.io/%20/2017/03/04/Words-Success-Work/</url>
      <content type="html"><![CDATA[<p>#TOEFL Words-Success &amp; Work<br>a household name å®¶å–»æˆ·æ™“çš„åå­—<br>tenacity/perseverance n æ¯…åŠ›<br>commitment/undertaking/endeavor n åŠªåŠ›åŽ»åšçš„äº‹æƒ…<br>highly-sought-after  adj å¾ˆå¤šäººéƒ½å¸Œæœ›å¾—åˆ°çš„<br>upward mobility é˜¶çº§ä¸Šå‡å¯èƒ½æ€§<br>setback æŒ«æŠ˜<br>rugged adj.åšéŸ§ä¸æ‹”çš„<br>insumountable adj ä¸å¯é€¾è¶Šçš„<br>obscure adj ä¸çŸ¥åçš„<br>well-thought-out adj æ·±æ€ç†Ÿè™‘çš„<br>peccadillo n.å¯ä»¥åŽŸè°…çš„è¿‡é”™<br>blunder n.é‡å¤§çš„è¿‡é”™<br>charismatic adj ä¸‡äººè¿·çš„<br>industrious adj å·¥ä½œå‹¤å¥‹çš„<br>feasible adj å¯è¡Œçš„<br>contentment n å¾ˆçŸ¥è¶³çš„çŠ¶æ€<br>work ethic æ•¬ä¸šç²¾ç¥ž<br>entrepreneur n ç™½æ‰‹èµ·å®¶çš„<br>zeal n ç‹‚çƒ­<br>gratification n æ»¡è¶³æ„Ÿ<br>exert oneself= do oneâ€™s best<br>interpersonal skills äººé™…äº¤å¾€èƒ½åŠ›<br>freelancer è‡ªç”±èŒä¸šè€…<br>demanding adj è‹›åˆ»çš„<br>solidarity n å›¢ç»“<br>workaholic n å·¥ä½œç‹‚<br>competent adj æœ‰ç«žäº‰åŠ›çš„<br>flawless adj å®Œç¾Žçš„<br>etiquette n ç¤¼ä»ª</p>
]]></content>
      
        <categories>
            
            <category> English </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Words </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Words-Technology & Media]]></title>
      <url>https://nbPeterWang.github.io/%20/2017/03/02/Words-Technology/</url>
      <content type="html"><![CDATA[<p>#TOEFL Words-Technology &amp; Media<br>state-of-the-art adj.éžå¸¸å…ˆè¿›çš„<br>cutting-edge  adj.å°–ç«¯çš„<br>revolutionize v å½»åº•å˜é©<br>automated adj.è‡ªåŠ¨åŒ–çš„ n. automation<br>mechanized adj.æœºæ¢°åŒ–çš„ n. mechanization<br>computer-generated adj.ç”µè„‘ç”Ÿæˆçš„<br>mass-production å¤§è§„æ¨¡ç”Ÿäº§<br>be detached from reality è„±ç¦»çŽ°å®ž<br>inconceivable adj. ä¸å¯æƒ³è±¡çš„<br>webcam n.æ‘„åƒå¤´<br>productive adj.é«˜ç”Ÿäº§çŽ‡çš„<br>novel  adj.æ–°é¢–çš„<br>user-friendly adj.å¯¹ç”¨æˆ·å‹å¥½çš„<br>conventional adj. å¸¸è§„çš„<br>enhance=boost v æé«˜<br>manufacture v ç”Ÿäº§<br>standardized adj.æ ‡å‡†åŒ–çš„<br>telecommuting n.åœ¨å®¶è¿œç¨‹ä¸Šç­<br>labor-saving/replacing machinery å‡å°‘/å–ä»£äººåŠ›çš„æœºå™¨<br>ingenious adj.æœ‰ç‹¬åˆ›æ€§çš„ ç²¾å·§çš„<br>at a staggering rate ä»¥æƒŠäººçš„é€Ÿåº¦<br>ultra-thin adj.è¶…è–„çš„<br>portable adj.ä¾¿æºçš„<br>anteena n.å¤©çº¿<br>organ transplant å™¨å®˜ç§»æ¤<br>transactions n.äº¤æ˜“<br>manned spacecraft è½½äººèˆªå¤©å™¨<br>the proliferation of the Internet/the extensive use of the Internet äº’è”ç½‘çš„å¹¿æ³›ä½¿ç”¨<br>newsworthy adj.æœ‰æ–°é—»ä»·å€¼çš„<br>informative adj.ä¿¡æ¯é‡å¤§çš„<br>entertaining adj.å¨±ä¹æ€§å¼ºçš„<br>commodity n. å•†å“<br>commercialized adj. å•†ä¸šåŒ–çš„<br>go viral æŸç§äº‹ç‰©åœ¨äº’è”ç½‘ã€åª’ä½“æˆ–å…¬ä¼—ä¸­å¿«é€Ÿä¼ å¼€<br>icon è±¡å¾<br>censorship n å®¡æŸ¥<br>make a splash æ¼”å‘˜çªç„¶æˆåŠŸ<br>blow things out of proportion å¤¸å¤§äº‹å®ž<br>entirely cut off from the outside world  å®Œå…¨ä¸Žä¸–éš”ç»<br>sitcom n.æƒ…æ™¯å–œå‰§<br>variety show ç»¼è‰ºèŠ‚ç›®<br>current affairs æ—¶äº‹<br>excessive/ gratuitous violent and pornographic contents è¿‡å¤šçš„æš´åŠ›ä¸Žè‰²æƒ…å†…å®¹<br>fraudulent adj.è¯ˆéª—æ€§çš„<br>report sth. in graphic detail æŠ¥é“éžå¸¸è¯¦å°½çš„ç»†èŠ‚<br>exaggerate things/sensationalize things å¤¸å¤§äº‹ä»¶<br>objective and balanced å…¬æ­£å®¢è§‚çš„<br>tarnish oneâ€™s reputation<br>violate /intrude on /infringe on   someoneâ€™s privacy æ¯åæŸäººå£°èª‰<br>fatucal accounts å¦‚å®žçš„æè¿°<br>cover up / gloss over /whitewash v æŽ©ç›–<br>biased /skewed/unobjective adj.ä¸å®¢è§‚çš„<br>reliable/trustworthy /dependable adj.å¯ä¿¡çš„<br>code of ethics/code of conduct é“å¾·å‡†åˆ™<br>scrutinize v ç›‘ç£<br>ubiquitous/prevalent adj æ— å¤„ä¸åœ¨çš„<br>high-profile /low-profile adj.é«˜è°ƒçš„/ä½Žè°ƒçš„<br>exclusive news ç‹¬å®¶æ–°é—»<br>the glitz and glamor æ˜Žæ˜Ÿå…‰çŽ¯<br>glamorous adj é­…åŠ›å››å°„çš„<br>in the spotlight / in the limelight å¤„åœ¨ç„¦ç‚¹<br>media hype åª’ä½“ç‚’ä½œ<br>fabricated adj æé€ çš„</p>
]]></content>
      
        <categories>
            
            <category> English </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Words </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Words]]></title>
      <url>https://nbPeterWang.github.io/%20/2017/03/01/Words/</url>
      <content type="html"><![CDATA[<h1 id="TOEFL-Words"><a href="#TOEFL-Words" class="headerlink" title="TOEFL Words"></a>TOEFL Words</h1><p>adolescent  n.é’å°‘å¹´ ;adj. é’æ˜¥æœŸçš„<br>segregate students æŠŠå­¦ç”Ÿåˆ†å¼€æ•™è‚²<br>students  appraise/evaluate their teachersâ€™ performance å­¦ç”Ÿè¯„ä»·è€å¸ˆçš„æ•™å­¦<br>generalist n.é€šæ‰<br>well-rounded/versatile adj.å…¨é¢å‘å±•çš„<br>humanities ç¤¾ä¼šç§‘å­¦<br>discipline n.å­¦ç§‘ï¼›çºªå¾‹ vt. ç®¡æ•™<br>self-discipline n.è‡ªåˆ¶åŠ›<br>primary-level secondary-level tertitary-level education å°ã€ä¸­ã€å¤§å­¦æ•™è‚²<br>schooling n.å­¦æ ¡ç»™å­¦ç”Ÿçš„æ•™è‚²<br>curriculum n.å­¦æ ¡æä¾›çš„è¯¾ç¨‹æ€»ç§°<br>be proficient in ç†Ÿç»ƒæŽŒæ¡<br>role model æ¦œæ ·</p>
<p>aaaaaaa<br>peer n.åŒé¾„äºº<br>peer pressure æ¥è‡ªå…¶ä»–åŒå­¦çš„åŽ‹åŠ›<br>well-acquainted (with) adj.å¯¹ â€¦ éžå¸¸ç†Ÿæ‚‰<br>self-esteem n.è‡ªå°Š<br>dignity n.å°Šä¸¥<br>evaluation n.è¯„ä¼°<br>indulge in   æ²‰è¿·äºŽ<br>thought-provoking adj.å‘äººæ·±æ€çš„<br>illiterate n.æ–‡ç›² adj.æ–‡ç›²çš„<br>go astray è¯¯å…¥æ­§é€”<br>uplifting adj.ä»¤äººæŒ¯å¥‹çš„<br>minors n.æœªæˆå¹´äºº<br>spoil v. æººçˆ±<br>juvenile delinquency /youth crime é’å°‘å¹´çŠ¯ç½ª<br>truancy n. é€ƒå­¦<br>formative years æˆåž‹çš„é˜¶æ®µ<br>cultivate/foster/nurture v.åŸ¹å…»<br>impart/inculcate knowledge ä¼ æŽˆçŸ¥è¯†<br>instill high morla values çŒè¾“é«˜å°šçš„ä»·å€¼è§‚<br>studentsâ€™ grasp /command of what has been taught å­¦ç”Ÿå¯¹è€å¸ˆæ‰€æ•™çŸ¥è¯†çš„æŽŒæ¡<br>employable/marketable skills å°±ä¸šæŠ€èƒ½<br>force-feed the students å¡«é¸­å¼æ•™æ³•æ•™å­¦ç”Ÿ<br>students should not be treated as passive receptacles<br>of predigested ideas å­¦ç”Ÿä¸åº”è¯¥åªæ˜¯è¢«åŠ¨æŽ¥å—çŸ¥è¯†çš„å®¹å™¨<br>memorize for memorization;s own sake ä¸ºäº†è®°å¿†è€Œè®°å¿†<br>a sense of obligation/duty/resposibility è´£ä»»æ„Ÿ<br>memorize equations,formulars,theorems and laws è®°å¿†æ–¹ç¨‹å¼ã€å…¬å¼ã€å®šç†ã€å®šå¾‹<br>follow sth indiscriminately ç›²ä»Ž<br>extinguish/ stifle /constrain creativity é™åˆ¶åˆ›é€ åŠ›çš„å‘å±•<br>dampen/sap the studentsâ€™ enthusiasm = frustrate the students æ‰“å‡»å­¦ç”Ÿçš„ç§¯æžæ€§<br>beget undue pressure äº§ç”Ÿä¸å¿…è¦çš„åŽ‹åŠ›<br>mold oneâ€™s character å¡‘é€ æŸäººçš„æ€§æ ¼<br>adverse circumstances /adversity n.é€†å¢ƒ<br>integrity n.æ­£ç›´è¯šå®žä¸”åŽŸåˆ™æ€§å¼º<br>individualism n.ä¸ªäººä¸»ä¹‰<br>egalitarian n.å¹³æƒä¸»ä¹‰<br>fulfill v. å®žçŽ°<br>extra-curricular activities å­¦æ ¡æ˜¯ç¤¾ä¼šçš„ç¼©å½±<br>indiscipline /misbehavior/mischief n.ä¸éµå®ˆçºªå¾‹<br>bilingual adj.åŒè¯­çš„<br>nagging adj.å˜´ç¢Žçš„<br>stimulating adj.æœ‰è¶£çš„<br>valedictorian n.ä¼˜ç§€æ¯•ä¸šç”Ÿ<br>graduate summa cum laude å¤§å­¦æ¯•ä¸šæˆç»©æœ€é¡¶å°–<br>illuminate v ç…§äº®/ è§£é‡Šæ¸…æ¥š<br>autonomy n. è‡ªæˆ‘ç®¡ç†<br>edification n.å¯è¿ª</p>
]]></content>
      
        <categories>
            
            <category> English </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Words </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Let's start from here]]></title>
      <url>https://nbPeterWang.github.io/%20/2017/02/16/test1/</url>
      <content type="html"><![CDATA[<h1 id="Letâ€™s-start-from-here"><a href="#Letâ€™s-start-from-here" class="headerlink" title="Letâ€™s start from here"></a>Letâ€™s start from here</h1><p>ä»Žè¿™é‡Œå¼€å§‹å§ã€‚æ‰¾äº†å¥½å¤šæ¨¡æ¿ï¼Œæœ€åŽçš„ç»“æžœä¹Ÿä¸è´Ÿè¿™ä¸€ç•ªå‘¨æŠ˜ã€‚åŸŸåè¿˜æ˜¯ç®—äº†ï¼Œå°±è¿™æ ·çŽ©çŽ©å§ã€‚</p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> start </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
