<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Everyday Leetcode 26]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/12/02/Everyday-Leetcode-26/</url>
      <content type="html"><![CDATA[<h3 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110 Balanced Binary Tree"></a>110 Balanced Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public boolean isBalanced(TreeNode root) &#123;</span><br><span class="line">      if (root == null)</span><br><span class="line">          return true;</span><br><span class="line">      return helper(root)!= -1;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int helper(TreeNode root)&#123;</span><br><span class="line">        if (root == null)</span><br><span class="line">            return 0;</span><br><span class="line">        int left = helper(root.left);</span><br><span class="line">        int right = helper(root.right);</span><br><span class="line">        if( left == -1 || right == -1 || Math.abs(left-right)&gt;1)</span><br><span class="line">            return -1;</span><br><span class="line">        return Math.max(left,right)+1;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time complexity:O(n) using DFS<br><a id="more"></a></p>
<h3 id="235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree"><a href="#235-Lowest-Common-Ancestor-of-a-Binary-Search-Tree" class="headerlink" title="235 Lowest Common Ancestor of a Binary Search Tree"></a>235 Lowest Common Ancestor of a Binary Search Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">--- iterative version</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">     if((root == null) || (p == null) || (q == null))  &#123;</span><br><span class="line">         return null;</span><br><span class="line">     &#125; </span><br><span class="line">     while(true)&#123;</span><br><span class="line">        if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            root = root.left ;</span><br><span class="line">        &#125;</span><br><span class="line">        else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            root = root.right;</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">            return root;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">--- recursive version</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if((root == null) || (p == null) || (q == null))  &#123;</span><br><span class="line">         return null;</span><br><span class="line">     &#125; </span><br><span class="line">     while(true)&#123;</span><br><span class="line">        if(root.val &gt; p.val &amp;&amp; root.val &gt; q.val)&#123;</span><br><span class="line">            return lowestCommonAncestor(root.left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        else if (root.val &lt; p.val &amp;&amp; root.val &lt; q.val)&#123;</span><br><span class="line">            return lowestCommonAncestor(root.right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        else </span><br><span class="line">            return root;</span><br><span class="line">     &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity : O(n)<br>Both uses BST’s property to locate LCA. p,q’s LCA must be larger than </p>
<h3 id="236-Lowest-Common-Ancestor-of-a-Binary-Tree"><a href="#236-Lowest-Common-Ancestor-of-a-Binary-Tree" class="headerlink" title="236 Lowest Common Ancestor of a Binary Tree"></a>236 Lowest Common Ancestor of a Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode lowestCommonAncestor(TreeNode root, TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (root == null || p == root || q == root) return root;</span><br><span class="line">        TreeNode left = lowestCommonAncestor(root.left, p , q);</span><br><span class="line">        TreeNode right = lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        if(left != null &amp;&amp; right != null) return root;</span><br><span class="line">        return left != null ? left: right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="108-Convert-Sorted-Array-to-Binary-Search-tree"><a href="#108-Convert-Sorted-Array-to-Binary-Search-tree" class="headerlink" title="108 Convert Sorted Array to Binary Search tree"></a>108 Convert Sorted Array to Binary Search tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public TreeNode sortedArrayToBST(int[] nums) &#123;</span><br><span class="line">        if(nums == null || nums.length == 0) return null;</span><br><span class="line">        return helper(nums, 0, nums.length - 1); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public TreeNode helper(int[] nums, int low, int high)&#123;</span><br><span class="line">        if (low &gt; high) return null;</span><br><span class="line">        </span><br><span class="line">        int mid = low + (high-low)/2;</span><br><span class="line">        </span><br><span class="line">        TreeNode root = new TreeNode(nums[mid]);</span><br><span class="line">        </span><br><span class="line">        root.left = helper(nums, low , mid - 1);</span><br><span class="line">        </span><br><span class="line">        root.right = helper(nums, mid + 1, high);</span><br><span class="line">        </span><br><span class="line">        return root;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity : O(n).  using low + (high-low)/2 instead of (low+high)/2 to avoid big integer overflow.<br>Space Complexity : O(logn)</p>
<h3 id="109-Convert-Sorted-List-to-Binary-Search-tree"><a href="#109-Convert-Sorted-List-to-Binary-Search-tree" class="headerlink" title="109 Convert Sorted List to Binary Search tree"></a>109 Convert Sorted List to Binary Search tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Solution&#123;</span><br><span class="line">    public TreeNode sortedListToBST(ListNode head)&#123;</span><br><span class="line">      return helper(head, null);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public TreeNode helper(ListNode head, ListNode tail)&#123;</span><br><span class="line">        if (head == null || head == tail) return null;</span><br><span class="line">        if (head.next == tail) return new TreeNode(head.val);</span><br><span class="line">        ListNode fast = head, slow = head;</span><br><span class="line">        while( fast != tail &amp;&amp; fast.next != tail)&#123;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode root = new TreeNode(slow.val);</span><br><span class="line">        root.left = helper(head, slow);</span><br><span class="line">        root.right = helper(slow.next, tail);</span><br><span class="line">        return root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Time Complexity : O(nlogn). </p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 25]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/10/24/Everyday-Leetcode-25/</url>
      <content type="html"><![CDATA[<h3 id="113-Path-Sum-II"><a href="#113-Path-Sum-II" class="headerlink" title="113    Path Sum II"></a>113    Path Sum II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; pathSum(TreeNode root, int sum) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt;ret = new ArrayList&lt;List&lt;Integer&gt;&gt;(); </span><br><span class="line">    List&lt;Integer&gt; cur = new ArrayList&lt;Integer&gt;(); </span><br><span class="line">    pathSum(root, sum, cur, ret);</span><br><span class="line">    return ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void pathSum(TreeNode root, int sum, List&lt;Integer&gt;cur, List&lt;List&lt;Integer&gt;&gt;ret)&#123;</span><br><span class="line">    if (root == null)&#123;</span><br><span class="line">        return; </span><br><span class="line">    &#125;</span><br><span class="line">    cur.add(root.val);</span><br><span class="line">    if (root.left == null &amp;&amp; root.right == null &amp;&amp; root.val == sum)&#123;</span><br><span class="line">        ret.add(new ArrayList(cur));</span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        pathSum(root.left, sum - root.val, cur, ret);</span><br><span class="line">        pathSum(root.right, sum - root.val, cur, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    cur.remove(cur.size()-1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>Using ArrayList to save the result, if find pathsum, add to the ret. Test.</p>
<h3 id="129-Sum-Root-to-Leaf-Numbers"><a href="#129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="129    Sum Root to Leaf Numbers"></a>129    Sum Root to Leaf Numbers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int sumNumbers(TreeNode root) &#123;</span><br><span class="line">	return sum(root, 0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int sum(TreeNode n, int s)&#123;</span><br><span class="line">	if (n == null) return 0;</span><br><span class="line">	if (n.right == null &amp;&amp; n.left == null) return s*10 + n.val;</span><br><span class="line">	return sum(n.left, s*10 + n.val) + sum(n.right, s*10 + n.val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Everytime we should return result * 10 plus the value of node, then we do the recursion.</p>
<h3 id="298-Binary-Tree-Longest-Consecutive-Sequence"><a href="#298-Binary-Tree-Longest-Consecutive-Sequence" class="headerlink" title="298    Binary Tree Longest Consecutive Sequence"></a>298    Binary Tree Longest Consecutive Sequence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">private int max = 0;</span><br><span class="line">    public int longestConsecutive(TreeNode root) &#123;</span><br><span class="line">        if(root == null) return 0;</span><br><span class="line">        helper(root, 0, root.val);</span><br><span class="line">        return max;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void helper(TreeNode root, int cur, int target)&#123;</span><br><span class="line">        if(root == null) return;</span><br><span class="line">        if(root.val == target) cur++;</span><br><span class="line">        else cur = 1;</span><br><span class="line">        max = Math.max(cur, max);</span><br><span class="line">        helper(root.left, cur, root.val + 1);</span><br><span class="line">        helper(root.right, cur, root.val + 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>using private variable max to save the maximum result of longest Consecutive.</p>
<h3 id="111-Minimum-Depth-of-Binary-Tree"><a href="#111-Minimum-Depth-of-Binary-Tree" class="headerlink" title="111    Minimum Depth of Binary Tree"></a>111    Minimum Depth of Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> public static int minDepth(TreeNode root) &#123;</span><br><span class="line">	if (root == null)	return 0;</span><br><span class="line">	if (root.left == null)	return minDepth(root.right) + 1;</span><br><span class="line">	if (root.right == null) return minDepth(root.left) + 1;</span><br><span class="line">	return Math.min(minDepth(root.left),minDepth(root.right)) + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>using DFS.</p>
<h3 id="104-Maximum-Depth-of-Binary-Tree"><a href="#104-Maximum-Depth-of-Binary-Tree" class="headerlink" title="104    Maximum Depth of Binary Tree"></a>104    Maximum Depth of Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int maxDepth(TreeNode root) &#123;</span><br><span class="line">        return root==null? 0 : Math.max(maxDepth(root.left), maxDepth(root.right))+1;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>using DFS.</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 24]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/10/19/Everyday-Leetcode-24/</url>
      <content type="html"><![CDATA[<h3 id="100-Same-Tree"><a href="#100-Same-Tree" class="headerlink" title="100    Same Tree"></a>100    Same Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSameTree(TreeNode p, TreeNode q) &#123;</span><br><span class="line">        if (p == null || q == null) return p == q;</span><br><span class="line">   return p.val == q.val &amp;&amp; isSameTree(p.left, q.left) &amp;&amp; isSameTree(p.right, q.right);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>recursion way, easy.</p>
<h3 id="101-Symmetric-Tree"><a href="#101-Symmetric-Tree" class="headerlink" title="101    Symmetric Tree"></a>101    Symmetric Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">        if(root==null) return true;</span><br><span class="line">        return isMirror(root, root);</span><br><span class="line">    &#125;</span><br><span class="line">     </span><br><span class="line">    public boolean isMirror(TreeNode l, TreeNode r) &#123;</span><br><span class="line">        if (l==null || r==null) return l==r;</span><br><span class="line">        return (l.val==r.val) &amp;&amp; isMirror(l.left,r.right) &amp;&amp; isMirror(l.right,r.left);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   public boolean isSymmetric(TreeNode root) &#123;</span><br><span class="line">    if (root == null) return true;</span><br><span class="line">    Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">    stack.push(root.left);</span><br><span class="line">    stack.push(root.right);</span><br><span class="line">    while (!stack.empty()) &#123;</span><br><span class="line">        TreeNode n1 = stack.pop(), n2 = stack.pop();</span><br><span class="line">        if (n1 == null &amp;&amp; n2 == null) continue;</span><br><span class="line">        if (n1 == null || n2 == null || n1.val != n2.val) return false;</span><br><span class="line">        stack.push(n1.left);</span><br><span class="line">        stack.push(n2.right);</span><br><span class="line">        stack.push(n1.right);</span><br><span class="line">        stack.push(n2.left);</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   Recursion way is easy. For iteration, I use stack.</p>
<h3 id="226-Invert-Binary-Tree"><a href="#226-Invert-Binary-Tree" class="headerlink" title="226    Invert Binary Tree"></a>226    Invert Binary Tree</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">      if(root == null) return root;</span><br><span class="line">      invertTree(root.left);</span><br><span class="line">      invertTree(root.right);</span><br><span class="line">      TreeNode temp =root.left;</span><br><span class="line">      root.left=root.right;</span><br><span class="line">      root.right=temp;</span><br><span class="line">      return root;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  public TreeNode invertTree(TreeNode root) &#123;</span><br><span class="line">       if (root == null) return null;</span><br><span class="line"></span><br><span class="line">      Queue&lt;TreeNode&gt; queue = new LinkedList&lt;&gt;();</span><br><span class="line">      queue.offer(root);</span><br><span class="line"></span><br><span class="line">      while(!queue.isEmpty()) &#123;</span><br><span class="line">           TreeNode node = queue.poll();</span><br><span class="line">           TreeNode left = node.left;</span><br><span class="line">          node.left = node.right;</span><br><span class="line">          node.right = left;</span><br><span class="line"></span><br><span class="line">          if(node.left != null) &#123;</span><br><span class="line">              queue.offer(node.left);</span><br><span class="line">          &#125;</span><br><span class="line">          if(node.right != null) &#123;</span><br><span class="line">              queue.offer(node.right);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return root;</span><br><span class="line">  </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Recursion way is easy. For iteration, I use queue.</p>
<h3 id="257-Binary-Tree-Paths"><a href="#257-Binary-Tree-Paths" class="headerlink" title="257    Binary Tree Paths"></a>257    Binary Tree Paths</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; binaryTreePaths(TreeNode root) &#123;</span><br><span class="line">      List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">      StringBuilder sb = new StringBuilder();</span><br><span class="line">      helper(res, root, sb);</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private void helper(List&lt;String&gt; res, TreeNode root, StringBuilder sb) &#123;</span><br><span class="line">      if(root == null) &#123;</span><br><span class="line">          return;</span><br><span class="line">      &#125;</span><br><span class="line">      int len = sb.length();</span><br><span class="line">      sb.append(root.val);</span><br><span class="line">      if(root.left == null &amp;&amp; root.right == null) &#123;</span><br><span class="line">          res.add(sb.toString());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">          sb.append(&quot;-&gt;&quot;);</span><br><span class="line">          helper(res, root.left, sb);</span><br><span class="line">          helper(res, root.right, sb);</span><br><span class="line">      &#125;</span><br><span class="line">      sb.setLength(len);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>Track of the length of the StringBuilder before we append anything to it before recursion and afterwards set the length back.</p>
<h3 id="112-Path-Sum"><a href="#112-Path-Sum" class="headerlink" title="112    Path Sum"></a>112    Path Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public boolean hasPathSum(TreeNode root, int sum) &#123;</span><br><span class="line">        if(root == null) return false;</span><br><span class="line"></span><br><span class="line">       if(root.left == null &amp;&amp; root.right == null) return sum == root.val;</span><br><span class="line"></span><br><span class="line">       return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>Rucursion way is easy. Just try to use  sum-root.val to  get the PathSum.</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 23]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/09/10/Everyday-Leetcode-23/</url>
      <content type="html"><![CDATA[<h3 id="367-Valid-Perfect-Square"><a href="#367-Valid-Perfect-Square" class="headerlink" title="367    Valid Perfect Square"></a>367    Valid Perfect Square</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPerfectSquare(int num) &#123;</span><br><span class="line">       if (num==1) return true;</span><br><span class="line">    else if(num&lt;2) return true;</span><br><span class="line">       else </span><br><span class="line">    &#123;</span><br><span class="line">           long low=1,high=num;</span><br><span class="line">           long mid,prod;</span><br><span class="line">           while(low&lt;high)</span><br><span class="line">           &#123;</span><br><span class="line">                mid=(low+high)/2;</span><br><span class="line">               prod=mid*mid;</span><br><span class="line">               if(prod==(long)num) return true;</span><br><span class="line">               else if (prod&lt;(long)num)&#123;</span><br><span class="line">                   low=mid+1;</span><br><span class="line">               &#125;else high=mid-1;</span><br><span class="line">           &#125;</span><br><span class="line">           </span><br><span class="line">        if (low==high) return (low*low==(long)num);</span><br><span class="line">       &#125;</span><br><span class="line">       return false;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>基本二分查找</p>
<h3 id="365-Water-and-Jug-Problem"><a href="#365-Water-and-Jug-Problem" class="headerlink" title="365    Water and Jug Problem"></a>365    Water and Jug Problem</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean canMeasureWater(int x, int y, int z) &#123;</span><br><span class="line">        if(z == 0) return true;</span><br><span class="line">        if(x + y &lt; z)</span><br><span class="line">            return false;</span><br><span class="line">        return (z%gcd(x, y)==0);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    public int gcd(int x, int y)&#123;</span><br><span class="line">        if (y==0) return x;</span><br><span class="line">            return gcd(y,x%y);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果x,y的最大公约数能被z整除，则可以。</p>
<h3 id="204-Count-Primes"><a href="#204-Count-Primes" class="headerlink" title="204    Count Primes"></a>204    Count Primes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int countPrimes(int n) &#123;</span><br><span class="line">        if(n &lt;=1 ) return 0;</span><br><span class="line">    </span><br><span class="line">    boolean[] notPrime = new boolean[n];        </span><br><span class="line">    notPrime[0] = true; </span><br><span class="line">    notPrime[1] = true; </span><br><span class="line"></span><br><span class="line">    for(int i = 2; i &lt; Math.sqrt(n); i++)&#123;</span><br><span class="line">        if(!notPrime[i])&#123;</span><br><span class="line">            for(int j = 2; j*i &lt; n; j++)&#123;</span><br><span class="line">                notPrime[i*j] = true; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    int count = 0; </span><br><span class="line">    for(int i = 2; i&lt; notPrime.length; i++)&#123;</span><br><span class="line">        if(!notPrime[i]) count++;</span><br><span class="line">    &#125;</span><br><span class="line">    return count; </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>using a cache to store the prime count, improve the performance.</p>
<h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1    Two Sum"></a>1    Two Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">       Map&lt;Integer,Integer&gt; ans= new HashMap&lt;&gt;();</span><br><span class="line">       for (int i=0; i&lt;nums.length;i++)&#123;</span><br><span class="line">         int diff=target-nums[i];</span><br><span class="line">             if (ans.containsKey(diff))</span><br><span class="line">             &#123;</span><br><span class="line">                 </span><br><span class="line">                 return new int[]&#123;ans.get(diff),i&#125;;</span><br><span class="line">             &#125;</span><br><span class="line">           ans.put(nums[i],i);</span><br><span class="line">         </span><br><span class="line">   &#125;</span><br><span class="line">       return new int[]&#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>using one-pass hashmap.</p>
<h3 id="167-Two-Sum-II-Input-array-is-sorted"><a href="#167-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="167    Two Sum II - Input array is sorted"></a>167    Two Sum II - Input array is sorted</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int[] twoSum(int[] numbers, int target) &#123;</span><br><span class="line">      int start = 0, end = numbers.length - 1;</span><br><span class="line">        while(start &lt; end)&#123;</span><br><span class="line">            if(numbers[start] + numbers[end] == target) break;</span><br><span class="line">            if(numbers[start] + numbers[end] &lt; target) start++;</span><br><span class="line">            else end--;</span><br><span class="line">        &#125;</span><br><span class="line">        return new int[]&#123;start + 1, end + 1&#125;;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>search from both start and end , using two int as a pointer.</p>
<h3 id="15-3Sum"><a href="#15-3Sum" class="headerlink" title="15    3Sum"></a>15    3Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"> Arrays.sort(num);</span><br><span class="line">List&lt;List&lt;Integer&gt;&gt; res = new LinkedList&lt;&gt;(); </span><br><span class="line">for (int i = 0; i &lt; num.length-2; i++) &#123;</span><br><span class="line">    if (i == 0 || (i &gt; 0 &amp;&amp; num[i] != num[i-1])) &#123;</span><br><span class="line">        int lo = i+1, hi = num.length-1, sum = 0 - num[i];</span><br><span class="line">        while (lo &lt; hi) &#123;</span><br><span class="line">            if (num[lo] + num[hi] == sum) &#123;</span><br><span class="line">                res.add(Arrays.asList(num[i], num[lo], num[hi]));</span><br><span class="line">                while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++;</span><br><span class="line">                while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--;</span><br><span class="line">                lo++; hi--;</span><br><span class="line">            &#125; else if (num[lo] + num[hi] &lt; sum) &#123;</span><br><span class="line">                // improve: skip duplicates</span><br><span class="line">                while (lo &lt; hi &amp;&amp; num[lo] == num[lo+1]) lo++;</span><br><span class="line">                lo++;</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                // improve: skip duplicates</span><br><span class="line">                while (lo &lt; hi &amp;&amp; num[hi] == num[hi-1]) hi--;</span><br><span class="line">                hi--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">return res;</span><br></pre></td></tr></table></figure>
<p>First, sort the array. Second, using one for loop and a while loop inside the for loop. In the while loop, using high and low to do the 2sum. And using serveral while loops to move the pointers.</p>
<h3 id="18-4Sum"><a href="#18-4Sum" class="headerlink" title="18    4Sum"></a>18    4Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res=new LinkedList&lt;&gt;();</span><br><span class="line">        if(nums.length&lt;4) return res;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for(int i=0;i&lt;nums.length-3;i++)&#123;</span><br><span class="line">            if(i&gt;0&amp;&amp;nums[i]==nums[i-1]) continue;</span><br><span class="line">            </span><br><span class="line">            if(nums[i]*4&gt;target) break;// Too Big!!</span><br><span class="line">            if(nums[i]+3*nums[nums.length-1]&lt;target) continue;//Too Small</span><br><span class="line">            </span><br><span class="line">            for(int j=i+1;j&lt;nums.length-2;j++)&#123;</span><br><span class="line">                if(j&gt;i+1&amp;&amp;nums[j]==nums[j-1]) continue;</span><br><span class="line">                </span><br><span class="line">                if(nums[j]*3&gt;target-nums[i]) break;//Too Big</span><br><span class="line">                if(nums[j]+2*nums[nums.length-1]&lt;target-nums[i]) continue;// Too Small</span><br><span class="line">                </span><br><span class="line">                int begin=j+1;</span><br><span class="line">                int end=nums.length-1;</span><br><span class="line">                while(begin&lt;end)&#123;</span><br><span class="line">                    int sum=nums[i]+nums[j]+nums[begin]+nums[end];</span><br><span class="line">                    if(sum==target)&#123;</span><br><span class="line">                        res.add(Arrays.asList(nums[i],nums[j],nums[begin],nums[end]));</span><br><span class="line">                        while(begin&lt;end &amp;&amp; nums[begin]==nums[begin+1])&#123;begin++;&#125;</span><br><span class="line">                        while(begin&lt;end &amp;&amp; nums[end]==nums[end-1])&#123;end--;&#125;</span><br><span class="line">                        begin++;</span><br><span class="line">                        end--;</span><br><span class="line">                    &#125;else if (sum&lt;target)&#123;</span><br><span class="line">                        begin++;</span><br><span class="line">                    &#125;else&#123;</span><br><span class="line">                        end--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>Same as 3sum and 2sum, the difference is  we have to judge two samll or two beg. and using 2 for loop and a while loop. Also using begin end.</p>
<h3 id="144-Binary-Tree-Preorder-Traversal"><a href="#144-Binary-Tree-Preorder-Traversal" class="headerlink" title="144    Binary Tree Preorder Traversal"></a>144    Binary Tree Preorder Traversal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; preorderTraversal(TreeNode root) &#123;</span><br><span class="line">		List&lt;Integer&gt; pre = new LinkedList&lt;Integer&gt;();</span><br><span class="line">		preHelper(root,pre);</span><br><span class="line">		return pre;</span><br><span class="line">	&#125;</span><br><span class="line">	public void preHelper(TreeNode root, List&lt;Integer&gt; pre) &#123;</span><br><span class="line">		if(root==null) return;</span><br><span class="line">		pre.add(root.val);</span><br><span class="line">		preHelper(root.left,pre);</span><br><span class="line">		preHelper(root.right,pre);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>using helper function, so that we dont have to initiate a new List at each recursion</p>
<h3 id="94-Binary-Tree-Inorder-Traversal"><a href="#94-Binary-Tree-Inorder-Traversal" class="headerlink" title="94    Binary Tree Inorder Traversal"></a>94    Binary Tree Inorder Traversal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; inorderTraversal(TreeNode root) &#123;</span><br><span class="line">       </span><br><span class="line">	List&lt;Integer&gt; in = new LinkedList&lt;Integer&gt;();</span><br><span class="line">	inHelper(root,in);</span><br><span class="line">	return in;</span><br><span class="line">&#125;</span><br><span class="line">public void inHelper(TreeNode root, List&lt;Integer&gt; in) &#123;</span><br><span class="line">	if(root==null) return;</span><br><span class="line">	inHelper(root.left,in);</span><br><span class="line">       in.add(root.val);</span><br><span class="line">	inHelper(root.right,in);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>same</p>
<h3 id="145-Binary-Tree-Postorder-Traversal"><a href="#145-Binary-Tree-Postorder-Traversal" class="headerlink" title="145    Binary Tree Postorder Traversal"></a>145    Binary Tree Postorder Traversal</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;Integer&gt; postorderTraversal(TreeNode root) &#123;</span><br><span class="line">    LinkedList&lt;Integer&gt; ans = new LinkedList&lt;&gt;();</span><br><span class="line">Stack&lt;TreeNode&gt; stack = new Stack&lt;&gt;();</span><br><span class="line">if (root == null) return ans;</span><br><span class="line"></span><br><span class="line">stack.push(root);</span><br><span class="line">while (!stack.isEmpty()) &#123;</span><br><span class="line">	TreeNode cur = stack.pop();</span><br><span class="line">	ans.addFirst(cur.val);</span><br><span class="line">	if (cur.left != null) &#123;</span><br><span class="line">		stack.push(cur.left);</span><br><span class="line">	&#125;</span><br><span class="line">	if (cur.right != null) &#123;</span><br><span class="line">		stack.push(cur.right);</span><br><span class="line">	&#125; </span><br><span class="line">&#125;</span><br><span class="line">return ans;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>No recursion version. using linkedlist and stack. Because insertion is O(1) in LinkedList, and it’s O(n) in ArrayList. </p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 22]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/08/02/Everyday-Leetcode-22/</url>
      <content type="html"><![CDATA[<h3 id="67-Add-Binary"><a href="#67-Add-Binary" class="headerlink" title="67    Add Binary"></a>67    Add Binary</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public String addBinary(String a, String b) &#123;</span><br><span class="line">      StringBuilder sb = new StringBuilder();</span><br><span class="line">        int i=a.length()-1, j=b.length()-1, memo=0;</span><br><span class="line">        while(j&gt;=0 || i&gt;=0)&#123;</span><br><span class="line">        int sum= memo;</span><br><span class="line">        if(i&gt;=0) sum+= a.charAt(i--)-&apos;0&apos;;</span><br><span class="line">        if(j&gt;=0) sum+= b.charAt(j--)-&apos;0&apos;;</span><br><span class="line">        memo=sum/2;</span><br><span class="line">        sb.append(sum%2);</span><br><span class="line">        &#125;</span><br><span class="line">        if(memo!=0) sb.append(memo);</span><br><span class="line">        return sb.reverse().toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>从右往左计算，每一位算出当前位的和再对2取余，就是这一位的结果，最后把第一位的结果加入到StringBuilder再反向输出。<br><a id="more"></a></p>
<h3 id="43-Multiply-Strings"><a href="#43-Multiply-Strings" class="headerlink" title="43    Multiply Strings"></a>43    Multiply Strings</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public String multiply(String num1, String num2) &#123;</span><br><span class="line">      int n=num1.length(), m=num2.length();</span><br><span class="line">      int[] pos= new int[m + n];</span><br><span class="line">      if(num1.length()==0 ||num2.length()==0) return &quot;0&quot;;</span><br><span class="line">        for(int i=n-1;i&gt;=0;i--)</span><br><span class="line">            for(int j=m-1;j&gt;=0;j--)&#123;</span><br><span class="line">                int res=(num1.charAt(i)-&apos;0&apos;)* (num2.charAt(j)-&apos;0&apos;);</span><br><span class="line">                int p1=i+j, p2=i+j+1;</span><br><span class="line">                int sum= res+=pos[p2];</span><br><span class="line">                pos[p1]+=sum/10;</span><br><span class="line">                pos[p2]=(sum)%10;</span><br><span class="line">            &#125;</span><br><span class="line">         StringBuilder sb = new StringBuilder();</span><br><span class="line">    for(int p : pos) if(!(sb.length() == 0 &amp;&amp; p == 0)) sb.append(p);</span><br><span class="line">    return sb.length() == 0 ? &quot;0&quot; : sb.toString();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算每一位的结果并将进位的结果每次都累加。</p>
<h3 id="29-Divide-Two-Integers"><a href="#29-Divide-Two-Integers" class="headerlink" title="29    Divide Two Integers"></a>29    Divide Two Integers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">public int divide(int dividend, int divisor) &#123;       </span><br><span class="line">      if(dividend ==  Integer.MIN_VALUE &amp;&amp; divisor == -1)&#123;</span><br><span class="line">          return Integer.MAX_VALUE;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      boolean isNeg = (dividend &lt; 0) ^ (divisor &lt; 0);</span><br><span class="line">      if(dividend &gt; 0) dividend = -dividend;</span><br><span class="line">      if(divisor &gt; 0) divisor = -divisor;</span><br><span class="line">         </span><br><span class="line">      return isNeg? -div(dividend, divisor) : div(dividend, divisor);</span><br><span class="line">  &#125;</span><br><span class="line">  public int div(int divid, int divis)&#123;</span><br><span class="line">      if(divid &gt; divis) return 0;</span><br><span class="line">      int curSum = divis &lt;&lt; 1, prevSum = divis, q = 1;</span><br><span class="line">      </span><br><span class="line">      while(divid &lt;= curSum &amp;&amp; curSum &lt; prevSum)&#123;</span><br><span class="line">          prevSum = curSum;</span><br><span class="line">          curSum &lt;&lt;= 1; q &lt;&lt;= 1;</span><br><span class="line">      &#125;</span><br><span class="line">      return q + div(divid - prevSum, divis);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>每次将divisor×2，如果大于dividend就返回之前的结果+差的结果。</p>
<h3 id="69-Sqrt-x"><a href="#69-Sqrt-x" class="headerlink" title="69    Sqrt(x)"></a>69    Sqrt(x)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int mySqrt(int x) &#123;</span><br><span class="line">      int i = 1;</span><br><span class="line">      int j = x;</span><br><span class="line">      int ans = 0;</span><br><span class="line">      while (i &lt;=j)&#123;</span><br><span class="line">          int mid = i + (j-i)/2;</span><br><span class="line">          if (mid &lt;= x/mid)&#123;</span><br><span class="line">              i = mid +1;</span><br><span class="line">              ans = mid;</span><br><span class="line">          &#125;</span><br><span class="line">          else</span><br><span class="line">              j = mid-1;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      return ans;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>二分法，当i小于j的时候，每次mid都=左指针+左右指针距离的的1/2，找到最接近x的n*n。</p>
<h3 id="50-Pow-x-n"><a href="#50-Pow-x-n" class="headerlink" title="50    Pow(x, n)"></a>50    Pow(x, n)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public double myPow(double x, int n) &#123;</span><br><span class="line">       if(n == 0)</span><br><span class="line">           return 1;</span><br><span class="line">       if(n&lt;0)&#123;</span><br><span class="line">           if(n == Integer.MIN_VALUE) &#123;</span><br><span class="line">           n += 2;</span><br><span class="line">       &#125;</span><br><span class="line">       n = -n;</span><br><span class="line">       x = 1/x;</span><br><span class="line">       &#125;</span><br><span class="line">       return (n%2 == 0) ? myPow(x*x, n/2) : x*myPow(x*x, n/2);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>每次都递归调用自身 n每次/2，要注意MIN_VALUE的情况会溢出，所以n+=2。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 21]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/07/25/Everyday-Leetcode-21/</url>
      <content type="html"><![CDATA[<h3 id="7-Reverse-Integer"><a href="#7-Reverse-Integer" class="headerlink" title="7    Reverse Integer"></a>7    Reverse Integer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int reverse(int x) &#123;</span><br><span class="line">          long rev= 0;</span><br><span class="line">        while( x != 0)&#123;</span><br><span class="line">            rev= rev*10 + x % 10;</span><br><span class="line">            x= x/10;</span><br><span class="line">            if( rev &gt; Integer.MAX_VALUE || rev &lt; Integer.MIN_VALUE)</span><br><span class="line">                return 0;</span><br><span class="line">        &#125;</span><br><span class="line">        return (int) rev;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>每次将最后一位*10+之前的一位。</p>
<h3 id="165-Compare-Version-Numbers"><a href="#165-Compare-Version-Numbers" class="headerlink" title="165    Compare Version Numbers"></a>165    Compare Version Numbers</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int compareVersion(String version1, String version2) &#123;</span><br><span class="line">   String[] levels1 = version1.split(&quot;\\.&quot;);</span><br><span class="line">   String[] levels2 = version2.split(&quot;\\.&quot;);</span><br><span class="line">   </span><br><span class="line">   int length = Math.max(levels1.length, levels2.length);</span><br><span class="line">   for (int i=0; i&lt;length; i++) &#123;</span><br><span class="line">   	Integer v1 = i &lt; levels1.length ? Integer.parseInt(levels1[i]) : 0;</span><br><span class="line">   	Integer v2 = i &lt; levels2.length ? Integer.parseInt(levels2[i]) : 0;</span><br><span class="line">   	int compare = v1.compareTo(v2);</span><br><span class="line">   	if (compare != 0) &#123;</span><br><span class="line">   		return compare;</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return 0;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先把.去掉，取两个字符串中最大的长度，然后逐位比较。</p>
<h3 id="66-Plus-One"><a href="#66-Plus-One" class="headerlink" title="66    Plus One"></a>66    Plus One</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"> public int[] plusOne(int[] digits) &#123;</span><br><span class="line">        int n = digits.length;</span><br><span class="line">        for (int i = digits.length - 1; i &gt;= 0; --i) &#123;</span><br><span class="line">            if (digits[i] &lt; 9) &#123;</span><br><span class="line">                ++digits[i];</span><br><span class="line">                return digits;</span><br><span class="line">            &#125;</span><br><span class="line">            digits[i] = 0;</span><br><span class="line">        &#125;</span><br><span class="line">        int[] res = new int[n + 1];</span><br><span class="line">        res[0] = 1;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果该位小于9就+1返回，否则=0.这样可以完成进位。</p>
<h3 id="8-String-to-Integer-atoi"><a href="#8-String-to-Integer-atoi" class="headerlink" title="8    String to Integer (atoi)"></a>8    String to Integer (atoi)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"> public int myAtoi(String str) &#123;</span><br><span class="line">	if (str.isEmpty())</span><br><span class="line">		return 0;</span><br><span class="line">	str = str.trim();</span><br><span class="line">      if (str.isEmpty())</span><br><span class="line">		return 0;</span><br><span class="line">	int i = 0, ans = 0, sign = 1, len = str.length();</span><br><span class="line">	if (str.charAt(i) == &apos;-&apos; || str.charAt(i) == &apos;+&apos;)</span><br><span class="line">		sign = str.charAt(i++) == &apos;+&apos; ? 1 : -1;</span><br><span class="line">	for (; i &lt; len; ++i) &#123;</span><br><span class="line">		int tmp = str.charAt(i) - &apos;0&apos;;</span><br><span class="line">		if (tmp &lt; 0 || tmp &gt; 9)</span><br><span class="line">			break;</span><br><span class="line">		if (ans &gt; Integer.MAX_VALUE / 10</span><br><span class="line">				|| (ans == Integer.MAX_VALUE / 10 &amp;&amp; Integer.MAX_VALUE % 10 &lt; tmp))</span><br><span class="line">			return sign == 1 ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">		else</span><br><span class="line">			ans = ans * 10 + tmp;</span><br><span class="line">	&#125;</span><br><span class="line">	return sign * ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，handle空字串，去掉空格后再handle，否则会越界。后面当ans越界时返回正无穷或负无穷。ans每次*10再加上tmp。</p>
<h3 id="258-Add-Digits"><a href="#258-Add-Digits" class="headerlink" title="258    Add Digits"></a>258    Add Digits</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public int addDigits(int num) &#123;</span><br><span class="line">        return (num!=0 &amp;&amp; num%9==0) ? 9 : num%9;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>返回9或对9取余的结果即可。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 20]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/07/22/Everyday-Leetcode-20/</url>
      <content type="html"><![CDATA[<h3 id="32-Longest-Valid-Parentheses"><a href="#32-Longest-Valid-Parentheses" class="headerlink" title="32    Longest Valid Parentheses"></a>32    Longest Valid Parentheses</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int longestValidParentheses(String s) &#123;</span><br><span class="line">    char[] S = s.toCharArray();</span><br><span class="line">    int[] V = new int[S.length];</span><br><span class="line">    int open = 0;</span><br><span class="line">    int max = 0;</span><br><span class="line">    for (int i=0; i&lt;S.length; i++) &#123;</span><br><span class="line">        if (S[i] == &apos;(&apos;) open++;</span><br><span class="line">        if (S[i] == &apos;)&apos; &amp;&amp; open &gt; 0) &#123;</span><br><span class="line">            // matches found</span><br><span class="line">            V[i] = 2+ V[i-1];</span><br><span class="line">            // add matches from previous</span><br><span class="line">            if(i-V[i]&gt;0)</span><br><span class="line">                V[i] += V[i-V[i]];</span><br><span class="line">            open--;</span><br><span class="line">        &#125;</span><br><span class="line">        if (V[i] &gt; max) max = V[i];</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>dp,状态方程式为V[i] = 2+ V[i-1]+ previous matches V[i- (V[i-1] + 2) ] if S[i] = ‘)’ and ‘(‘ count &gt; 0。</p>
<h3 id="241-Different-Ways-to-Add-Parentheses"><a href="#241-Different-Ways-to-Add-Parentheses" class="headerlink" title="241    Different Ways to Add Parentheses"></a>241    Different Ways to Add Parentheses</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">private Map&lt;String,List&lt;Integer&gt;&gt; memo = new HashMap&lt;&gt;();</span><br><span class="line">   public List&lt;Integer&gt; diffWaysToCompute(String input) &#123;</span><br><span class="line">       int len = input.length();</span><br><span class="line">       List&lt;Integer&gt; result = memo.get(input);</span><br><span class="line">       if (result != null) &#123; return result; &#125;</span><br><span class="line">       result = new ArrayList&lt;&gt;();</span><br><span class="line">       if (isDigit(input)) &#123;</span><br><span class="line">           result.add(Integer.parseInt(input));</span><br><span class="line">           memo.put(input,result);</span><br><span class="line">           return result;</span><br><span class="line">       &#125;</span><br><span class="line">       for (int i = 0; i &lt; len; i++) &#123;</span><br><span class="line">           char c = input.charAt(i);</span><br><span class="line">           if (c == &apos;+&apos; || c == &apos;-&apos; || c == &apos;*&apos;) &#123;</span><br><span class="line">               List&lt;Integer&gt; left = diffWaysToCompute(input.substring(0,i));</span><br><span class="line">               List&lt;Integer&gt; right = diffWaysToCompute(input.substring(i+1,len));</span><br><span class="line">               for (Integer il : left) &#123;</span><br><span class="line">                   for (Integer ir : right) &#123;</span><br><span class="line">                       switch (c) &#123;</span><br><span class="line">                           case &apos;+&apos;: result.add(il + ir); break;</span><br><span class="line">                           case &apos;-&apos;: result.add(il - ir); break;</span><br><span class="line">                           case &apos;*&apos;: result.add(il * ir); break;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       memo.put(input,result);</span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br><span class="line">   private boolean isDigit(String s) &#123;</span><br><span class="line">       for (Character c : s.toCharArray()) &#123;</span><br><span class="line">           if (!Character.isDigit(c)) &#123; return false; &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先维护一个private的hashmap用来储存。如果已经有结果直接返回，如果是数字，直接加入到memo并返回。遍历字符，将左边的和右边的都递归调用自身返回结果，然后根据当前符号计算，最后保存结果到hashmap。</p>
<h3 id="301-Remove-Invalid-Parentheses"><a href="#301-Remove-Invalid-Parentheses" class="headerlink" title="301    Remove Invalid Parentheses"></a>301    Remove Invalid Parentheses</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; removeInvalidParentheses(String s) &#123;</span><br><span class="line">    List&lt;String&gt; ans = new ArrayList&lt;&gt;();</span><br><span class="line">    remove(s, ans, 0, 0, new char[]&#123;&apos;(&apos;, &apos;)&apos;&#125;);</span><br><span class="line">    return ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void remove(String s, List&lt;String&gt; ans, int last_i, int last_j,  char[] par) &#123;</span><br><span class="line">    for (int stack = 0, i = last_i; i &lt; s.length(); ++i) &#123;</span><br><span class="line">        if (s.charAt(i) == par[0]) stack++;</span><br><span class="line">        if (s.charAt(i) == par[1]) stack--;</span><br><span class="line">        if (stack &gt;= 0) continue;</span><br><span class="line">        for (int j = last_j; j &lt;= i; ++j)</span><br><span class="line">            if (s.charAt(j) == par[1] &amp;&amp; (j == last_j || s.charAt(j - 1) != par[1]))</span><br><span class="line">                remove(s.substring(0, j) + s.substring(j + 1, s.length()), ans, i, j, par);</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    String reversed = new StringBuilder(s).reverse().toString();</span><br><span class="line">    if (par[0] == &apos;(&apos;) // finished left to right</span><br><span class="line">        remove(reversed, ans, 0, 0, new char[]&#123;&apos;)&apos;, &apos;(&apos;&#125;);</span><br><span class="line">    else // finished right to left</span><br><span class="line">        ans.add(reversed);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>stack遇到左括号自增1，遇到右括号自减1。当stack&lt;0时，从上一个删除的位置开始遍历。当当前字符为右括号而且是第一个右括号，删除当前右括号并递归。后面将字符串反转，如果par是左括号，则调用递归函数传入反向括号来删除多的左括号。否则说明已经反转，可以直接加入结果了。</p>
<h3 id="392-Is-Subsequence"><a href="#392-Is-Subsequence" class="headerlink" title="392    Is Subsequence"></a>392    Is Subsequence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isSubsequence(String s, String t) </span><br><span class="line">  &#123;</span><br><span class="line">      if(t.length() &lt; s.length()) return false;</span><br><span class="line">      int prev = 0;</span><br><span class="line">      for(int i = 0; i &lt; s.length();i++)</span><br><span class="line">      &#123;</span><br><span class="line">          char tempChar = s.charAt(i);</span><br><span class="line">          prev = t.indexOf(tempChar,prev);</span><br><span class="line">          if(prev == -1) return false;</span><br><span class="line">          prev++;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      return true;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>使用string的indexOf，每次都检索是否从当前位置开始，是否有s的字符在t中。</p>
<h3 id="115-Distinct-Subsequences"><a href="#115-Distinct-Subsequences" class="headerlink" title="115    Distinct Subsequences"></a>115    Distinct Subsequences</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int numDistinct(String S, String T) &#123;</span><br><span class="line">   int[][] mem = new int[T.length()+1][S.length()+1];</span><br><span class="line">   for(int j=0; j&lt;=S.length(); j++) &#123;</span><br><span class="line">       mem[0][j] = 1;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   </span><br><span class="line">   for(int i=0; i&lt;T.length(); i++) &#123;</span><br><span class="line">       for(int j=0; j&lt;S.length(); j++) &#123;</span><br><span class="line">           if(T.charAt(i) == S.charAt(j)) &#123;</span><br><span class="line">               mem[i+1][j+1] = mem[i][j] + mem[i+1][j];</span><br><span class="line">           &#125; else &#123;</span><br><span class="line">               mem[i+1][j+1] = mem[i+1][j];</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return mem[T.length()][S.length()];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>dp 。dp[i][j] = dp[i-1][j] + dp[i-1][j-1]</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 19]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/07/21/Everyday-Leetcode-19/</url>
      <content type="html"><![CDATA[<h3 id="131-Palindrome-Partitioning"><a href="#131-Palindrome-Partitioning" class="headerlink" title="131    Palindrome Partitioning"></a>131    Palindrome Partitioning</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;String&gt;&gt; partition(String s) &#123;</span><br><span class="line">	List&lt;List&lt;String&gt;&gt; lists=new ArrayList&lt;&gt;();</span><br><span class="line">	int len=s.length();</span><br><span class="line">	if(len==0) return lists;</span><br><span class="line">	backtrack(lists, new ArrayList&lt;&gt;(), s,0,len);</span><br><span class="line">	return lists;</span><br><span class="line">&#125;</span><br><span class="line">private void backtrack(List&lt;List&lt;String&gt;&gt; lists,List&lt;String&gt; list,String s, int l, int r) &#123;</span><br><span class="line">	if(l==r) &#123;</span><br><span class="line">		lists.add(new ArrayList&lt;&gt;(list));</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	for(int i=l+1;i&lt;=r;i++) &#123;</span><br><span class="line">		if(isPalindrome(s, l, i)) &#123;</span><br><span class="line">			list.add(s.substring(l, i));</span><br><span class="line">			backtrack(lists, list, s,i,r);</span><br><span class="line">			list.remove(list.size()-1);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">private boolean isPalindrome(String s, int l, int r)&#123;</span><br><span class="line">    if(l==r-1) return true;</span><br><span class="line">    while(l&lt;r-1)&#123;</span><br><span class="line">        if(s.charAt(l)!=s.charAt(r-1)) return false;</span><br><span class="line">        l++;r--;</span><br><span class="line">    &#125;</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>isPalindrome判断回文串，backtrack函数，遍历过程中如果l=r说明已经遍历完成，返回。否则遍历如果当前l到i为字符串为回文串，加到list中并递归调用backtrack(i后面的字符串)最后remove掉最后new的空字符串数组。</p>
<h3 id="132-Palindrome-Partitioning-II"><a href="#132-Palindrome-Partitioning-II" class="headerlink" title="132    Palindrome Partitioning II"></a>132    Palindrome Partitioning II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int minCut(String s) &#123;</span><br><span class="line">        int n = s.length();</span><br><span class="line">        boolean dp[][] = new boolean[n+1][n+1];</span><br><span class="line">        int min[] = new int[n];</span><br><span class="line">        for(int i=0; i&lt;n; ++i) &#123;</span><br><span class="line">            min[i] = i;</span><br><span class="line">            for(int j=0; j&lt;=i; ++j) &#123;</span><br><span class="line">                if(s.charAt(i) == s.charAt(j) &amp;&amp; (j+1 &gt; i-1 || dp[j+1][i-1])) &#123;</span><br><span class="line">                    dp[j][i] = true;</span><br><span class="line">                    min[i] = j == 0 ? 0 : Math.min(min[i], min[j-1] + 1);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min[n-1];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>当[j][i]为回文时，dp[j+1][i-1]==true，且s.charAt(i) == s.charAt(j)。所以利用这个写出dp。第一个for循环遍历的是i，此时我们现将 min[i] 初始化为 i，因为对于区间 [0, i]，就算我们每个字母割一刀，最多能只用分割 i 次，不需要再多于这个数字。但是可能会变小，所以第二个for循环用 j 遍历区间 [0, j]，根据上面的解释，我们需要验证的是区间 [j, i] 内的子串是否为回文串，那么只要 s[j] == s[i]，并且 j+1&gt;i-1 或者 p[j+1][i-1] 为true的话，先更新 dp[j][i] 为true，然后在更新 dp[i]，这里需要注意一下corner case，当 j=0 时，我们直接给 dp[i] 赋值为0，因为此时能运行到这，说明 [j, i] 区间是回文串，而 j=0， 则说明 [0, i] 区间内是回文串，这样根本不用分割啊。若 j 大于0，则用 min[j-1] + 1 来更新,min[ i]，最终返回 min[n-1] 即可。</p>
<h3 id="267-Palindrome-Permutation-II"><a href="#267-Palindrome-Permutation-II" class="headerlink" title="267    Palindrome Permutation II"></a>267    Palindrome Permutation II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">    vector&lt;string&gt; generatePalindromes(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        unordered_map&lt;char, int&gt; m;</span><br><span class="line">        string t = &quot;&quot;, mid = &quot;&quot;;</span><br><span class="line">        for (auto a : s) ++m[a];</span><br><span class="line">        for (auto &amp;it : m) &#123;</span><br><span class="line">            if (it.second % 2 == 1) mid += it.first;</span><br><span class="line">            it.second /= 2;</span><br><span class="line">            t += string(it.second, it.first);</span><br><span class="line">            if (mid.size() &gt; 1) return &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        permute(t, m, mid, &quot;&quot;, res);</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    void permute(string &amp;t, unordered_map&lt;char, int&gt; &amp;m, string mid, string out, vector&lt;string&gt; &amp;res) &#123;</span><br><span class="line">        if (out.size() &gt;= t.size()) &#123;</span><br><span class="line">            res.push_back(out + mid + string(out.rbegin(), out.rend()));</span><br><span class="line">            return;</span><br><span class="line">        &#125; </span><br><span class="line">        for (auto &amp;it : m) &#123;</span><br><span class="line">            if (it.second &gt; 0) &#123;</span><br><span class="line">                --it.second;</span><br><span class="line">                permute(t, m, mid, out + it.first, res);</span><br><span class="line">                ++it.second;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>用哈希表来记录所有字符的出现个数，然后我们找出出现奇数次数的字符加入mid中，如果有两个或两个以上的奇数个数的字符，那么返回空集，我们对于每个字符，不管其奇偶，都将其个数除以2的个数的字符加入t中，这样做的原因是如果是偶数个，那么将其一般加入t中，如果是奇数，如果有1个，那么除以2是0，不会有字符加入t，如果是3个，那么除以2是1，取一个加入t。等我们获得了t之后，t是就是前半段字符，我们对其做全排列，每得到一个全排列，我们加上mid和该全排列的逆序列就是一种所求的回文字符串，这样我们就可以得到所有的回文全排列了。同时用hashset防重复。</p>
<h3 id="20-Valid-Parentheses"><a href="#20-Valid-Parentheses" class="headerlink" title="20    Valid Parentheses"></a>20    Valid Parentheses</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isValid(String s) &#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = new Stack&lt;Character&gt;();</span><br><span class="line">	for (char c : s.toCharArray()) &#123;</span><br><span class="line">		if (c == &apos;(&apos;)</span><br><span class="line">			stack.push(&apos;)&apos;);</span><br><span class="line">		else if (c == &apos;&#123;&apos;)</span><br><span class="line">			stack.push(&apos;&#125;&apos;);</span><br><span class="line">		else if (c == &apos;[&apos;)</span><br><span class="line">			stack.push(&apos;]&apos;);</span><br><span class="line">		else if (stack.isEmpty() || stack.pop() != c)</span><br><span class="line">			return false;</span><br><span class="line">	&#125;</span><br><span class="line">	return stack.isEmpty();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>利用栈，如果是左边的（{[，就把右边的压入栈中，否则就判断是否能消去，或者栈为空。最后栈为空的情况下就是true。</p>
<h3 id="22-Generate-Parentheses"><a href="#22-Generate-Parentheses" class="headerlink" title="22    Generate Parentheses"></a>22    Generate Parentheses</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; generateParenthesis(int n) &#123;</span><br><span class="line">       List&lt;String&gt; list = new ArrayList&lt;String&gt;();</span><br><span class="line">       backtrack(list, &quot;&quot;, 0, 0, n);</span><br><span class="line">       return list;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public void backtrack(List&lt;String&gt; list, String str, int open, int close, int max)&#123;</span><br><span class="line">       </span><br><span class="line">       if(str.length() == max*2)&#123;</span><br><span class="line">           list.add(str);</span><br><span class="line">           return;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       if(open &lt; max)</span><br><span class="line">           backtrack(list, str+&quot;(&quot;, open+1, close, max);</span><br><span class="line">       if(close &lt; open)</span><br><span class="line">           backtrack(list, str+&quot;)&quot;, open, close+1, max);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>递归调用资深，如果str长度等于n*2则直接返回res。如果open&lt;n就加（，close&lt;open就加），最后返回res。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 18]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/07/20/Everyday-Leetcode-18/</url>
      <content type="html"><![CDATA[<h3 id="266-Palindrome-Permutation"><a href="#266-Palindrome-Permutation" class="headerlink" title="266    Palindrome Permutation"></a>266    Palindrome Permutation</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bool canPermutePalindrome(string s) &#123;</span><br><span class="line">        unordered_map&lt;char, int&gt; m;</span><br><span class="line">        int cnt = 0;</span><br><span class="line">        for (auto a : s) ++m[a];</span><br><span class="line">        for (auto a : m) &#123;</span><br><span class="line">            if (a.second % 2 == 1) ++cnt;</span><br><span class="line">        &#125;</span><br><span class="line">        return cnt == 0 || (s.size() % 2 == 1 &amp;&amp; cnt == 1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>创建字符串的hashmap，字符是key，出现次数是value。统计出现次数为奇数的字符个数，如果为0则可以全排列回文，如果为1且只有1个字符出现奇数次，也可以全排列回文。<br><!-- mroe --></p>
<h3 id="5-Longest-Palindromic-Substring"><a href="#5-Longest-Palindromic-Substring" class="headerlink" title="5    Longest Palindromic Substring"></a>5    Longest Palindromic Substring</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public String longestPalindrome(String s) &#123;</span><br><span class="line">       String res = &quot;&quot;;</span><br><span class="line">       int currLength = 0;</span><br><span class="line">       for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">           if(isPalindrome(s,i-currLength-1,i))&#123;</span><br><span class="line">               res = s.substring(i-currLength-1,i+1);</span><br><span class="line">               currLength = currLength+2;</span><br><span class="line">           &#125;</span><br><span class="line">           else if(isPalindrome(s,i-currLength,i))&#123;</span><br><span class="line">               res = s.substring(i-currLength,i+1);</span><br><span class="line">               currLength = currLength+1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   public boolean isPalindrome(String s, int begin, int end)&#123;</span><br><span class="line">       if(begin&lt;0) return false;</span><br><span class="line">       while(begin&lt;end)&#123;</span><br><span class="line">       	if(s.charAt(begin++)!=s.charAt(end--)) return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先写一个判断是否为回文的辅助函数，然后遍历，判断从当前右指针到前面length+1或者+2长度的字符串是否回文，是的话就更新长度，保存res。最后返回res。</p>
<h3 id="9-Palindrome-Number"><a href="#9-Palindrome-Number" class="headerlink" title="9    Palindrome Number"></a>9    Palindrome Number</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPalindrome(int x) &#123;</span><br><span class="line">       if (x &lt; 0) return false;</span><br><span class="line"></span><br><span class="line">   int p = x; </span><br><span class="line">   int q = 0; </span><br><span class="line">   </span><br><span class="line">   while (p &gt;= 10)&#123;</span><br><span class="line">       q *=10; </span><br><span class="line">       q += p%10; </span><br><span class="line">       p /=10; </span><br><span class="line">   &#125;</span><br><span class="line">   </span><br><span class="line">   return q == x / 10 &amp;&amp; p == x % 10;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>p为x的第一位，q为x的逆序少去个位数。判断他们和原数字是否相等</p>
<h3 id="214-Shortest-Palindrome"><a href="#214-Shortest-Palindrome" class="headerlink" title="214    Shortest Palindrome"></a>214    Shortest Palindrome</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public String shortestPalindrome(String s) &#123;</span><br><span class="line">    String temp = s + &quot;#&quot; + new StringBuilder(s).reverse().toString();</span><br><span class="line">    int[] table = getTable(temp);</span><br><span class="line"></span><br><span class="line">    return new StringBuilder(s.substring(table[table.length - 1])).reverse().toString() + s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int[] getTable(String s)&#123;</span><br><span class="line">    int[] table = new int[s.length()];</span><br><span class="line"></span><br><span class="line">    int index = 0;</span><br><span class="line">    for(int i = 1; i &lt; s.length(); )&#123;</span><br><span class="line">        if(s.charAt(index) == s.charAt(i))&#123;</span><br><span class="line">            table[i] = ++index;</span><br><span class="line">            i++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            if(index &gt; 0)&#123;</span><br><span class="line">                index = table[index-1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                index = 0;</span><br><span class="line">                i ++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return table;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们把s和其转置r连接起来，中间加上一个其他字符，形成一个新的字符串t，我们还需要一个和t长度相同的一位数组 table，其中 table[i] 表示从 t[i] 到开头的子串的相同前缀后缀的个数，具体可参考 KMP 算法中解释。最后我们把不相同的个数对应的字符串添加到s之前即可。</p>
<h3 id="336-Palindrome-Pairs"><a href="#336-Palindrome-Pairs" class="headerlink" title="336    Palindrome Pairs"></a>336    Palindrome Pairs</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">class TrieNode &#123;</span><br><span class="line">    TrieNode[] next;</span><br><span class="line">    int index;</span><br><span class="line">    List&lt;Integer&gt; list;</span><br><span class="line">    	</span><br><span class="line">    TrieNode() &#123;</span><br><span class="line">    	next = new TrieNode[26];</span><br><span class="line">    	index = -1;</span><br><span class="line">    	list = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">public List&lt;List&lt;Integer&gt;&gt; palindromePairs(String[] words) &#123;</span><br><span class="line">    List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    TrieNode root = new TrieNode();</span><br><span class="line">    for (int i = 0; i &lt; words.length; i++) addWord(root, words[i], i);</span><br><span class="line">    for (int i = 0; i &lt; words.length; i++) search(words, i, root, res);</span><br><span class="line">    </span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private void addWord(TrieNode root, String word, int index) &#123;</span><br><span class="line">    for (int i = word.length() - 1; i &gt;= 0; i--) &#123;</span><br><span class="line">        int j = word.charAt(i) - &apos;a&apos;;</span><br><span class="line">    	if (root.next[j] == null) root.next[j] = new TrieNode();</span><br><span class="line">    	if (isPalindrome(word, 0, i)) root.list.add(index);</span><br><span class="line">    	root = root.next[j];</span><br><span class="line">    &#125;</span><br><span class="line">    	</span><br><span class="line">    root.list.add(index);</span><br><span class="line">    root.index = index;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private void search(String[] words, int i, TrieNode root, List&lt;List&lt;Integer&gt;&gt; res) &#123;</span><br><span class="line">    for (int j = 0; j &lt; words[i].length(); j++) &#123;	</span><br><span class="line">    	if (root.index &gt;= 0 &amp;&amp; root.index != i &amp;&amp; isPalindrome(words[i], j, words[i].length() - 1)) &#123;</span><br><span class="line">    	    res.add(Arrays.asList(i, root.index));</span><br><span class="line">    	&#125;</span><br><span class="line">    		</span><br><span class="line">    	root = root.next[words[i].charAt(j) - &apos;a&apos;];</span><br><span class="line">      	if (root == null) return;</span><br><span class="line">    &#125;</span><br><span class="line">    	</span><br><span class="line">    for (int j : root.list) &#123;</span><br><span class="line">    	if (i == j) continue;</span><br><span class="line">    	res.add(Arrays.asList(i, j));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">private boolean isPalindrome(String word, int i, int j) &#123;</span><br><span class="line">    while (i &lt; j) &#123;</span><br><span class="line">    	if (word.charAt(i++) != word.charAt(j--)) return false;</span><br><span class="line">    &#125;</span><br><span class="line">    	</span><br><span class="line">    return true;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用Trie来保存字符串。构建Trie树，将每个word和每步是否是回文的结果保存进去，随后再遍历查找，如果是从j到最后的回文串则加入该键值对到res，最后把list中本来就是回文的也加入res。</p>
]]></content>
      
        
        <tags>
            
            <tag> leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 17]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/07/19/Everyday-Leetcode-17/</url>
      <content type="html"><![CDATA[<h3 id="3-Longest-Substring-Without-Repeating-Characters"><a href="#3-Longest-Substring-Without-Repeating-Characters" class="headerlink" title="3    Longest Substring Without Repeating Characters"></a>3    Longest Substring Without Repeating Characters</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLongestSubstring(String s) &#123;</span><br><span class="line">        if (s.length()==0) return 0;</span><br><span class="line">       HashMap&lt;Character, Integer&gt; map = new HashMap&lt;Character, Integer&gt;();</span><br><span class="line">       int max=0;</span><br><span class="line">       for (int i=0, j=0; i&lt;s.length(); ++i)&#123;</span><br><span class="line">           if (map.containsKey(s.charAt(i)))&#123;</span><br><span class="line">               j = Math.max(j,map.get(s.charAt(i))+1);</span><br><span class="line">           &#125;</span><br><span class="line">           map.put(s.charAt(i),i);</span><br><span class="line">           max = Math.max(max,i-j+1);</span><br><span class="line">       &#125;</span><br><span class="line">       return max;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>构建字符串的hashmap，字符是key，位置是value。然后遍历，构建一个sliding window， j是左指针，i是右指针，如果出现过该字符，则更新hashmap，否则直接加入。<br><a id="more"></a></p>
<h3 id="340-Longest-Substring-with-At-Most-K-Distinct-Characters"><a href="#340-Longest-Substring-with-At-Most-K-Distinct-Characters" class="headerlink" title="340    Longest Substring with At Most K Distinct Characters"></a>340    Longest Substring with At Most K Distinct Characters</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLongestSubstringTwoDistinct(string s) &#123;</span><br><span class="line">        int res = 0, left = 0;</span><br><span class="line">        unordered_map&lt;char, int&gt; m;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            ++m[s[i]];</span><br><span class="line">            while (m.size() &gt; k) &#123;</span><br><span class="line">                if (--m[s[left]] == 0) m.erase(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, i - left + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同下题159，把2改成k</p>
<h3 id="395-Longest-Substring-with-At-Least-K-Repeating-Characters"><a href="#395-Longest-Substring-with-At-Least-K-Repeating-Characters" class="headerlink" title="395    Longest Substring with At Least K Repeating Characters"></a>395    Longest Substring with At Least K Repeating Characters</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int longestSubstring(String s, int k) &#123;</span><br><span class="line">      if (s == null || s.length() == 0) return 0;</span><br><span class="line">      char[] chars = new char[26];</span><br><span class="line">      // record the frequency of each character</span><br><span class="line">      for (int i = 0; i &lt; s.length(); i += 1) chars[s.charAt(i) - &apos;a&apos;] += 1;</span><br><span class="line">      boolean flag = true;</span><br><span class="line">      for (int i = 0; i &lt; chars.length; i += 1) &#123;</span><br><span class="line">          if (chars[i] &lt; k &amp;&amp; chars[i] &gt; 0) flag = false;</span><br><span class="line">      &#125;</span><br><span class="line">      // return the length of string if this string is a valid string</span><br><span class="line">      if (flag == true) return s.length();</span><br><span class="line">      int result = 0;</span><br><span class="line">      int start = 0, cur = 0;</span><br><span class="line">      // otherwise we use all the infrequent elements as splits</span><br><span class="line">      while (cur &lt; s.length()) &#123;</span><br><span class="line">          if (chars[s.charAt(cur) - &apos;a&apos;] &lt; k) &#123;</span><br><span class="line">              result = Math.max(result, longestSubstring(s.substring(start, cur), k));</span><br><span class="line">              start = cur + 1;</span><br><span class="line">          &#125;</span><br><span class="line">          cur++;</span><br><span class="line">      &#125;</span><br><span class="line">      result = Math.max(result, longestSubstring(s.substring(start), k));</span><br><span class="line">      return result;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>递归做法，记录字符串中每个字符的出现次数，如果已经是valid string就返回，否则便遍历所有splits，在循环中递归调用自身（start到cur）。内层循环结束后，最后再递归调用自身（start到最后）。</p>
<h3 id="159-Longest-Substring-with-At-Most-Two-Distinct-Characters"><a href="#159-Longest-Substring-with-At-Most-Two-Distinct-Characters" class="headerlink" title="159    Longest Substring with At Most Two Distinct Characters"></a>159    Longest Substring with At Most Two Distinct Characters</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">int lengthOfLongestSubstringTwoDistinct(string s) &#123;</span><br><span class="line">        int res = 0, left = 0;</span><br><span class="line">        unordered_map&lt;char, int&gt; m;</span><br><span class="line">        for (int i = 0; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            ++m[s[i]];</span><br><span class="line">            while (m.size() &gt; 2) &#123;</span><br><span class="line">                if (--m[s[left]] == 0) m.erase(s[left]);</span><br><span class="line">                ++left;</span><br><span class="line">            &#125;</span><br><span class="line">            res = max(res, i - left + 1);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>HashMap 记录每个字符的出现次数，然后如果 HashMap 中的映射数量超过两个的时候，我们需要删掉一个映射，然后我们更新结果为 i - left + 1。</p>
<h3 id="125-Valid-Palindrome"><a href="#125-Valid-Palindrome" class="headerlink" title="125    Valid Palindrome"></a>125    Valid Palindrome</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean isPalindrome(String s) &#123;</span><br><span class="line">   char[] c = s.toCharArray();</span><br><span class="line">       for (int i = 0, j = c.length - 1; i &lt; j; ) &#123;</span><br><span class="line">           if (!Character.isLetterOrDigit(c[i])) i++;</span><br><span class="line">           else if (!Character.isLetterOrDigit(c[j])) j--;</span><br><span class="line">           else if (Character.toLowerCase(c[i++]) != Character.toLowerCase(c[j--])) </span><br><span class="line">               return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先转换成char[]，然后如果不是letter就移动左右两个指针，随后比较tolowercase后的两个字符，如果有不一样就返回false，如果遍历完没有说明是palindrome，返回true。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 16]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/26/Everyday-Leetcode-16/</url>
      <content type="html"><![CDATA[<h3 id="65-Valid-Number"><a href="#65-Valid-Number" class="headerlink" title="65    Valid Number"></a>65    Valid Number</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public boolean isNumber(String s) &#123;</span><br><span class="line">        s = s.trim();</span><br><span class="line">       boolean pointSeen = false;</span><br><span class="line">       boolean eSeen = false;</span><br><span class="line">       boolean numberSeen = false;</span><br><span class="line">       for(int i=0; i&lt;s.length(); i++) &#123;</span><br><span class="line">           if(&apos;0&apos; &lt;= s.charAt(i) &amp;&amp; s.charAt(i) &lt;= &apos;9&apos;) &#123;</span><br><span class="line">               numberSeen = true;</span><br><span class="line">           &#125; else if(s.charAt(i) == &apos;.&apos;) &#123;</span><br><span class="line">               if(eSeen || pointSeen)</span><br><span class="line">                   return false;</span><br><span class="line">               pointSeen = true;</span><br><span class="line">           &#125; else if(s.charAt(i) == &apos;e&apos;) &#123;</span><br><span class="line">               if(eSeen || !numberSeen)</span><br><span class="line">                   return false;</span><br><span class="line">               numberSeen = false;</span><br><span class="line">               eSeen = true;</span><br><span class="line">           &#125; else if(s.charAt(i) == &apos;-&apos; || s.charAt(i) == &apos;+&apos;) &#123;</span><br><span class="line">               if(i != 0 &amp;&amp; s.charAt(i-1) != &apos;e&apos;)</span><br><span class="line">                   return false;</span><br><span class="line">           &#125; else</span><br><span class="line">               return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return numberSeen;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>如上所示。</p>
<h3 id="157-Read-N-Characters-Given-Read4"><a href="#157-Read-N-Characters-Given-Read4" class="headerlink" title="157    Read N Characters Given Read4"></a>157    Read N Characters Given Read4</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">int read(char *buf, int n) &#123;</span><br><span class="line">        int t = read4(buf);</span><br><span class="line">        if (t &gt;= n) return n;</span><br><span class="line">        if (t &lt; 4) return t;</span><br><span class="line">        return 4 + read(&amp;buf[4], n - 4);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>递归解法，如果返回值t大于等于n，说明此时n不大于4，直接返回n即可，如果此返回值t小于4，直接返回t即可，如果都不是，则直接返回调用递归函数加上4，其中递归函数的buf应往后推4个字符，此时n变成n-4即可。</p>
<h3 id="158-Read-N-Characters-Given-Read4-II-Call-multiple-times"><a href="#158-Read-N-Characters-Given-Read4-II-Call-multiple-times" class="headerlink" title="158    Read N Characters Given Read4 II - Call multiple times"></a>158    Read N Characters Given Read4 II - Call multiple times</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> public class Solution extends Reader4 &#123;</span><br><span class="line">    char[] buffer = new char[4];</span><br><span class="line">    int readPos = 0;</span><br><span class="line">    int writePos = 0;</span><br><span class="line">    public int read(char[] buf, int n) &#123;</span><br><span class="line">        int idx = 0;</span><br><span class="line">        while (idx &lt; n) &#123;</span><br><span class="line">            if (readPos == 0) &#123;</span><br><span class="line">                writePos = read4(buffer);</span><br><span class="line">            &#125;</span><br><span class="line">            while (readPos &lt; writePos &amp;&amp; idx &lt; n) &#123;</span><br><span class="line">                buf[idx++] = buffer[readPos++];</span><br><span class="line">            &#125;</span><br><span class="line">            if (readPos == writePos) &#123;</span><br><span class="line">                readPos = 0;</span><br><span class="line">            &#125;</span><br><span class="line">            if (idx == n || writePos &lt; 4) &#123;</span><br><span class="line">                break;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return idx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>比如file(“abcdefg”)，然后要求的是[read(1), read(2), read(2), read(1)]。</p>
<ol>
<li>调用read(1)后，此时buff为空，调用一个read4，buff中存储了“abcd”，writePos = 4，然后从buff中读出1个字符到buf，那么就是第一个字符[“a”]，此时readPos = 1。</li>
<li>调用read(2)，此时readPos = 1 &lt; writePos = 4，所以先从buf中读取2个字符，也就是[“bc”]，此时readPos = 3。</li>
<li>然后read(2)，此时readPos = 3 &lt; readPos = 4，所以继续从buff中读取，但是buffer中只剩下一个字符了，所以先把它读到buf中，[“d”]，然后readPos == writePos了，所以readPos重置为0，继续循环。此时readPos = 0，我们调用一个read4填充buff，buff中为”efg”，然后我们可以继续读取一个字符到buf中，也就是这次最终读取的结果为[“de”]。</li>
<li>最后一次是调用read(1)，则是把buff中的1个字符复制到buf中，得到[“f”]</li>
</ol>
<h3 id="76-Minimum-Window-Substring"><a href="#76-Minimum-Window-Substring" class="headerlink" title="76    Minimum Window Substring"></a>76    Minimum Window Substring</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public String minWindow(String s, String t) &#123;</span><br><span class="line">   int [] map = new int[128];</span><br><span class="line">   for (char c : t.toCharArray()) &#123;</span><br><span class="line">     map[c]++;</span><br><span class="line">   &#125;</span><br><span class="line">   int start = 0, end = 0, minStart = 0, minLen = Integer.MAX_VALUE, counter = t.length();</span><br><span class="line">   while (end &lt; s.length()) &#123;</span><br><span class="line">     final char c1 = s.charAt(end);</span><br><span class="line">     if (map[c1] &gt; 0) counter--;</span><br><span class="line">     map[c1]--;</span><br><span class="line">     end++;</span><br><span class="line">     while (counter == 0) &#123;</span><br><span class="line">       if (minLen &gt; end - start) &#123;</span><br><span class="line">         minLen = end - start;</span><br><span class="line">         minStart = start;</span><br><span class="line">       &#125;</span><br><span class="line">       final char c2 = s.charAt(start);</span><br><span class="line">       map[c2]++;</span><br><span class="line">       if (map[c2] &gt; 0) counter++;</span><br><span class="line">       start++;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   return minLen == Integer.MAX_VALUE ? &quot;&quot; : s.substring(minStart, minStart + minLen);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>使用两个指针+map，如果命中counter-1，当counter==-时说明找到包含substring的window，于是在window内找满足条件的最小window，最后返回最小的window。</p>
<h3 id="30-Substring-with-Concatenation-of-All-Words"><a href="#30-Substring-with-Concatenation-of-All-Words" class="headerlink" title="30    Substring with Concatenation of All Words"></a>30    Substring with Concatenation of All Words</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public static List&lt;Integer&gt; findSubstring(String S, String[] L) &#123;</span><br><span class="line">    List&lt;Integer&gt; res = new ArrayList&lt;Integer&gt;();</span><br><span class="line">    if (S == null || L == null || L.length == 0) return res;</span><br><span class="line">    int len = L[0].length(); // length of each word</span><br><span class="line">    </span><br><span class="line">    Map&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); // map for L</span><br><span class="line">    for (String w : L) map.put(w, map.containsKey(w) ? map.get(w) + 1 : 1);</span><br><span class="line">    </span><br><span class="line">    for (int i = 0; i &lt;= S.length() - len * L.length; i++) &#123;</span><br><span class="line">        Map&lt;String, Integer&gt; copy = new HashMap&lt;String, Integer&gt;(map);</span><br><span class="line">        for (int j = 0; j &lt; L.length; j++) &#123; // checkc if match</span><br><span class="line">            String str = S.substring(i + j*len, i + j*len + len); // next word</span><br><span class="line">            if (copy.containsKey(str)) &#123; // is in remaining words</span><br><span class="line">                int count = copy.get(str);</span><br><span class="line">                if (count == 1) copy.remove(str);</span><br><span class="line">                else copy.put(str, count - 1);</span><br><span class="line">                if (copy.isEmpty()) &#123; // matches</span><br><span class="line">                    res.add(i);</span><br><span class="line">                    break;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; else break; // not in L</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先构建map，然后遍历查找是否match</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 15]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/18/Everyday-Leetcode-15/</url>
      <content type="html"><![CDATA[<h3 id="12-Integer-to-Roman"><a href="#12-Integer-to-Roman" class="headerlink" title="12    Integer to Roman"></a>12    Integer to Roman</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public String intToRoman(int num) &#123;</span><br><span class="line">       int[] values = &#123;1000,900,500,400,100,90,50,40,10,9,5,4,1&#125;;</span><br><span class="line">   String[] strs = &#123;&quot;M&quot;,&quot;CM&quot;,&quot;D&quot;,&quot;CD&quot;,&quot;C&quot;,&quot;XC&quot;,&quot;L&quot;,&quot;XL&quot;,&quot;X&quot;,&quot;IX&quot;,&quot;V&quot;,&quot;IV&quot;,&quot;I&quot;&#125;;</span><br><span class="line">   </span><br><span class="line">   StringBuilder sb = new StringBuilder();</span><br><span class="line">   </span><br><span class="line">   for(int i=0;i&lt;values.length;i++) &#123;</span><br><span class="line">       while(num &gt;= values[i]) &#123;</span><br><span class="line">           num -= values[i];</span><br><span class="line">           sb.append(strs[i]);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从高到低判断是否符合罗马数字大小，符合则减去一该数字并加入字符到结果。</p>
<h3 id="273-Integer-to-English-Words"><a href="#273-Integer-to-English-Words" class="headerlink" title="273    Integer to English Words"></a>273    Integer to English Words</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private final String[] belowTen = new String[] &#123;&quot;&quot;, &quot;One&quot;, &quot;Two&quot;, &quot;Three&quot;, &quot;Four&quot;, &quot;Five&quot;, &quot;Six&quot;, &quot;Seven&quot;, &quot;Eight&quot;, &quot;Nine&quot;&#125;;</span><br><span class="line">    private final String[] belowTwenty = new String[] &#123;&quot;Ten&quot;, &quot;Eleven&quot;, &quot;Twelve&quot;, &quot;Thirteen&quot;, &quot;Fourteen&quot;, &quot;Fifteen&quot;, &quot;Sixteen&quot;, &quot;Seventeen&quot;, &quot;Eighteen&quot;, &quot;Nineteen&quot;&#125;;</span><br><span class="line">    private final String[] belowHundred = new String[] &#123;&quot;&quot;, &quot;Ten&quot;, &quot;Twenty&quot;, &quot;Thirty&quot;, &quot;Forty&quot;, &quot;Fifty&quot;, &quot;Sixty&quot;, &quot;Seventy&quot;, &quot;Eighty&quot;, &quot;Ninety&quot;&#125;;</span><br><span class="line">    </span><br><span class="line">    public String numberToWords(int num) &#123;</span><br><span class="line">        if (num == 0) return &quot;Zero&quot;;</span><br><span class="line">        return helper(num); </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    private String helper(int num) &#123;</span><br><span class="line">        String result = new String();</span><br><span class="line">        if (num &lt; 10) result = belowTen[num];</span><br><span class="line">        else if (num &lt; 20) result = belowTwenty[num -10];</span><br><span class="line">        else if (num &lt; 100) result = belowHundred[num/10] + &quot; &quot; + helper(num % 10);</span><br><span class="line">        else if (num &lt; 1000) result = helper(num/100) + &quot; Hundred &quot; +  helper(num % 100);</span><br><span class="line">        else if (num &lt; 1000000) result = helper(num/1000) + &quot; Thousand &quot; +  helper(num % 1000);</span><br><span class="line">        else if (num &lt; 1000000000) result = helper(num/1000000) + &quot; Million &quot; +  helper(num % 1000000);</span><br><span class="line">        else result = helper(num/1000000000) + &quot; Billion &quot; + helper(num % 1000000000);</span><br><span class="line">        return result.trim();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>构建单词表（记得开头有“”)，然后根据大小else if，记得可以递归调用自身。</p>
<h3 id="246-Strobogrammatic-Number"><a href="#246-Strobogrammatic-Number" class="headerlink" title="246    Strobogrammatic Number"></a>246    Strobogrammatic Number</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">bool isStrobogrammatic(string num) &#123;</span><br><span class="line">       unordered_map&lt;char, char&gt; m &#123;&#123;&apos;0&apos;, &apos;0&apos;&#125;, &#123;&apos;1&apos;, &apos;1&apos;&#125;, &#123;&apos;8&apos;, &apos;8&apos;&#125;, &#123;&apos;6&apos;, &apos;9&apos;&#125;, &#123;&apos;9&apos;, &apos;6&apos;&#125;&#125;;</span><br><span class="line">       for (int i = 0; i &lt;= num.size() / 2; ++i) &#123;</span><br><span class="line">           if (m[num[i]] != num[num.size() - i - 1]) return false;</span><br><span class="line">       &#125;</span><br><span class="line">       return true;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果对应两个位置不满足对称要求，返回false。</p>
<h3 id="247-Strobogrammatic-Number-II"><a href="#247-Strobogrammatic-Number-II" class="headerlink" title="247    Strobogrammatic Number II"></a>247    Strobogrammatic Number II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; findStrobogrammatic(int n) &#123;</span><br><span class="line">      return find(n, n);</span><br><span class="line">  &#125;</span><br><span class="line">  vector&lt;string&gt; find(int m, int n) &#123;</span><br><span class="line">      if (m == 0) return &#123;&quot;&quot;&#125;;</span><br><span class="line">      if (m == 1) return &#123;&quot;0&quot;, &quot;1&quot;, &quot;8&quot;&#125;;</span><br><span class="line">      vector&lt;string&gt; t = find(m - 2, n), res;</span><br><span class="line">      for (auto a : t) &#123;</span><br><span class="line">          if (m != n) res.push_back(&quot;0&quot; + a + &quot;0&quot;);</span><br><span class="line">          res.push_back(&quot;1&quot; + a + &quot;1&quot;);</span><br><span class="line">          res.push_back(&quot;6&quot; + a + &quot;9&quot;);</span><br><span class="line">          res.push_back(&quot;8&quot; + a + &quot;8&quot;);</span><br><span class="line">          res.push_back(&quot;9&quot; + a + &quot;6&quot;);</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>从m=0层开始，一层一层往上加的，需要注意的是当加到了n层的时候，左右两边不能加[0 0]。</p>
<h3 id="68-Text-Justification"><a href="#68-Text-Justification" class="headerlink" title="68    Text Justification"></a>68    Text Justification</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; fullJustify(String[] words, int maxWidth) &#123;</span><br><span class="line">      List&lt;String&gt; res = new ArrayList&lt;&gt;();</span><br><span class="line">      int i=0;</span><br><span class="line">      while (i&lt;words.length)&#123;</span><br><span class="line">          int width=0, I=i;</span><br><span class="line">          while (I&lt;words.length &amp;&amp; width+words[I].length()+(I-i)&lt;=maxWidth)</span><br><span class="line">              width+=words[I++].length();</span><br><span class="line">          int space=1, extra=0;</span><br><span class="line">          if (I-i!=1 &amp;&amp; I!=words.length)&#123;</span><br><span class="line">              space=(maxWidth-width)/(I-i-1);</span><br><span class="line">              extra=(maxWidth-width)%(I-i-1);</span><br><span class="line">          &#125;</span><br><span class="line">          StringBuilder line= new StringBuilder(words[i++]);</span><br><span class="line">          while (i&lt;I)&#123;</span><br><span class="line">              for (int s= space; s&gt;0; s--) line.append(&quot; &quot;);</span><br><span class="line">              if (extra--&gt;0) line.append(&quot; &quot;);</span><br><span class="line">              line.append(words[i++]);</span><br><span class="line">          &#125;</span><br><span class="line">          for (int s= maxWidth-line.length(); s&gt;0; s--) line.append(&quot; &quot;);</span><br><span class="line">          res.add(line.toString());</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>当width小于maxwidth时，加word到改行，然后再后面补空格如果空格数不是2的倍数，那么左边的空间里要比右边的空间里多加入一个空格，那么我们只需要用总的空格数除以空间个数。能除尽最好，说明能平均分配，除不尽的话就多加个空格放在左边的空间里。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 14]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/17/Everyday-Leetcode-14/</url>
      <content type="html"><![CDATA[<h3 id="316-Remove-Duplicate-Letters"><a href="#316-Remove-Duplicate-Letters" class="headerlink" title="316    Remove Duplicate Letters"></a>316    Remove Duplicate Letters</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public String removeDuplicateLetters(String sr) &#123;   </span><br><span class="line">        int[] res = new int[26]; </span><br><span class="line">   boolean[] visited = new boolean[26]; </span><br><span class="line">   char[] ch = sr.toCharArray();</span><br><span class="line">   for(char c: ch)&#123;  </span><br><span class="line">       res[c-&apos;a&apos;]++;</span><br><span class="line">   &#125;</span><br><span class="line">   Stack&lt;Character&gt; st = new Stack&lt;&gt;();</span><br><span class="line">   int index;</span><br><span class="line">   for(char s:ch)&#123; </span><br><span class="line">       index= s-&apos;a&apos;;</span><br><span class="line">       res[index]--;   </span><br><span class="line">       if(visited[index]) </span><br><span class="line">           continue;</span><br><span class="line">       while(!st.isEmpty() &amp;&amp; s&lt;st.peek() &amp;&amp; res[st.peek()-&apos;a&apos;]!=0)&#123; </span><br><span class="line">           visited[st.pop()-&apos;a&apos;]=false;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       st.push(s); </span><br><span class="line">       visited[index]=true;</span><br><span class="line">   &#125;</span><br><span class="line">   StringBuilder sb = new StringBuilder();</span><br><span class="line">   while(!st.isEmpty())&#123;</span><br><span class="line">       sb.insert(0,st.pop());</span><br><span class="line">   &#125;</span><br><span class="line">   return sb.toString();</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<a id="more"></a>
<p>首先用char数组记录字符出现次数，然后遍历，如果该数字已经出现在序列中，continue不管它，如果比当前栈顶小，而且栈顶字符次数不为0，还会在后面出现，就弹出并置为false未出现，将当前字符压入栈中。最后按照栈的次序pop输出。</p>
<h3 id="271-Encode-and-Decode-Strings"><a href="#271-Encode-and-Decode-Strings" class="headerlink" title="271    Encode and Decode Strings"></a>271    Encode and Decode Strings</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// Encodes a list of strings to a single string.</span><br><span class="line">    string encode(vector&lt;string&gt;&amp; strs) &#123;</span><br><span class="line">        string res = &quot;&quot;;</span><br><span class="line">        for (string str : strs) res += str + &apos;\0&apos;;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    // Decodes a single string to a list of strings.</span><br><span class="line">    vector&lt;string&gt; decode(string s) &#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        stringstream ss(s);</span><br><span class="line">        string t;</span><br><span class="line">        while (getline(ss, t, &apos;\0&apos;)) &#123;</span><br><span class="line">            res.push_back(t);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在每个字符串的后面加上换行字符’\0’，其还属于一个字符串，这样我们在解码的时候，只要去查找这个换行字符就可以了。</p>
<h3 id="168-Excel-Sheet-Column-Title"><a href="#168-Excel-Sheet-Column-Title" class="headerlink" title="168    Excel Sheet Column Title"></a>168    Excel Sheet Column Title</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public String convertToTitle(int n) &#123;</span><br><span class="line">      StringBuilder sb= new StringBuilder();</span><br><span class="line">      </span><br><span class="line"></span><br><span class="line">        while(n&gt;0)&#123;</span><br><span class="line">            n--;</span><br><span class="line">            sb.insert(0, (char)(&apos;A&apos; + n % 26));</span><br><span class="line">            n /= 26;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>相当于转换成26进制。</p>
<h3 id="171-Excel-Sheet-Column-Number"><a href="#171-Excel-Sheet-Column-Number" class="headerlink" title="171    Excel Sheet Column Number"></a>171    Excel Sheet Column Number</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int titleToNumber(String s) &#123;</span><br><span class="line">       </span><br><span class="line">     char[] ch = s.toCharArray();</span><br><span class="line">       int res=0;</span><br><span class="line">      for(int i=s.length()-1;i&gt;=0;i--)&#123;</span><br><span class="line">          int sq=s.length()-1-i;</span><br><span class="line">          int q=1;</span><br><span class="line">          while(sq&gt;0)&#123;</span><br><span class="line">              q*=26;</span><br><span class="line">              sq--;</span><br><span class="line">          &#125;</span><br><span class="line">       res+=(int)(ch[i]-&apos;A&apos;+1)*q;</span><br><span class="line">        &#125;</span><br><span class="line">       return res;</span><br><span class="line">   </span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>同上，反过来做。</p>
<h3 id="13-Roman-to-Integer"><a href="#13-Roman-to-Integer" class="headerlink" title="13    Roman to Integer"></a>13    Roman to Integer</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public int romanToInt(String s) &#123;</span><br><span class="line">       </span><br><span class="line">        int[] map = new int[256];</span><br><span class="line">        map[&apos;I&apos;] = 1; map[&apos;V&apos;] = 5; map[&apos;X&apos;] = 10; map[&apos;L&apos;] = 50; map[&apos;C&apos;] = 100; map[&apos;D&apos;] = 500; map[&apos;M&apos;] = 1000;</span><br><span class="line">        </span><br><span class="line">        int ret = 0, pre = 1;</span><br><span class="line">        for (int i = s.length()-1; i &gt;= 0; --i) &#123;</span><br><span class="line">            int cur = map[s.charAt(i)];</span><br><span class="line">            if (cur &lt; pre) ret -= cur;</span><br><span class="line">            else &#123;</span><br><span class="line">                pre = cur;</span><br><span class="line">                ret += cur;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ret;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>罗马数字的规则，如果小得放前面说明要减去前面这个。否则直接累加。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 13]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/15/Everyday-Leetcode-13/</url>
      <content type="html"><![CDATA[<h3 id="249-Group-Shifted-Strings"><a href="#249-Group-Shifted-Strings" class="headerlink" title="249    Group Shifted Strings"></a>249    Group Shifted Strings</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;vector&lt;string&gt;&gt; groupStrings(vector&lt;string&gt;&amp; strings) &#123;</span><br><span class="line">        vector&lt;vector&lt;string&gt; &gt; res;</span><br><span class="line">        unordered_map&lt;string, multiset&lt;string&gt;&gt; m;</span><br><span class="line">        for (auto a : strings) &#123;</span><br><span class="line">            string t = &quot;&quot;;</span><br><span class="line">            for (char c : a) &#123;</span><br><span class="line">                t += to_string((c + 26 - a[0]) % 26) + &quot;,&quot;;</span><br><span class="line">            &#125;</span><br><span class="line">            m[t].insert(a);</span><br><span class="line">        &#125;</span><br><span class="line">        for (auto it = m.begin(); it != m.end(); ++it) &#123;</span><br><span class="line">            res.push_back(vector&lt;string&gt;(it-&gt;second.begin(), it-&gt;second.end()));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>所有互为偏移的字符串都有个unique的距离差，我们根据这个来建立映射就可以很好的进行单词分组了。<br><a id="more"></a></p>
<h3 id="87-Scramble-String"><a href="#87-Scramble-String" class="headerlink" title="87    Scramble String"></a>87    Scramble String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public boolean isScramble(String s1, String s2) &#123;</span><br><span class="line">       </span><br><span class="line">        if (s1.equals(s2)) return true; </span><br><span class="line">        </span><br><span class="line">        int[] letters = new int[26];</span><br><span class="line">        for (int i=0; i&lt;s1.length(); i++) &#123;</span><br><span class="line">            letters[s1.charAt(i)-&apos;a&apos;]++;</span><br><span class="line">            letters[s2.charAt(i)-&apos;a&apos;]--;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i=0; i&lt;26; i++) if (letters[i]!=0) return false;</span><br><span class="line">    </span><br><span class="line">        for (int i=1; i&lt;s1.length(); i++) &#123;</span><br><span class="line">            if (isScramble(s1.substring(0,i), s2.substring(0,i)) </span><br><span class="line">             &amp;&amp; isScramble(s1.substring(i), s2.substring(i))) return true;</span><br><span class="line">            if (isScramble(s1.substring(0,i), s2.substring(s2.length()-i)) </span><br><span class="line">             &amp;&amp; isScramble(s1.substring(i), s2.substring(0,s2.length()-i))) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先判断是否直接相等，再判断所含字母是否相等。然后遍历，递归调用直到输出结果。要么分解到单词包含的字母都一样，要么分解到两头单词对和中间单词对相同，说明可以翻转。</p>
<h3 id="161-One-Edit-Distance"><a href="#161-One-Edit-Distance" class="headerlink" title="161    One Edit Distance"></a>161    One Edit Distance</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">bool isOneEditDistance(string s, string t) &#123;</span><br><span class="line">    for (int i = 0; i &lt; min(s.size(), t.size()); ++i) &#123;</span><br><span class="line">        if (s[i] != t[i]) &#123;</span><br><span class="line">            if (s.size() == t.size()) return s.substr(i + 1) == t.substr(i + 1);</span><br><span class="line">            else if (s.size() &lt; t.size()) return s.substr(i) == t.substr(i + 1);</span><br><span class="line">            else return s.substr(i + 1) == t.substr(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return abs((int)s.size() - (int)t.size()) == 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>对比两个字符串对应位置上的字符，如果遇到不同的时候，这时我们看两个字符串的长度关系，如果相等，那么我们比较当前位置后的字串是否相同，如果s的长度大，那么我们比较s的下一个位置开始的子串，和t的当前位置开始的子串是否相同，反之如果t的长度大，那么我们比较t的下一个位置开始的子串，和s的当前位置开始的子串是否相同。如果循环结束，都没有找到不同的字符，那么此时我们看两个字符串的长度是否相差1</p>
<h3 id="38-Count-and-Say"><a href="#38-Count-and-Say" class="headerlink" title="38    Count and Say"></a>38    Count and Say</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">public String countAndSay(int n) &#123;</span><br><span class="line">        if(n==1)</span><br><span class="line">            return &quot;1&quot;;</span><br><span class="line"></span><br><span class="line">        StringBuilder sb=new StringBuilder();</span><br><span class="line"></span><br><span class="line">        </span><br><span class="line">        String str=countAndSay(n-1);</span><br><span class="line">       </span><br><span class="line">        </span><br><span class="line">        char c=&apos;0&apos;;</span><br><span class="line">        int count=0;</span><br><span class="line">        for (int i=0;i&lt;str.length();i++)&#123;</span><br><span class="line">            c=str.charAt(i);</span><br><span class="line">            count=1;</span><br><span class="line">            while ((i+1)&lt;str.length()&amp;&amp;str.charAt(i+1)==c)&#123;</span><br><span class="line">                count++;</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            sb.append(count+&quot;&quot;+c);</span><br><span class="line">        &#125;</span><br><span class="line">        return sb.toString();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>递归返回前一行的结果。每次while来count相同字符的数量，然后加入到stringbuilder中。</p>
<h3 id="358-Rearrange-String-k-Distance-Apart"><a href="#358-Rearrange-String-k-Distance-Apart" class="headerlink" title="358    Rearrange String k Distance Apart"></a>358    Rearrange String k Distance Apart</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">string rearrangeString(string str, int k) &#123;</span><br><span class="line">        if (k == 0) return str;</span><br><span class="line">        string res;</span><br><span class="line">        int len = (int)str.size();</span><br><span class="line">        unordered_map&lt;char, int&gt; m;</span><br><span class="line">        priority_queue&lt;pair&lt;int, char&gt;&gt; q;</span><br><span class="line">        for (auto a : str) ++m[a];</span><br><span class="line">        for (auto it = m.begin(); it != m.end(); ++it) &#123;</span><br><span class="line">            q.push(&#123;it-&gt;second, it-&gt;first&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        while (!q.empty()) &#123;</span><br><span class="line">            vector&lt;pair&lt;int, int&gt;&gt; v;</span><br><span class="line">            int cnt = min(k, len);</span><br><span class="line">            for (int i = 0; i &lt; cnt; ++i) &#123;</span><br><span class="line">                if (q.empty()) return &quot;&quot;;</span><br><span class="line">                auto t = q.top(); q.pop();</span><br><span class="line">                res.push_back(t.second);</span><br><span class="line">                if (--t.first &gt; 0) v.push_back(t);</span><br><span class="line">                --len;</span><br><span class="line">            &#125;</span><br><span class="line">            for (auto a : v) q.push(a);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>我们需要一个哈希表来建立字符和其出现次数之间的映射，然后需要一个堆来保存这每一堆映射，按照出现次数来排序。然后如果堆不为空我们就开始循环，我们找出k和str长度之间的较小值，然后从0遍历到这个较小值，对于每个遍历到的值，如果此时堆为空了，说明此位置没法填入字符了，返回空字符串，否则我们从堆顶取出一对映射，然后把字母加入结果res中，此时映射的个数减1，如果减1后的个数仍大于0，则我们将此映射加入临时集合v中，同时str的个数len减1，遍历完一次，我们把临时集合中的映射对由加入堆中。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 12]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/14/Everyday-Leetcode-12/</url>
      <content type="html"><![CDATA[<h3 id="293-Flip-Game"><a href="#293-Flip-Game" class="headerlink" title="293    Flip Game"></a>293    Flip Game</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public generatePossibleNextMoves(string s) &#123;</span><br><span class="line"> StringBuilder sb = new StringBuilder();</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt; s.length(); ++i) &#123;</span><br><span class="line">            </span><br><span class="line">            if (s.charAt(i) == &apos;+&apos;&amp;&amp; scharAt(i - 1) == &apos;+&apos;) &#123;</span><br><span class="line">            sb.append(s.substring(0, i - 1) + &quot;--&quot; + s.substrting(i + 1)));</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return sb.toString(); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历 如果i和i-1都是加则加入字符串。<br><a id="more"></a></p>
<h3 id="294-Flip-Game-II"><a href="#294-Flip-Game-II" class="headerlink" title="294    Flip Game II"></a>294    Flip Game II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">bool canWin(string s) &#123;</span><br><span class="line">        for (int i = 1; i &lt; s.size(); ++i) &#123;</span><br><span class="line">            if (s[i] == &apos;+&apos; &amp;&amp; s[i - 1] == &apos;+&apos; &amp;&amp; !canWin(s.substr(0, i - 1) + &quot;--&quot; + s.substr(i + 1))) &#123;</span><br><span class="line">                return true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>递归调用如果将这两个位置变为–的字符串，如果返回false，说明当前玩家可以赢，结束循环返回false。</p>
<h3 id="290-Word-Pattern"><a href="#290-Word-Pattern" class="headerlink" title="290    Word Pattern"></a>290    Word Pattern</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public boolean wordPattern(String pattern, String str) &#123;</span><br><span class="line">    String[] words = str.split(&quot; &quot;);</span><br><span class="line">    if (words.length != pattern.length())</span><br><span class="line">        return false;</span><br><span class="line">    Map index = new HashMap();</span><br><span class="line">    for (Integer i=0; i&lt;words.length; ++i)</span><br><span class="line">        if (index.put(pattern.charAt(i), i) != index.put(words[i], i))</span><br><span class="line">            return false;</span><br><span class="line">    return true;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>构建hashmap，和前面205原理一样。</p>
<h3 id="242-Valid-Anagram"><a href="#242-Valid-Anagram" class="headerlink" title="242    Valid Anagram"></a>242    Valid Anagram</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public boolean isAnagram(String s, String t) &#123;</span><br><span class="line">        </span><br><span class="line">        if (s.length() != t.length()) return false;</span><br><span class="line"></span><br><span class="line">        int n = s.length();</span><br><span class="line">        int[] freq = new int[26];</span><br><span class="line"></span><br><span class="line">       </span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            freq[s.charAt(i) - &apos;a&apos;]++; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">            if (freq[t.charAt(i) - &apos;a&apos;]-- == 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>建立单词表，两个for遍历。</p>
<h3 id="49-Group-Anagrams"><a href="#49-Group-Anagrams" class="headerlink" title="49    Group Anagrams"></a>49    Group Anagrams</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;List&lt;String&gt;&gt; groupAnagrams(String[] strs) &#123;</span><br><span class="line">   if (strs == null || strs.length == 0) return new ArrayList&lt;List&lt;String&gt;&gt;();</span><br><span class="line">       Map&lt;String, List&lt;String&gt;&gt; map = new HashMap&lt;String, List&lt;String&gt;&gt;();</span><br><span class="line">       for (String s : strs) &#123;</span><br><span class="line">           char[] ca = s.toCharArray();</span><br><span class="line">           Arrays.sort(ca);</span><br><span class="line">           String keyStr = String.valueOf(ca);</span><br><span class="line">           if (!map.containsKey(keyStr)) map.put(keyStr, new ArrayList&lt;String&gt;());</span><br><span class="line">           map.get(keyStr).add(s);</span><br><span class="line">       &#125;</span><br><span class="line">       return new ArrayList&lt;List&lt;String&gt;&gt;(map.values());</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>把每个字符串排序，这样得到的keyStr都一样，然后将同个key的字符串add进同一个list。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 11]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/13/Everyday-Leetcode-11/</url>
      <content type="html"><![CDATA[<h3 id="344-Reverse-String"><a href="#344-Reverse-String" class="headerlink" title="344    Reverse String"></a>344    Reverse String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public void reverseString(char[] s) &#123;</span><br><span class="line">   for(int i=0,j=s.length-1;i&lt;j;i++,j--)&#123;</span><br><span class="line">     char temp=s[i];</span><br><span class="line">     s[i]=s[j];</span><br><span class="line">     s[j]=temp;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>头尾遍历并交换。<br><a id="more"></a></p>
<h3 id="151-Reverse-Words-in-a-String"><a href="#151-Reverse-Words-in-a-String" class="headerlink" title="151    Reverse Words in a String"></a>151    Reverse Words in a String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public String reverseWords(String s) &#123;</span><br><span class="line">        StringBuilder sb = new StringBuilder();</span><br><span class="line">        int n = s.length();</span><br><span class="line">        int i = n - 1;</span><br><span class="line">        while(i &gt;= 0) &#123;</span><br><span class="line">            if (s.charAt(i) == &apos; &apos;) &#123;i--; continue; &#125;;</span><br><span class="line">            int j = i - 1;</span><br><span class="line">            while(j &gt;= 0 &amp;&amp; s.charAt(j) != &apos; &apos;) j--;</span><br><span class="line">            sb.append(&quot; &quot;);</span><br><span class="line">            sb.append(s.substring(j + 1, i + 1));</span><br><span class="line">            i = j - 1;</span><br><span class="line">        &#125;</span><br><span class="line">        if (sb.length() &gt; 0) sb.deleteCharAt(0);</span><br><span class="line">        return sb.toString(); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>同样两个指针，都从尾部开始，i遇到不是空格停下，j遇到空格停下，j+1到i+1为词。</p>
<h3 id="186-Reverse-Words-in-a-String-II"><a href="#186-Reverse-Words-in-a-String-II" class="headerlink" title="186    Reverse Words in a String II"></a>186    Reverse Words in a String II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">同上</span><br></pre></td></tr></table></figure>
<p>同上。</p>
<h3 id="345-Reverse-Vowels-of-a-String"><a href="#345-Reverse-Vowels-of-a-String" class="headerlink" title="345    Reverse Vowels of a String"></a>345    Reverse Vowels of a String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"> public  boolean isVowel(char a)&#123;</span><br><span class="line">	    switch(a)&#123;</span><br><span class="line">	         case (&apos;a&apos;) : return true;</span><br><span class="line">	         case (&apos;e&apos;) : return true;</span><br><span class="line">	         case (&apos;i&apos;) : return true;</span><br><span class="line">	         case (&apos;o&apos;) : return true;</span><br><span class="line">	         case (&apos;u&apos;) : return true;</span><br><span class="line">	         case (&apos;A&apos;) : return true;</span><br><span class="line">	         case (&apos;E&apos;) : return true;</span><br><span class="line">	         case (&apos;I&apos;) : return true;</span><br><span class="line">	         case (&apos;O&apos;) : return true;</span><br><span class="line">	         case (&apos;U&apos;) : return true;</span><br><span class="line">	         default : return false;</span><br><span class="line">	    &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public  String reverseVowels(String s) &#123;</span><br><span class="line">	     if (s.length()&lt;2) return s;</span><br><span class="line">	</span><br><span class="line">	     char[] tab = s.toCharArray();</span><br><span class="line">	     int j = tab.length - 1;</span><br><span class="line">	     int i = 0;</span><br><span class="line">	</span><br><span class="line">	     while( i &lt; j ) &#123;</span><br><span class="line"></span><br><span class="line">		if (!isVowel(tab[i]))</span><br><span class="line">			i++;	</span><br><span class="line">		else &#123;</span><br><span class="line">			while (j!=i &amp;&amp; !isVowel(tab[j]))</span><br><span class="line">				j--;</span><br><span class="line">			</span><br><span class="line">			char temp = tab[i];</span><br><span class="line">			tab[i] = tab[j];</span><br><span class="line">			tab[j] = temp;</span><br><span class="line">			i++;</span><br><span class="line">			j--;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	return new String(tab);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先将string变为charArray，然后依然从头找元音，找到后再从未开始找。找到后交换。 最后返回new String。</p>
<h3 id="205-Isomorphic-Strings"><a href="#205-Isomorphic-Strings" class="headerlink" title="205    Isomorphic Strings"></a>205    Isomorphic Strings</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public boolean isIsomorphic(String s, String t) &#123;</span><br><span class="line">        int[] m1 = new int[256];</span><br><span class="line">        int[] m2 = new int[256];</span><br><span class="line">        </span><br><span class="line">        for (int i = 0; i &lt; s.length(); i++) &#123;</span><br><span class="line">            if (m1[s.charAt(i)] != m2[t.charAt(i)]) return false;</span><br><span class="line">            m1[s.charAt(i)] = m2[t.charAt(i)] = i+1;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>可以用两个hashmap，但是时间不划算。可以用int[]代替，如果不相等说明次序不等。char可以表示成256的int（ascii）。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 10]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/11/Everyday-Leetcode-10/</url>
      <content type="html"><![CDATA[<h3 id="28-Implement-strStr"><a href="#28-Implement-strStr" class="headerlink" title="28    Implement strStr()"></a>28    Implement strStr()</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int strStr(String haystack, String needle) &#123;</span><br><span class="line">       if(needle==null||needle.length()==0) return 0;</span><br><span class="line">       if(haystack.length()&lt;needle.length()) return -1;</span><br><span class="line">       for(int i=0;i&lt;=haystack.length()-needle.length();++i)&#123;</span><br><span class="line">           int j=0;</span><br><span class="line">           for(;j&lt;needle.length();++j)&#123;</span><br><span class="line">                if (haystack.charAt(i + j) != needle.charAt(j)) break;</span><br><span class="line">           &#125;</span><br><span class="line">           if (j == needle.length()) return i;</span><br><span class="line">           &#125;</span><br><span class="line">       return -1;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure>
<p>如果有位置不等的就跳出循环，如果循环长度等于n长度就返回i。前面两个cornercase。<br><a id="more"></a></p>
<h3 id="14-Longest-Common-Prefix"><a href="#14-Longest-Common-Prefix" class="headerlink" title="14    Longest Common Prefix"></a>14    Longest Common Prefix</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public String longestCommonPrefix(String[] strs) &#123;</span><br><span class="line">       if (strs == null || strs.length == 0) return &quot;&quot;;</span><br><span class="line">       for (int j = 0; j &lt; strs[0].length(); ++j) &#123;</span><br><span class="line">           for (int i = 0; i &lt; strs.length; ++i) &#123;</span><br><span class="line">               if (j &gt;= strs[i].length() || strs[i].charAt(j) != strs[0].charAt(j)) &#123;</span><br><span class="line">                   return strs[i].substring(0, j); </span><br><span class="line">               &#125;   </span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return strs[0];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果不相等说明最长前缀已找到，否则最后返回第一个单词就是结果。</p>
<h3 id="58-Length-of-Last-Word"><a href="#58-Length-of-Last-Word" class="headerlink" title="58    Length of Last Word"></a>58    Length of Last Word</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public int lengthOfLastWord(String s) &#123;</span><br><span class="line">   if(s.length()&lt;1) return 0;</span><br><span class="line">       int res=0;</span><br><span class="line">       int i=s.length()-1;</span><br><span class="line">       while(i&gt;=0&amp;&amp;s.charAt(i)==&apos; &apos;) i--;</span><br><span class="line">       while(i&gt;=0&amp;&amp;s.charAt(i)!=&apos; &apos;) &#123;</span><br><span class="line">           res++;</span><br><span class="line">           i--;</span><br><span class="line">       &#125;</span><br><span class="line">      return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>从末尾找齐，把空格去掉，再遇到空格就统计到这段为止的长度。注意i&gt;=0一定要在前面，不然会越界。</p>
<h3 id="387-First-Unique-Character-in-a-String"><a href="#387-First-Unique-Character-in-a-String" class="headerlink" title="387    First Unique Character in a String"></a>387    First Unique Character in a String</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"> public int firstUniqChar(String s) &#123;</span><br><span class="line">    if(s==null||s.length()&lt;1) return -1;</span><br><span class="line">    if(s.length()==1) return 0;</span><br><span class="line">    for(int i=0;i&lt;s.length();i++)&#123;</span><br><span class="line">        if(s.lastIndexOf(s.charAt(i))==i &amp;&amp;s.indexOf(s.charAt(i))==i) return i;</span><br><span class="line">      &#125;</span><br><span class="line">     return -1;</span><br><span class="line">    &#125;</span><br><span class="line">//5ms</span><br><span class="line">public int firstUniqChar(String s) &#123;</span><br><span class="line">    int[] count = new int[26];</span><br><span class="line">        </span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            count[c - &apos;a&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        int i = 0;</span><br><span class="line">        for (char c : s.toCharArray()) &#123;</span><br><span class="line">            if (count[c- &apos;a&apos;] == 1) &#123;</span><br><span class="line">                return i;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果first和lastindex都是i，说明是唯一的。<br>第二种解法，统计每个字母的个数，然后==1的就是唯一的。</p>
<h3 id="383-Ransom-Note"><a href="#383-Ransom-Note" class="headerlink" title="383    Ransom Note"></a>383    Ransom Note</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public boolean canConstruct(String ransomNote, String magazine) &#123;</span><br><span class="line">    </span><br><span class="line">     int[] arr = new int[26];</span><br><span class="line">        for (int i = 0; i &lt; magazine.length(); i++) &#123;</span><br><span class="line">            arr[magazine.charAt(i) - &apos;a&apos;]++;</span><br><span class="line">        &#125;</span><br><span class="line">        for (int i = 0; i &lt; ransomNote.length(); i++) &#123;</span><br><span class="line">            if(--arr[ransomNote.charAt(i)-&apos;a&apos;] &lt; 0) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure>
<p>统计每个字母出现次数。如果–后小于0说明false 否则true。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 9 ]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/10/Everyday-Leetcode-9/</url>
      <content type="html"><![CDATA[<h3 id="75-Sort-Colors"><a href="#75-Sort-Colors" class="headerlink" title="75    Sort Colors"></a>75    Sort Colors</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">public void sortColors(int[] nums) &#123;</span><br><span class="line">    // 1-pass</span><br><span class="line">    int p1 = 0, p2 = nums.length - 1, index = 0;</span><br><span class="line">    while (index &lt;= p2) &#123;</span><br><span class="line">        if (nums[index] == 0) &#123;</span><br><span class="line">            nums[index] = nums[p1];</span><br><span class="line">            nums[p1] = 0;</span><br><span class="line">            p1++;</span><br><span class="line">        &#125;</span><br><span class="line">        if (nums[index] == 2) &#123;</span><br><span class="line">            nums[index] = nums[p2];</span><br><span class="line">            nums[p2] = 2;</span><br><span class="line">            p2--;</span><br><span class="line">            index--;</span><br><span class="line">        &#125;</span><br><span class="line">        index++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//2pass</span><br><span class="line">public void sortColors(int[] nums) &#123;</span><br><span class="line">        int rc=0,wc=0,bc=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(nums[i]==0) rc++;</span><br><span class="line">            else if(nums[i]==1) wc++;</span><br><span class="line">            else if(nums[i]==2) bc++;</span><br><span class="line">        &#125;</span><br><span class="line">        for(int j=0;j&lt;nums.length;j++)&#123;</span><br><span class="line">        if(rc&gt;0)&#123;nums[j]=0;rc--;&#125;</span><br><span class="line">        else  if(wc&gt;0)&#123;nums[j]=1;wc--;&#125;</span><br><span class="line">        else   if(bc&gt;0)&#123;nums[j]=2;bc--;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>1pass方法，在头部插入0，在尾部插入2，其他1不动。<br>2pass，统计数目然后重新写入。<br><a id="more"></a></p>
<h3 id="283-Move-Zeroes"><a href="#283-Move-Zeroes" class="headerlink" title="283    Move Zeroes"></a>283    Move Zeroes</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> public void moveZeroes(int[] nums) &#123;</span><br><span class="line">         </span><br><span class="line">    if (nums == null || nums.length == 0) return;        </span><br><span class="line"></span><br><span class="line">    int insertPos = 0;</span><br><span class="line">    for (int num: nums) &#123;</span><br><span class="line">        if (num != 0) nums[insertPos++] = num;</span><br><span class="line">    &#125;        </span><br><span class="line"></span><br><span class="line">    while (insertPos &lt; nums.length) &#123;</span><br><span class="line">        nums[insertPos++] = 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果不等于0则在前面开始插入，然后补足0。</p>
<h3 id="376-Wiggle-Subsequence"><a href="#376-Wiggle-Subsequence" class="headerlink" title="376    Wiggle Subsequence"></a>376    Wiggle Subsequence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public int wiggleMaxLength(int[] nums) &#123;</span><br><span class="line">        if (nums.length &lt; 2) return nums.length;</span><br><span class="line">        int up = 1;</span><br><span class="line">        int down = 1;</span><br><span class="line">        </span><br><span class="line">        for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (nums[i] &gt; nums[i - 1]) &#123;</span><br><span class="line">                up = down + 1;</span><br><span class="line">            &#125;</span><br><span class="line">            else if (nums[i] &lt; nums[i - 1]) &#123;</span><br><span class="line">                down = up + 1;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        return Math.max(up, down); </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>很巧妙的做法，设置up和down，只有符合wiggle的才会递增，不然停滞，最后输出max即可。</p>
<h3 id="280-Wiggle-Sort"><a href="#280-Wiggle-Sort" class="headerlink" title="280    Wiggle Sort"></a>280    Wiggle Sort</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">void wiggleSort(vector&lt;int&gt; &amp;nums) &#123;</span><br><span class="line">       if (nums.size() &lt;= 1) return;</span><br><span class="line">       for (int i = 1; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">           if ((i % 2 == 1 &amp;&amp; nums[i] &lt; nums[i - 1]) || (i % 2 == 0 &amp;&amp; nums[i] &gt; nums[i - 1])) &#123;</span><br><span class="line">               swap(nums[i], nums[i - 1]);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果不符合条件就和前面的交换。</p>
<h3 id="324-Wiggle-Sort-II"><a href="#324-Wiggle-Sort-II" class="headerlink" title="324    Wiggle Sort II"></a>324    Wiggle Sort II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public void wiggleSort(int[] nums) &#123;</span><br><span class="line">       int[] copy = new int[nums.length];</span><br><span class="line">       Arrays.sort(nums);</span><br><span class="line">       for(int i = 0; i &lt; nums.length; i++) copy[i] = nums[i];</span><br><span class="line">       int index = 1;</span><br><span class="line">       for(int i = nums.length - 1; i &gt; (nums.length - 1) / 2; i--)&#123;</span><br><span class="line">           nums[index] = copy[i];</span><br><span class="line">           index += 2;</span><br><span class="line">       &#125;</span><br><span class="line">       index = 0;</span><br><span class="line">       for(int i = (nums.length - 1) / 2; i &gt;= 0; i--)&#123;</span><br><span class="line">           nums[index] = copy[i];</span><br><span class="line">           index += 2;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先将数组排序，然后复制数组，将后半部分的数组每2个插入，前半部分的数组也每2个插入。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 8]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/09/Everyday-Leetcode-8/</url>
      <content type="html"><![CDATA[<h3 id="238-Product-of-Array-Except-Self"><a href="#238-Product-of-Array-Except-Self" class="headerlink" title="238    Product of Array Except Self"></a>238    Product of Array Except Self</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int[] productExceptSelf(int[] nums) &#123;</span><br><span class="line">       if(nums==null||nums.length&lt;=1) return null;</span><br><span class="line">        int[] res = new int[nums.length];</span><br><span class="line">       res[0] = 1;</span><br><span class="line">       for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">       res[i] = res[i - 1] * nums[i - 1];</span><br><span class="line">       &#125;</span><br><span class="line">       int right = 1;</span><br><span class="line">   for (int i = nums.length-1; i &gt;= 0; i--) &#123;</span><br><span class="line">       res[i] *= right;</span><br><span class="line">       right *= nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">   return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>自己做的时候算错了，以为这样不是O（n），不过确实也很巧妙。第一遍遍历算i左边的累积，第二遍算i右边的累积。得出结果。<br><a id="more"></a></p>
<h3 id="152-Maximum-Product-Subarray"><a href="#152-Maximum-Product-Subarray" class="headerlink" title="152    Maximum Product Subarray"></a>152    Maximum Product Subarray</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int maxProduct(int[] nums) &#123;</span><br><span class="line">    int maxSum = nums[0];</span><br><span class="line">    int currentMax = nums[0];</span><br><span class="line">    int currentMin = nums[0];</span><br><span class="line"></span><br><span class="line">    for (int i = 1; i &lt; nums.length; i++) &#123;</span><br><span class="line">        if (nums[i] &lt; 0)&#123;</span><br><span class="line">        int tmp = currentMax;</span><br><span class="line">        currentMax = currentMin;</span><br><span class="line">        currentMin = tmp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        currentMax = Math.max(nums[i], currentMax * nums[i]);</span><br><span class="line">        currentMin = Math.min(nums[i], currentMin * nums[i]);</span><br><span class="line">        maxSum = Math.max(maxSum, currentMax);</span><br><span class="line">    &#125;</span><br><span class="line">        return maxSum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果小于0则交换currentMax和min，将到现在为止最大和最小的乘积都保存下来。注意比较的是nums[i]和nums[i]*currentMax/min，这样相当于可以从nums[i]重新开始算乘积。</p>
<h3 id="228-Summary-Ranges"><a href="#228-Summary-Ranges" class="headerlink" title="228    Summary Ranges"></a>228    Summary Ranges</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public List&lt;String&gt; summaryRanges(int[] nums) &#123;</span><br><span class="line">        List&lt;String&gt; list=new ArrayList();</span><br><span class="line">	if(nums.length==1)&#123;</span><br><span class="line">		list.add(nums[0]+&quot;&quot;);</span><br><span class="line">		return list;</span><br><span class="line">	&#125;</span><br><span class="line">    for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">    	int a=nums[i];</span><br><span class="line">    	while(i+1&lt;nums.length&amp;&amp;(nums[i+1]-nums[i])==1)&#123;</span><br><span class="line">    		i++;</span><br><span class="line">    	&#125;</span><br><span class="line">    	if(a!=nums[i])&#123;</span><br><span class="line">    		list.add(a+&quot;-&gt;&quot;+nums[i]);</span><br><span class="line">    	&#125;else&#123;</span><br><span class="line">    		list.add(a+&quot;&quot;);</span><br><span class="line">    	&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return list;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>如果能构成连续的就一直走到底。如果走过了就输出-&gt;， 没走过就输出原有的a。太巧妙。</p>
<h3 id="163-Missing-Ranges"><a href="#163-Missing-Ranges" class="headerlink" title="163    Missing Ranges"></a>163    Missing Ranges</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;string&gt; findMissingRanges(vector&lt;int&gt;&amp; nums, int lower, int upper) &#123;</span><br><span class="line">       vector&lt;string&gt; res;</span><br><span class="line">       int l = lower;</span><br><span class="line">       for (int i = 0; i &lt;= nums.size(); ++i) &#123;</span><br><span class="line">           int r = (i &lt; nums.size() &amp;&amp; nums[i] &lt;= upper) ? nums[i] : upper + 1;</span><br><span class="line">           if (l == r) ++l;</span><br><span class="line">           else if (r &gt; l) &#123;</span><br><span class="line">               res.push_back(r - l == 1 ? to_string(l) : to_string(l) + &quot;-&gt;&quot; + to_string(r - 1));</span><br><span class="line">               l = r + 1;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>我们首先将lower赋给l，然后开始遍历nums数组，如果i小于nums长度且当前数字小于等于upper，我们让r等于当前数字，否则如果当i等于nums的长度时或者当前数字大于upper时，将r赋为upper+1。然后判断l和r的值，若相同，l自增1，否则当r大于l时，说明缺失空间存在，我们看l和r是否差1，如果是，说明只缺失了一个数字，若不是，则说明缺失了一个区间，我们分别加上数字或者区间即可。</p>
<h3 id="88-Merge-Sorted-Array"><a href="#88-Merge-Sorted-Array" class="headerlink" title="88    Merge Sorted Array"></a>88    Merge Sorted Array</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public void merge(int[] nums1, int m, int[] nums2, int n) &#123;</span><br><span class="line">   int i=m-1, j=n-1, k=m+n-1;</span><br><span class="line">    while (i&gt;-1 &amp;&amp; j&gt;-1) nums1[k--]= (nums1[i]&gt;nums2[j]) ? nums1[i--] : nums2[j--];</span><br><span class="line">    while (j&gt;-1)         nums1[k--]=nums2[j--];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>精妙之处在于两个while的条件。首先肯定如果i先遍历完，j还没有遍历完的话，是可以在下个循环全部插入的。 如果j先遍历完，说明插入完成，剩下的i已经在nums1里了，这就是巧妙之处。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 7]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/06/Everyday-Leetcode-7/</url>
      <content type="html"><![CDATA[<h3 id="239-Sliding-Window-Maximum"><a href="#239-Sliding-Window-Maximum" class="headerlink" title="239    Sliding Window Maximum"></a>239    Sliding Window Maximum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public int[] maxSlidingWindow(int[] a, int k) &#123;		</span><br><span class="line">		if (a == null || k &lt;= 0) &#123;</span><br><span class="line">			return new int[0];</span><br><span class="line">		&#125;</span><br><span class="line">		int n = a.length;</span><br><span class="line">		int[] r = new int[n-k+1];</span><br><span class="line">		int ri = 0;</span><br><span class="line">		// store index</span><br><span class="line">		Deque&lt;Integer&gt; q = new ArrayDeque&lt;&gt;();</span><br><span class="line">		for (int i = 0; i &lt; a.length; i++) &#123;</span><br><span class="line">			// remove numbers out of range k</span><br><span class="line">			while (!q.isEmpty() &amp;&amp; q.peek() &lt; i - k + 1) &#123;</span><br><span class="line">				q.poll();</span><br><span class="line">			&#125;</span><br><span class="line">			// remove smaller numbers in k range as they are useless</span><br><span class="line">			while (!q.isEmpty() &amp;&amp; a[q.peekLast()] &lt; a[i]) &#123;</span><br><span class="line">				q.pollLast();</span><br><span class="line">			&#125;</span><br><span class="line">			// q contains index... r contains content</span><br><span class="line">			q.offer(i);</span><br><span class="line">			if (i &gt;= k - 1) &#123;</span><br><span class="line">				r[ri++] = a[q.peek()];</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return r;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>
<p>这题用到了不熟悉的数据结构Deque，用q保存整个数组的下标遍历整个数组，如果此时队列的首元素是i - k的话，表示此时窗口向右移了一步，则移除队首元素。然后比较队尾元素和将要进来的值，如果小的话就都移除，然后此时我们把队首元素加入结果中即可。<br><a id="more"></a></p>
<h3 id="295-Find-Median-from-Data-Stream"><a href="#295-Find-Median-from-Data-Stream" class="headerlink" title="295    Find Median from Data Stream"></a>295    Find Median from Data Stream</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class MedianFinder &#123;</span><br><span class="line"></span><br><span class="line">    /** initialize your data structure here. */</span><br><span class="line">   </span><br><span class="line"></span><br><span class="line">    private Queue&lt;Long&gt; small = new PriorityQueue(),</span><br><span class="line">                        large = new PriorityQueue();</span><br><span class="line"></span><br><span class="line">    public void addNum(int num) &#123;</span><br><span class="line">        large.add((long) num);</span><br><span class="line">        small.add(-large.poll());</span><br><span class="line">        if (large.size() &lt; small.size())</span><br><span class="line">            large.add(-small.poll());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public double findMedian() &#123;</span><br><span class="line">        return large.size() &gt; small.size()</span><br><span class="line">               ? large.peek()</span><br><span class="line">               : (large.peek() - small.peek()) / 2.0;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题用了两个PriorityQueue，分别记录数组的两端，始终保持large数量大于等于small，此时中位数要么是large.peek，要么是large与small头部元素的差/2。</p>
<h3 id="53-Maximum-Subarray"><a href="#53-Maximum-Subarray" class="headerlink" title="53    Maximum Subarray"></a>53    Maximum Subarray</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public int maxSubArray(int[] nums) &#123;</span><br><span class="line">      int res=Integer.MIN_VALUE;</span><br><span class="line">      if (nums==null||nums.length&lt;1) return 0;</span><br><span class="line">      if (nums.length==1) return nums[0];</span><br><span class="line">      for(int i=1;i&lt;nums.length;i++)&#123;</span><br><span class="line">          if (nums[i-1]&gt;0)</span><br><span class="line">              nums[i]+=nums[i-1];</span><br><span class="line">      &#125;</span><br><span class="line">      for(int j:nums)&#123;</span><br><span class="line">          res= Math.max(res,j);</span><br><span class="line">      &#125;</span><br><span class="line">      return res;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注意边界情况。</p>
<h3 id="325-Maximum-Size-Subarray-Sum-Equals-k"><a href="#325-Maximum-Size-Subarray-Sum-Equals-k" class="headerlink" title="325    Maximum Size Subarray Sum Equals k"></a>325    Maximum Size Subarray Sum Equals k</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">public:</span><br><span class="line">    int maxSubArrayLen(vector&lt;int&gt;&amp; nums, int k) &#123;</span><br><span class="line">        int sum = 0, res = 0;</span><br><span class="line">        unordered_map&lt;int, int&gt; m;</span><br><span class="line">        for (int i = 0; i &lt; nums.size(); ++i) &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            if (sum == k) res = i + 1;</span><br><span class="line">            else if (m.count(sum - k)) res = max(res, i - m[sum - k]);</span><br><span class="line">            if (!m.count(sum)) m[sum] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>用一个变量sum边累加边处理，只要保存第一个出现该累积和的位置，后面再出现直接跳过，这样算下来就是最长的子数组。</p>
<h3 id="209-Minimum-Size-Subarray-Sum"><a href="#209-Minimum-Size-Subarray-Sum" class="headerlink" title="209    Minimum Size Subarray Sum"></a>209    Minimum Size Subarray Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">//O（n）做法</span><br><span class="line"> public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">        int i = 0, j = 0, sum = 0, min = Integer.MAX_VALUE;</span><br><span class="line">        while (j &lt; nums.length) &#123;</span><br><span class="line">            while (sum &lt; s &amp;&amp; j &lt; nums.length) sum += nums[j++];</span><br><span class="line">            if(sum&gt;=s)&#123;</span><br><span class="line">                while (sum &gt;= s &amp;&amp; i &lt; j) sum -= nums[i++];</span><br><span class="line">                min = Math.min(min, j - i + 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return min == Integer.MAX_VALUE ? 0 : min;</span><br><span class="line">    &#125;</span><br><span class="line">//O（nlogn）做法</span><br><span class="line">public int minSubArrayLen(int s, int[] nums) &#123;</span><br><span class="line">        int i = 1, j = nums.length, min = 0;</span><br><span class="line">        while (i &lt;= j) &#123;</span><br><span class="line">            int mid = (i + j) / 2;</span><br><span class="line">            if (windowExist(mid, nums, s)) &#123;</span><br><span class="line">                j = mid - 1;</span><br><span class="line">                min = mid;</span><br><span class="line">            &#125; else i = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return min;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    private boolean windowExist(int size, int[] nums, int s) &#123;</span><br><span class="line">        int sum = 0;</span><br><span class="line">        for (int i = 0; i &lt; nums.length; i++) &#123;</span><br><span class="line">            if (i &gt;= size) sum -= nums[i - size];</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            if (sum &gt;= s) return true;</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先让 right 向右移，直到子数组和大于等于给定值或者 right 达到数组末尾，此时我们更新最短距离，并且将 left 像右移一位，然后再 sum 中减去移去的值，然后重复上面的步骤，直到 right 到达末尾，且 left 到达临界位置，即要么到达边界，要么再往右移动，和就会小于给定值。 此时即为最小序列。<br>nlogn，二分，不断查找这段中有没有序列值为s的序列，有则返回true，最后锁定size。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 6]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/05/Everyday-Leetcode-6/</url>
      <content type="html"><![CDATA[<h3 id="128-Longest-Consecutive-Sequence"><a href="#128-Longest-Consecutive-Sequence" class="headerlink" title="128    Longest Consecutive Sequence"></a>128    Longest Consecutive Sequence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int longestConsecutive(int[] nums) &#123;</span><br><span class="line">        int res = 0;</span><br><span class="line">        Set&lt;Integer&gt; s = new HashSet&lt;Integer&gt;();</span><br><span class="line">        for (int num : nums) s.add(num);</span><br><span class="line">        for (int num : nums) &#123;</span><br><span class="line">            if (s.remove(num)) &#123;</span><br><span class="line">                int pre = num - 1, next = num + 1;</span><br><span class="line">                while (s.remove(pre)) --pre;</span><br><span class="line">                while (s.remove(next)) ++next;</span><br><span class="line">                res = Math.max(res, next - pre - 1);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先都加入到hashset中，遍历nums，如果有，则remove，然后一个个remove前一个和后一个数，得出最大序列长度。<br><a id="more"></a></p>
<h3 id="164-Maximum-Gap"><a href="#164-Maximum-Gap" class="headerlink" title="164    Maximum Gap"></a>164    Maximum Gap</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">//我的做法，先排序。 faster than 37.82%，less than 85.87%。</span><br><span class="line"> public int maximumGap(int[] nums) &#123;</span><br><span class="line">        if(nums.length&lt;2||nums==null) return 0;</span><br><span class="line">        int res=0;</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">         if(nums.length==2)return nums[1]-nums[0];</span><br><span class="line">        for(int i=0;i&lt;=nums.length-2;i++)&#123;</span><br><span class="line">        res=Math.max(res,nums[i+1]-nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">//桶排序</span><br><span class="line">public int maximumGap(int[] nums)&#123;</span><br><span class="line">   if (num == null || num.length &lt; 2)</span><br><span class="line">        return 0;</span><br><span class="line">    // get the max and min value of the array</span><br><span class="line">    int min = num[0];</span><br><span class="line">    int max = num[0];</span><br><span class="line">    for (int i:num) &#123;</span><br><span class="line">        min = Math.min(min, i);</span><br><span class="line">        max = Math.max(max, i);</span><br><span class="line">    &#125;</span><br><span class="line">    // the minimum possibale gap, ceiling of the integer division</span><br><span class="line">    int gap = (int)Math.ceil((double)(max - min)/(num.length - 1));</span><br><span class="line">    int[] bucketsMIN = new int[num.length - 1]; // store the min value in that bucket</span><br><span class="line">    int[] bucketsMAX = new int[num.length - 1]; // store the max value in that bucket</span><br><span class="line">    Arrays.fill(bucketsMIN, Integer.MAX_VALUE);</span><br><span class="line">    Arrays.fill(bucketsMAX, Integer.MIN_VALUE);</span><br><span class="line">    // put numbers into buckets</span><br><span class="line">    for (int i:num) &#123;</span><br><span class="line">        if (i == min || i == max)</span><br><span class="line">            continue;</span><br><span class="line">        int idx = (i - min) / gap; // index of the right position in the buckets</span><br><span class="line">        bucketsMIN[idx] = Math.min(i, bucketsMIN[idx]);</span><br><span class="line">        bucketsMAX[idx] = Math.max(i, bucketsMAX[idx]);</span><br><span class="line">    &#125;</span><br><span class="line">    // scan the buckets for the max gap</span><br><span class="line">    int maxGap = Integer.MIN_VALUE;</span><br><span class="line">    int previous = min;</span><br><span class="line">    for (int i = 0; i &lt; num.length - 1; i++) &#123;</span><br><span class="line">        if (bucketsMIN[i] == Integer.MAX_VALUE &amp;&amp; bucketsMAX[i] == Integer.MIN_VALUE)</span><br><span class="line">            // empty bucket</span><br><span class="line">            continue;</span><br><span class="line">        // min value minus the previous value is the current gap</span><br><span class="line">        maxGap = Math.max(maxGap, bucketsMIN[i] - previous);</span><br><span class="line">        // update previous bucket value</span><br><span class="line">        previous = bucketsMAX[i];</span><br><span class="line">    &#125;</span><br><span class="line">    maxGap = Math.max(maxGap, max - previous); // updata the final max value gap</span><br><span class="line">    return maxGap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先进行桶排序，然后遍历桶，算出并记录最大的gap，returnmaxGap。</p>
<h3 id="287-Find-the-Duplicate-Number"><a href="#287-Find-the-Duplicate-Number" class="headerlink" title="287    Find the Duplicate Number"></a>287    Find the Duplicate Number</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">//我的解法，比较朴素。</span><br><span class="line"> public int findDuplicate(int[] nums) &#123;</span><br><span class="line">        if(nums==null||nums.length&lt;1) return 0;</span><br><span class="line">        if(nums.length==2) return nums[0];</span><br><span class="line">        Arrays.sort(nums);</span><br><span class="line">        for(int i=0;i&lt;nums.length-1;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (nums[i]==nums[i+1]) return nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">//击败100%解法。</span><br><span class="line"> public int findDuplicate(int[] nums) &#123;</span><br><span class="line">        if (nums.length &gt; 1)&#123;</span><br><span class="line">		int slow = nums[0];</span><br><span class="line">		int fast = nums[nums[0]];</span><br><span class="line">		while (slow != fast)&#123;</span><br><span class="line">			slow = nums[slow];</span><br><span class="line">			fast = nums[nums[fast]];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		fast = 0;</span><br><span class="line">		while (fast != slow)&#123;</span><br><span class="line">			fast = nums[fast];</span><br><span class="line">			slow = nums[slow];</span><br><span class="line">		&#125;</span><br><span class="line">		return slow;</span><br><span class="line">	&#125;</span><br><span class="line">	return -1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用两个指针，fast每次走两步，slow每次走一步，fast==slow时说明在环中，只要找到环的起始位置，此时fast为0,同步搜索。再次相等时就是答案。</p>
<h3 id="4-Median-of-Two-Sorted-Arrays"><a href="#4-Median-of-Two-Sorted-Arrays" class="headerlink" title="4    Median of Two Sorted Arrays"></a>4    Median of Two Sorted Arrays</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public double findMedianSortedArrays(int[] nums1, int[] nums2) &#123;</span><br><span class="line">       int m = nums1.length, n = nums2.length, left = (m + n + 1) / 2, right = (m + n + 2) / 2;</span><br><span class="line">       return (findKth(nums1, nums2, left) + findKth(nums1, nums2, right)) / 2.0;</span><br><span class="line">   &#125;</span><br><span class="line">   int findKth(int[] nums1, int[] nums2, int k) &#123;</span><br><span class="line">       int m = nums1.length, n = nums2.length;</span><br><span class="line">       if (m == 0) return nums2[k - 1];</span><br><span class="line">       if (n == 0) return nums1[k - 1];</span><br><span class="line">       if (k == 1) return Math.min(nums1[0], nums2[0]);</span><br><span class="line">       int i = Math.min(m, k / 2), j = Math.min(n, k / 2);</span><br><span class="line">       if (nums1[i - 1] &gt; nums2[j - 1]) &#123;</span><br><span class="line">           return findKth(nums1, Arrays.copyOfRange(nums2, j, n), k - j);</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">           return findKth(Arrays.copyOfRange(nums1, i, m), nums2, k - i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>首先我们要判断数组是否为空，为空的话，直接在另一个数组找第K个即可。还有一种情况是当 K = 1 时，表示我们要找第一个元素，只要比较两个数组的第一个元素，返回较小的那个即可。这里我们分别取出两个数组的第 K/2 个数字的位置坐标i和j，为了避免数组没有第 K/2 个数组的情况，我们每次都和数组长度做比较，取出较小值。</p>
<h3 id="289-Game-of-Life"><a href="#289-Game-of-Life" class="headerlink" title="289    Game of Life"></a>289    Game of Life</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">public void gameOfLife(int[][] board) &#123;</span><br><span class="line">    if (board == null || board.length == 0) return;</span><br><span class="line">    int m = board.length, n = board[0].length;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            int lives = liveNeighbors(board, m, n, i, j);</span><br><span class="line"></span><br><span class="line">            // In the beginning, every 2nd bit is 0;</span><br><span class="line">            // So we only need to care about when will the 2nd bit become 1.</span><br><span class="line">            if (board[i][j] == 1 &amp;&amp; lives &gt;= 2 &amp;&amp; lives &lt;= 3) &#123;  </span><br><span class="line">                board[i][j] = 3; // Make the 2nd bit 1: 01 ---&gt; 11</span><br><span class="line">            &#125;</span><br><span class="line">            if (board[i][j] == 0 &amp;&amp; lives == 3) &#123;</span><br><span class="line">                board[i][j] = 2; // Make the 2nd bit 1: 00 ---&gt; 10</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    for (int i = 0; i &lt; m; i++) &#123;</span><br><span class="line">        for (int j = 0; j &lt; n; j++) &#123;</span><br><span class="line">            board[i][j] &gt;&gt;= 1;  // Get the 2nd state.</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int liveNeighbors(int[][] board, int m, int n, int i, int j) &#123;</span><br><span class="line">    int lives = 0;</span><br><span class="line">    for (int x = Math.max(i - 1, 0); x &lt;= Math.min(i + 1, m - 1); x++) &#123;</span><br><span class="line">        for (int y = Math.max(j - 1, 0); y &lt;= Math.min(j + 1, n - 1); y++) &#123;</span><br><span class="line">            lives += board[x][y] &amp; 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    lives -= board[i][j] &amp; 1;</span><br><span class="line">    return lives;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用1234纪录状态，&gt;&gt;1 来获得最终状态。 liveNeighbors统计周边活着的邻居。</p>
<h3 id="57-Insert-Interval"><a href="#57-Insert-Interval" class="headerlink" title="57    Insert Interval"></a>57    Insert Interval</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public int[][] insert(int[][] intervals, int[] newInterval) &#123;</span><br><span class="line">        // Time : O(n) Space : O(n)</span><br><span class="line">        if(newInterval == null) return intervals;</span><br><span class="line">        int[][] list = new int[intervals.length + 1][2];</span><br><span class="line">        int i = 0;</span><br><span class="line">        int idx = 0;</span><br><span class="line">        while(i &lt; intervals.length &amp;&amp; intervals[i][1] &lt; newInterval[0]) &#123;</span><br><span class="line">            list[idx][0] = intervals[i][0];</span><br><span class="line">            list[idx++][1] = intervals[i++][1];</span><br><span class="line">        &#125;</span><br><span class="line">        while(i &lt; intervals.length &amp;&amp; intervals[i][0] &lt;= newInterval[1]) &#123;</span><br><span class="line">            newInterval[0] = Math.min(newInterval[0], intervals[i][0]);</span><br><span class="line">            newInterval[1] = Math.max(newInterval[1], intervals[i++][1]);</span><br><span class="line">        &#125;</span><br><span class="line">        list[idx][0] = newInterval[0];</span><br><span class="line">        list[idx++][1] = newInterval[1];</span><br><span class="line">        while(i &lt; intervals.length) &#123;</span><br><span class="line">            list[idx][0] = intervals[i][0];</span><br><span class="line">            list[idx++][1] = intervals[i++][1];</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] res = new int[idx][2];</span><br><span class="line">        for(int j = 0; j &lt; idx; j++) &#123;</span><br><span class="line">            res[j][0] = list[j][0];</span><br><span class="line">            res[j][1] = list[j][1];</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>首先如果原来的interval的第i个数对的第2个数小于newInterval的第一个数，说明不重叠，直接加入新的list。如果原来的interval的第i个数对的第1个数小于等于newInterval的第二个数，说明重叠，将两边的最小和最大值记录到newinterval。然后插入list。最后将interval剩下的值都插入list，再将list的前idx个数对取出，就是答案。</p>
<h3 id="56-Merge-Intervals"><a href="#56-Merge-Intervals" class="headerlink" title="56    Merge Intervals"></a>56    Merge Intervals</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">public int[][] merge(int[][] intervals) &#123;</span><br><span class="line">        List&lt;int[]&gt; arr = new ArrayList&lt;&gt;();</span><br><span class="line">        Arrays.sort(intervals, new Comparator&lt;int[]&gt;()&#123;</span><br><span class="line">            @Override</span><br><span class="line">            public int compare(int[] a, int[] b)&#123;</span><br><span class="line">                return a[0] - b[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        for(int i = 0; i &lt; intervals.length;i++)&#123;</span><br><span class="line">            int[] interval = new int[2];</span><br><span class="line">            interval[0] = intervals[i][0];</span><br><span class="line">            int max = intervals[i][1];</span><br><span class="line">            while(i &lt; intervals.length-1 &amp;&amp; max &gt;= intervals[i+1][0])&#123;</span><br><span class="line">                max = Math.max(max, intervals[i+1][1]);</span><br><span class="line">                i=i+1;</span><br><span class="line">            &#125;</span><br><span class="line">            interval[1] = max;</span><br><span class="line">            arr.add(interval);</span><br><span class="line">        &#125;</span><br><span class="line">        int[][] answer = new int[arr.size()][2];</span><br><span class="line">        for(int i = 0; i &lt; arr.size(); i++)&#123;</span><br><span class="line">            answer[i] = arr.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return answer;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>重写了compare方法，返回第一个数相减的结果。然后将intervals排序，遍历每个数对，记录最大值max，实现把重叠的merge的操作，将每个数对加入arr。</p>
<h3 id="252-Meeting-Rooms"><a href="#252-Meeting-Rooms" class="headerlink" title="252    Meeting Rooms"></a>252    Meeting Rooms</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">//被锁只能找C++解法</span><br><span class="line">bool canAttendMeetings(vector&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        sort(intervals.begin(), intervals.end(), [](const Interval &amp;a, const Interval &amp;b)&#123;return a.start &lt; b.start;&#125;);</span><br><span class="line">        for (int i = 1; i &lt; intervals.size(); ++i) &#123;</span><br><span class="line">            if (intervals[i].start &lt; intervals[i - 1].end) &#123;</span><br><span class="line">                return false;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>先排序，如果区间的开始小于前一个区间的结束说明重叠。</p>
<h3 id="253-Meeting-Rooms-II"><a href="#253-Meeting-Rooms-II" class="headerlink" title="253    Meeting Rooms II"></a>253    Meeting Rooms II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//被锁只能找C++解法</span><br><span class="line">int minMeetingRooms(vector&lt;Interval&gt;&amp; intervals) &#123;</span><br><span class="line">        map&lt;int, int&gt; m;</span><br><span class="line">        for (auto a : intervals) &#123;</span><br><span class="line">            ++m[a.start];</span><br><span class="line">            --m[a.end];</span><br><span class="line">        &#125;</span><br><span class="line">        int rooms = 0, res = 0;</span><br><span class="line">        for (auto it : m) &#123;</span><br><span class="line">            res = max(res, rooms += it.second);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>遍历时间区间，对于起始时间，映射值自增1，对于结束时间，映射值自减1，然后定义结果变量 res，和房间数 rooms，遍历 TreeMap，时间从小到大，房间数每次加上映射值，然后更新结果 res，遇到起始时间，映射是正数，则房间数会增加，如果一个时间是一个会议的结束时间，也是另一个会议的开始时间，则映射值先减后加仍为0，并不用分配新的房间，而结束时间的映射值为负数更不会增加房间数。</p>
<h3 id="352-Data-Stream-as-Disjoint-Intervals"><a href="#352-Data-Stream-as-Disjoint-Intervals" class="headerlink" title="352    Data Stream as Disjoint Intervals"></a>352    Data Stream as Disjoint Intervals</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line">//老题目用Interval时</span><br><span class="line">class SummaryRanges &#123;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">     Map&lt;Integer, Interval&gt; smap;</span><br><span class="line">    Map&lt;Integer, Interval&gt; emap;</span><br><span class="line">    Set&lt;Integer&gt; added;</span><br><span class="line"></span><br><span class="line">    public SummaryRanges() &#123;</span><br><span class="line">        smap = new TreeMap&lt;&gt;();</span><br><span class="line">        emap = new TreeMap&lt;&gt;();</span><br><span class="line">        added = new HashSet&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addNum(int val) &#123;</span><br><span class="line">        </span><br><span class="line">        if(added.contains(val)) return;</span><br><span class="line">        added.add(val);</span><br><span class="line">        </span><br><span class="line">        Interval s = smap.get(val+1);</span><br><span class="line">        Interval e = emap.get(val-1);</span><br><span class="line">        </span><br><span class="line">        smap.remove(val+1);</span><br><span class="line">        emap.remove(val-1);</span><br><span class="line"> </span><br><span class="line">        Interval n = new Interval(e!=null?e.start:val, s!=null?s.end:val);</span><br><span class="line">        smap.put(n.start, n);</span><br><span class="line">        emap.put(n.end, n);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public List&lt;Interval&gt; getIntervals() &#123;</span><br><span class="line">        return new ArrayList&lt;&gt;(smap.values());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">//新题目用int[][]时</span><br><span class="line">class SummaryRanges &#123;</span><br><span class="line">    </span><br><span class="line">    List&lt;int[]&gt; intervals;</span><br><span class="line"></span><br><span class="line">    /** Initialize your data structure here. */</span><br><span class="line">    public SummaryRanges() &#123;</span><br><span class="line">        intervals = new ArrayList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public void addNum(int val) &#123;</span><br><span class="line">        boolean find = false;</span><br><span class="line">        for (int[] interval : intervals) &#123;</span><br><span class="line">            if (val == interval[0] - 1) &#123;</span><br><span class="line">                interval[0] = val;</span><br><span class="line">                find = true;</span><br><span class="line">            &#125; else if (val == interval[1] + 1) &#123;</span><br><span class="line">                interval[1] = val;</span><br><span class="line">                find = true;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        if (!find) &#123;</span><br><span class="line">            int[] tmp = new int[2];</span><br><span class="line">            tmp[0] = val;</span><br><span class="line">            tmp[1] = val;</span><br><span class="line">            intervals.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    public int[][] getIntervals() &#123;</span><br><span class="line">        Collections.sort(intervals, (a, b) -&gt; &#123;</span><br><span class="line">            if (a[0] == b[0]) &#123;</span><br><span class="line">                return a[1] - b[1];</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                return a[0] - b[0];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        //merge</span><br><span class="line">        List&lt;int[]&gt; merged = new ArrayList&lt;&gt;();</span><br><span class="line">        int[] prev = null;</span><br><span class="line">        for (int[] cur : intervals) &#123;</span><br><span class="line">            if (prev == null || cur[0] &gt; prev[1] + 1) &#123;</span><br><span class="line">                merged.add(cur);</span><br><span class="line">                prev = cur;</span><br><span class="line">            &#125; else if (cur[1] &gt; prev[1]) &#123;</span><br><span class="line">                prev[1] = cur[1];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        intervals = merged;</span><br><span class="line">        int[][] res = new int[merged.size()][2];</span><br><span class="line">        for (int i = 0; i &lt; merged.size(); i++) &#123;</span><br><span class="line">            res[i] = merged.get(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当addNum时， 先从startmap和endmap里面尝试get，如果有就用原来的start/end值作为新的区间，没有就用val作为新的区间并put进smap和emap。新题目思想一样，多了在getInterval中 merg等等过程，如果cur[0]大于前一个的end+1或者前一个为null则直接add，否则前一个的end为现在的end。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 5]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/04/Everyday-Leetcode-5/</url>
      <content type="html"><![CDATA[<h3 id="188-Best-Time-to-Buy-and-Sell-Stock-IV"><a href="#188-Best-Time-to-Buy-and-Sell-Stock-IV" class="headerlink" title="188    Best Time to Buy and Sell Stock IV"></a>188    Best Time to Buy and Sell Stock IV</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int k, int[] prices) &#123;</span><br><span class="line">int n = prices.length;</span><br><span class="line">if (n &lt;= 1)</span><br><span class="line">	return 0;</span><br><span class="line"></span><br><span class="line">if (k &gt;=  n/2) &#123;</span><br><span class="line">	int maxPro = 0;</span><br><span class="line">	for (int i = 1; i &lt; n; i++) &#123;</span><br><span class="line">		if (prices[i] &gt; prices[i-1])</span><br><span class="line">			maxPro += prices[i] - prices[i-1];</span><br><span class="line">	&#125;</span><br><span class="line">	return maxPro;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">   int[][] dp = new int[k+1][n];</span><br><span class="line">   for (int i = 1; i &lt;= k; i++) &#123;</span><br><span class="line">   	int localMax = dp[i-1][0] - prices[0];</span><br><span class="line">   	for (int j = 1; j &lt; n; j++) &#123;</span><br><span class="line">   		dp[i][j] = Math.max(dp[i][j-1],  prices[j] + localMax);</span><br><span class="line">   		localMax = Math.max(localMax, dp[i-1][j] - prices[j]);</span><br><span class="line">   	&#125;</span><br><span class="line">   &#125;</span><br><span class="line">   return dp[k][n-1];</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>如果K大于N/2,说明可以做最多的交易次数，也就是N/2，此时只要是盈利的交易都做，得到最大的收益。 else的话进行dp。dp[i][j-1]是不交易的情况，prices[j]+localMax是在j天交易的情况。<br><a id="more"></a></p>
<h3 id="309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown"><a href="#309-Best-Time-to-Buy-and-Sell-Stock-with-Cooldown" class="headerlink" title="309    Best Time to Buy and Sell Stock with Cooldown"></a>309    Best Time to Buy and Sell Stock with Cooldown</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">   if(prices.length==0 ||prices==null) return 0;</span><br><span class="line">   int buy=Integer.MIN_VALUE;</span><br><span class="line">   int presell=0,prebuy=0,sell=0;</span><br><span class="line">       for(int i: prices)&#123;</span><br><span class="line">           prebuy=buy;</span><br><span class="line">           buy=Math.max(presell-i,prebuy);</span><br><span class="line">           presell=sell;</span><br><span class="line">           sell=Math.max(prebuy+i,presell);</span><br><span class="line">       &#125;</span><br><span class="line">   return sell;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>递推式： buy的情况，要么不买（prebuy,记录i-1天），要么在i-2天前sell，然后在i天buy。 sell的情况，要么不卖（presell，记录i-1天），要么在（i-1天）buy，然后在i天sell。</p>
<h3 id="11-Container-With-Most-Water"><a href="#11-Container-With-Most-Water" class="headerlink" title="11    Container With Most Water"></a>11    Container With Most Water</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">//自己的初始想法 仅仅战胜5.02%</span><br><span class="line">public int maxArea(int[] height) &#123;</span><br><span class="line">        if(height==null || height.length&lt;=1) return 0;</span><br><span class="line">        int ans=Integer.MIN_VALUE;</span><br><span class="line">        for(int i=height.length-1;i&gt;=0;i--)</span><br><span class="line">            for(int j=0;j&lt;height.length;j++)&#123;</span><br><span class="line">                ans=Math.max(Math.min(height[i],height[j])*(i-j),ans);</span><br><span class="line">            &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br><span class="line">//优化后 faster than 97.7%</span><br><span class="line"> public int maxArea(int[] height) &#123;</span><br><span class="line">        if(height==null || height.length&lt;=1) return 0;</span><br><span class="line">        int left = 0, right = height.length - 1;</span><br><span class="line">	    int maxArea = 0;</span><br><span class="line"></span><br><span class="line">	    while (left &lt; right) &#123;</span><br><span class="line">		maxArea = Math.max(maxArea, Math.min(height[left], height[right])</span><br><span class="line">				* (right - left));</span><br><span class="line">		if (height[left] &lt; height[right])</span><br><span class="line">			left++;</span><br><span class="line">		else</span><br><span class="line">			right--;</span><br><span class="line">	    &#125;</span><br><span class="line"></span><br><span class="line">	return maxArea;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>开始想法太粗暴，其实只要两头往中间相遇，遍历一遍即可。</p>
<h3 id="42-Trapping-Rain-Water"><a href="#42-Trapping-Rain-Water" class="headerlink" title="42    Trapping Rain Water"></a>42    Trapping Rain Water</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public int trap(int[] A)&#123;</span><br><span class="line">    int a=0;</span><br><span class="line">    int b=A.length-1;</span><br><span class="line">    int max=0;</span><br><span class="line">    int leftmax=0;</span><br><span class="line">    int rightmax=0;</span><br><span class="line">    while(a&lt;=b)&#123;</span><br><span class="line">        leftmax=Math.max(leftmax,A[a]);</span><br><span class="line">        rightmax=Math.max(rightmax,A[b]);</span><br><span class="line">        if(leftmax&lt;rightmax)&#123;</span><br><span class="line">            max+=(leftmax-A[a]);       // leftmax is smaller than rightmax, so the (leftmax-A[a]) water can be stored</span><br><span class="line">            a++;</span><br><span class="line">        &#125;</span><br><span class="line">        else&#123;</span><br><span class="line">            max+=(rightmax-A[b]);</span><br><span class="line">            b--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return max;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也是两头往中间相遇，每格的面积刚好是leftmax-A[a]或者rightmax-A[b] 乘以1。</p>
<h3 id="334-Increasing-Triplet-Subsequence"><a href="#334-Increasing-Triplet-Subsequence" class="headerlink" title="334    Increasing Triplet Subsequence"></a>334    Increasing Triplet Subsequence</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"> public boolean increasingTriplet(int[] nums) &#123;</span><br><span class="line">         int small = Integer.MAX_VALUE, big = Integer.MAX_VALUE;</span><br><span class="line">        for (int n : nums) &#123;</span><br><span class="line">            if (n &lt;= small) &#123; small = n; &#125;</span><br><span class="line">            else if (n &lt;= big) &#123; big = n; &#125; </span><br><span class="line">            else return true; </span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>存储遍历过程中的最小值与大于最小值小于最大值的值。如果找到能构成序列的三个n则return true，否则return false。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 4]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/05/03/Everyday-Leetcode-4/</url>
      <content type="html"><![CDATA[<h3 id="55-Jump-Game"><a href="#55-Jump-Game" class="headerlink" title="55    Jump Game"></a>55    Jump Game</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">     public boolean canJump(int[] nums) &#123;</span><br><span class="line">        if(nums.length&lt;2)</span><br><span class="line">            return true;</span><br><span class="line">        if(nums[0]&lt;1)</span><br><span class="line">            return false;</span><br><span class="line">        int curr=nums[0];</span><br><span class="line">        for(int i =1;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(nums[i]&gt;=curr) curr=nums[i];   </span><br><span class="line">            else curr--;</span><br><span class="line">            if(curr&lt;=0&amp;&amp;i!=nums.length-1) return false;</span><br><span class="line">        &#125;</span><br><span class="line">        return true;        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>遍历数组，如果下一步能比current走得远就走，否则current-1（每一步花的距离）。如果current&lt;=0时还没有走到尽头，说明无法跳到。如果没有return false说明可以跳到。此处greedy比dp更好。<br><a id="more"></a></p>
<h3 id="45-Jump-Game-II"><a href="#45-Jump-Game-II" class="headerlink" title="45    Jump Game II"></a>45    Jump Game II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public int jump(int[] nums) &#123;</span><br><span class="line">       int end = 0;</span><br><span class="line">       int furthest =0;</span><br><span class="line">       int result=0;</span><br><span class="line">       </span><br><span class="line">       for(int i=0;i&lt;nums.length-1;i++)&#123;</span><br><span class="line">           furthest = Math.max(furthest, i+nums[i]);</span><br><span class="line">           if(i==end)&#123;</span><br><span class="line">               result+=1;</span><br><span class="line">               end = furthest;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       return result;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>每一步走最远，记录下步数到result，更新end到最远。 也是greedy。</p>
<h3 id="121-Best-Time-to-Buy-and-Sell-Stock"><a href="#121-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="121    Best Time to Buy and Sell Stock"></a>121    Best Time to Buy and Sell Stock</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">       int buy=0;</span><br><span class="line">       int sell=1;</span><br><span class="line">       int maxProfit=0;</span><br><span class="line">       while(sell&lt;prices.length)&#123;</span><br><span class="line">           int profit=prices[sell]-prices[buy];</span><br><span class="line">           maxProfit=Math.max(maxProfit,profit);</span><br><span class="line">           if(profit&lt;0) buy=sell;</span><br><span class="line">           sell++;</span><br><span class="line">       &#125;</span><br><span class="line">       return maxProfit;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>遍历所有盈利最大值并存储，如果无法profit就把buy设置成那天（价格低）。这样可以在最低的价格买入。</p>
<h3 id="122-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#122-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="122    Best Time to Buy and Sell Stock II"></a>122    Best Time to Buy and Sell Stock II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123;</span><br><span class="line">     int result = 0;</span><br><span class="line">     for(int i=1;i&lt;prices.length;i++)</span><br><span class="line">     result=Math.max(result+prices[i]-prices[i-1],result);</span><br><span class="line">     return result;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>只要盈利就做卖出操作，遍历后即可得到最大收益。</p>
<h3 id="123-Best-Time-to-Buy-and-Sell-Stock-III"><a href="#123-Best-Time-to-Buy-and-Sell-Stock-III" class="headerlink" title="123    Best Time to Buy and Sell Stock III"></a>123    Best Time to Buy and Sell Stock III</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public int maxProfit(int[] prices) &#123; </span><br><span class="line">       if (prices == null || prices.length &lt;= 1) &#123;</span><br><span class="line">            return 0;</span><br><span class="line">        &#125;</span><br><span class="line">       int cost1 = Integer.MAX_VALUE, cost2 = Integer.MAX_VALUE, profit1 = 0, profit2 = 0;</span><br><span class="line"></span><br><span class="line">       for (int price : prices)&#123;</span><br><span class="line">           cost1 = Math.min(cost1, price);</span><br><span class="line">           profit1 = Math.max(profit1, price - cost1);</span><br><span class="line">           cost2 = Math.min(cost2, price - profit1);</span><br><span class="line">           profit2 = Math.max(profit2, price - cost2);</span><br><span class="line">       &#125;</span><br><span class="line">       return profit2;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>该做法较直观，其实dp也可以。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 3]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/04/30/Everyday-Leetcode-3/</url>
      <content type="html"><![CDATA[<h3 id="277-Find-the-Celebrity"><a href="#277-Find-the-Celebrity" class="headerlink" title="277    Find the Celebrity"></a>277    Find the Celebrity</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int findCelebrity(int n) &#123;</span><br><span class="line">        for (int i = 0, j = 0; i &lt; n; ++i) &#123;</span><br><span class="line">            for (j = 0; j &lt; n; ++j) &#123;</span><br><span class="line">                if (i != j &amp;&amp; (knows(i, j) || !knows(j, i))) break;</span><br><span class="line">            &#125;</span><br><span class="line">            if (j == n) return i;</span><br><span class="line">        &#125;</span><br><span class="line">        return -1;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>遍历，如果遇到 i认识j或者j不认识i就break，完整循环下来的就是celebrity。<br><a id="more"></a></p>
<h3 id="217-Contains-Duplicate"><a href="#217-Contains-Duplicate" class="headerlink" title="217    Contains Duplicate"></a>217    Contains Duplicate</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashSet;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public boolean containsDuplicate(int[] nums) &#123;</span><br><span class="line">        HashSet&lt;Integer&gt; hs = new HashSet&lt;&gt;();</span><br><span class="line">        for(int i:nums)</span><br><span class="line">        &#123;</span><br><span class="line">            if(hs.contains(i)) return true;</span><br><span class="line">            else hs.add(i);</span><br><span class="line">        &#125;</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>hashset遍历，如果包含就返回true，否则就加入hashset。</p>
<h3 id="243-Shortest-Word-Distance"><a href="#243-Shortest-Word-Distance" class="headerlink" title="243    Shortest Word Distance"></a>243    Shortest Word Distance</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int shortestDistance(vector&lt;string&gt;&amp; words, string word1, string word2) &#123;</span><br><span class="line">        int p1 = -1, p2 = -1, res = INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; words.size(); ++i) &#123;</span><br><span class="line">            if (words[i] == word1) p1 = i;</span><br><span class="line">            else if (words[i] == word2) p2 = i;</span><br><span class="line">            if (p1 != -1 &amp;&amp; p2 != -1) res = min(res, abs(p1 - p2));</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>遍历一次数组找出p1,p2，得出结果。</p>
<h3 id="244-Shortest-Word-Distance-II"><a href="#244-Shortest-Word-Distance-II" class="headerlink" title="244    Shortest Word Distance II"></a>244    Shortest Word Distance II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class WordDistance &#123;</span><br><span class="line">public:</span><br><span class="line">    WordDistance(vector&lt;string&gt;&amp; words) &#123;</span><br><span class="line">        for (int i = 0; i &lt; words.size(); ++i) &#123;</span><br><span class="line">            m[words[i]].push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    int shortest(string word1, string word2) &#123;</span><br><span class="line">        int res = INT_MAX;</span><br><span class="line">        for (int i = 0; i &lt; m[word1].size(); ++i) &#123;</span><br><span class="line">            for (int j = 0; j &lt; m[word2].size(); ++j) &#123;</span><br><span class="line">                res = min(res, abs(m[word1][i] - m[word2][j]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">private:</span><br><span class="line">    unordered_map&lt;string, vector&lt;int&gt; &gt; m;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>hashmap解法。</p>
<h3 id="245-Shortest-Word-Distance-III"><a href="#245-Shortest-Word-Distance-III" class="headerlink" title="245    Shortest Word Distance III"></a>245    Shortest Word Distance III</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">int shortestWordDistance(vector&lt;string&gt;&amp; words, string word1, string word2) &#123;</span><br><span class="line">       int p1 = words.size(), p2 = -words.size(), res = INT_MAX;</span><br><span class="line">       for (int i = 0; i &lt; words.size(); ++i) &#123;</span><br><span class="line">           if (words[i] == word1) p1 = word1 == word2 ? p2 : i;</span><br><span class="line">           if (words[i] == word2) p2 = i;</span><br><span class="line">           res = min(res, abs(p1 - p2));</span><br><span class="line">       &#125;</span><br><span class="line">       return res;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>如果p1和p2相等，结果为p2-i。不相等则同243的做法。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 2]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/04/29/Everyday-Leetcode-2/</url>
      <content type="html"><![CDATA[<h3 id="41-First-Missing-Positive"><a href="#41-First-Missing-Positive" class="headerlink" title="41    First Missing Positive"></a>41    First Missing Positive</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import java.util.HashMap;</span><br><span class="line">class Solution &#123;</span><br><span class="line">    public int firstMissingPositive(int[] nums) &#123;</span><br><span class="line">        HashMap map = new HashMap&lt;&gt;();</span><br><span class="line">        for (int i:nums)&#123;</span><br><span class="line">            map.put(i,1);</span><br><span class="line">        &#125;</span><br><span class="line">        for (int j=1;j&lt;Integer.MAX_VALUE;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (!map.containsKey(j))&#123;</span><br><span class="line">                return j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return 0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一道自己做出的Hard，可能是最简单的Hard。 faster than 83.02%，less than 86.32%.<br><a id="more"></a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">public int firstMissingPositive(int[] nums) &#123;</span><br><span class="line">    int n = nums.length;</span><br><span class="line">    </span><br><span class="line">    // 1. mark numbers (num &lt; 0) and (num &gt; n) with a special marker number (n+1) </span><br><span class="line">    // (we can ignore those because if all number are &gt; n then we&apos;ll simply return 1)</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (nums[i] &lt;= 0 || nums[i] &gt; n) &#123;</span><br><span class="line">            nums[i] = n + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // note: all number in the array are now positive, and on the range 1..n+1</span><br><span class="line">    </span><br><span class="line">    // 2. mark each cell appearing in the array, by converting the index for that number to negative</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        int num = Math.abs(nums[i]);</span><br><span class="line">        if (num &gt; n) &#123;</span><br><span class="line">            continue;</span><br><span class="line">        &#125;</span><br><span class="line">        num--; // -1 for zero index based array (so the number 1 will be at pos 0)</span><br><span class="line">        if (nums[num] &gt; 0) &#123; // prevents double negative operations</span><br><span class="line">            nums[num] = -1 * nums[num];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 3. find the first cell which isn&apos;t negative (doesn&apos;t appear in the array)</span><br><span class="line">    for (int i = 0; i &lt; n; i++) &#123;</span><br><span class="line">        if (nums[i] &gt;= 0) &#123;</span><br><span class="line">            return i + 1;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 4. no positive numbers were found, which means the array contains all numbers 1..n</span><br><span class="line">    return n + 1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最佳解。</p>
<h3 id="299-Bulls-and-Cows"><a href="#299-Bulls-and-Cows" class="headerlink" title="299    Bulls and Cows"></a>299    Bulls and Cows</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public String getHint(String secret, String guess) &#123;</span><br><span class="line">    int bulls = 0;</span><br><span class="line">    int cows = 0;</span><br><span class="line">    int[] numbers = new int[10];</span><br><span class="line">    for (int i = 0; i&lt;secret.length(); i++) &#123;</span><br><span class="line">        int s = Character.getNumericValue(secret.charAt(i));</span><br><span class="line">        int g = Character.getNumericValue(guess.charAt(i));</span><br><span class="line">        if (s == g) bulls++;</span><br><span class="line">        else &#123;</span><br><span class="line">            if (numbers[s] &lt; 0) cows++;</span><br><span class="line">            if (numbers[g] &gt; 0) cows++;</span><br><span class="line">            numbers[s] ++;</span><br><span class="line">            numbers[g] --;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return bulls + &quot;A&quot; + cows + &quot;B&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很坑爹的题，题目表示不清楚。为什么1123，0111是1B，1122，2211却是4B。</p>
<h3 id="134-Gas-Station"><a href="#134-Gas-Station" class="headerlink" title="134    Gas Station"></a>134    Gas Station</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public int canCompleteCircuit(int[] gas, int[] cost) &#123;</span><br><span class="line">    int res=-1;</span><br><span class="line">        for (int i=0;i&lt;gas.length;i++)&#123;</span><br><span class="line">            int tank=gas[i];</span><br><span class="line">            int j=i;</span><br><span class="line">            </span><br><span class="line">            while(tank-cost[j]&gt;=0)&#123;</span><br><span class="line">                if(j==gas.length-1)</span><br><span class="line">                tank=tank-cost[j]+gas[0];</span><br><span class="line">                else</span><br><span class="line">                tank=tank-cost[j]+gas[j+1];</span><br><span class="line">                j++;</span><br><span class="line">                if(j==gas.length) j=0;</span><br><span class="line">                if(j==i) return i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return res;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>思路很简单，但是要小心corner case。</p>
<h3 id="274-H-Index"><a href="#274-H-Index" class="headerlink" title="274    H-Index"></a>274    H-Index</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public int hIndex(int[] citations) &#123;</span><br><span class="line">    int n = citations.length;</span><br><span class="line">    int[] buckets = new int[n+1];</span><br><span class="line">    for(int c : citations) &#123;</span><br><span class="line">        if(c &gt;= n) &#123;</span><br><span class="line">            buckets[n]++;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            buckets[c]++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    int count = 0;</span><br><span class="line">    for(int i = n; i &gt;= 0; i--) &#123;</span><br><span class="line">        count += buckets[i];</span><br><span class="line">        if(count &gt;= i) &#123;</span><br><span class="line">            return i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>bucket sort，空间换时间。首先为长度为n的数组设置n+1个桶，大于n长度的引用数都放到n+1个桶里，然后从尾到头遍历，如果count&gt;=index，这说明我们得到了题目要求的引用数&gt;=index的index。</p>
<h3 id="275-H-Index-II"><a href="#275-H-Index-II" class="headerlink" title="275    H-Index II"></a>275    H-Index II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int hIndex(int[] citations) &#123;</span><br><span class="line">        int len = citations.length, left = 0, right = len - 1;</span><br><span class="line">        while (left &lt;= right) &#123;</span><br><span class="line">            int mid = 0.5 * (left + right);</span><br><span class="line">            if (citations[mid] == len - mid) return len - mid;</span><br><span class="line">            else if (citations[mid] &gt; len - mid) right = mid - 1;</span><br><span class="line">            else left = mid + 1;</span><br><span class="line">        &#125;</span><br><span class="line">        return len - left;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>用bucket sort也可以，但这里更适合binary search，因为是有序数组。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Everyday Leetcode 1]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/04/28/Everyday-Leetcode-1/</url>
      <content type="html"><![CDATA[<h3 id="1-Two-Sum"><a href="#1-Two-Sum" class="headerlink" title="1 Two Sum"></a>1 Two Sum</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Solution &#123;</span><br><span class="line">    public int[] twoSum(int[] nums, int target) &#123;</span><br><span class="line">        Map&lt;Integer,Integer&gt; ans= new HashMap&lt;&gt;();</span><br><span class="line">        for (int i=0; i&lt;nums.length;i++)&#123;</span><br><span class="line">          int diff=target-nums[i];</span><br><span class="line">              if (ans.containsKey(diff))</span><br><span class="line">              &#123;</span><br><span class="line">                  </span><br><span class="line">                  return new int[]&#123;ans.get(diff),i&#125;;</span><br><span class="line">              &#125;</span><br><span class="line">            ans.put(nums[i],i);</span><br><span class="line">          </span><br><span class="line">    &#125;</span><br><span class="line">       throw new IllegalArgumentException();</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用到hashmap，大大提高了效率。 可以用throw new IlleaglArgumentException的办法跳过必须return的检查。<br><a id="more"></a></p>
<h3 id="27-Remove-Element"><a href="#27-Remove-Element" class="headerlink" title="27    Remove Element"></a>27    Remove Element</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public int removeElement(int[] nums, int val) &#123;</span><br><span class="line">       int ans=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if(nums[i]!=val)&#123;</span><br><span class="line">                nums[ans]=nums[i];</span><br><span class="line">                ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;  </span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>没什么好说的。</p>
<h3 id="26-Remove-Duplicates-from-Sorted-Array"><a href="#26-Remove-Duplicates-from-Sorted-Array" class="headerlink" title="26    Remove Duplicates from Sorted Array"></a>26    Remove Duplicates from Sorted Array</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">        int ans=0;</span><br><span class="line">        for(int i=0;i&lt;nums.length;i++)&#123;</span><br><span class="line">            if (nums[i]!=nums[ans])</span><br><span class="line">                nums[++ans]=nums[i];</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        return ++ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>没什么好说的。</p>
<h3 id="80-Remove-Duplicates-from-Sorted-Array-II"><a href="#80-Remove-Duplicates-from-Sorted-Array-II" class="headerlink" title="80    Remove Duplicates from Sorted Array II"></a>80    Remove Duplicates from Sorted Array II</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public int removeDuplicates(int[] nums) &#123;</span><br><span class="line">    int ans=0;</span><br><span class="line">    for (int i : nums)</span><br><span class="line">    &#123;</span><br><span class="line">        if (ans&lt;2 ||i&gt;nums[ans-2])</span><br><span class="line">            nums[ans++]=i;</span><br><span class="line">    &#125;</span><br><span class="line">        return ans;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>没什么好说的。</p>
<h3 id="189-Rotate-Array"><a href="#189-Rotate-Array" class="headerlink" title="189    Rotate Array"></a>189    Rotate Array</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public void rotate(int[] nums, int k) &#123;</span><br><span class="line">        </span><br><span class="line">    k %= nums.length;</span><br><span class="line">    reverse(nums, 0, nums.length - 1);</span><br><span class="line">    reverse(nums, 0, k - 1);</span><br><span class="line">    reverse(nums, k, nums.length - 1);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public void reverse(int[] nums, int start, int end) &#123;</span><br><span class="line">    while (start &lt; end) &#123;</span><br><span class="line">        int temp = nums[start];</span><br><span class="line">        nums[start] = nums[end];</span><br><span class="line">        nums[end] = temp;</span><br><span class="line">        start++;</span><br><span class="line">        end--;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>k可能大于nums.length,所以就需要%=一下。</p>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Leetcode Record]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/04/28/Leetcode-Record/</url>
      <content type="html"><![CDATA[<ul>
<li>[x] 1     Two Sum</li>
<li>[x] 27    Remove Element</li>
<li>[x] 26    Remove Duplicates from Sorted Array</li>
<li>[x] 80    Remove Duplicates from Sorted Array II</li>
<li>[x] 189    Rotate Array</li>
<li>[x] 41    First Missing Positive</li>
<li>[x] 299    Bulls and Cows</li>
<li>[x] 134    Gas Station</li>
<li>[x] 274    H-Index</li>
<li>[x] 275    H-Index II<a id="more"></a></li>
<li>[x] 277    Find the Celebrity</li>
<li>[x] 217    Contains Duplicate</li>
<li>[x] 243    Shortest Word Distance</li>
<li>[x] 244    Shortest Word Distance II</li>
<li>[x] 245    Shortest Word Distance III</li>
<li>[x] 55    Jump Game</li>
<li>[x] 45    Jump Game II</li>
<li>[x] 121    Best Time to Buy and Sell Stock</li>
<li>[x] 122    Best Time to Buy and Sell Stock II</li>
<li>[x] 123    Best Time to Buy and Sell Stock III</li>
<li>[x] 188    Best Time to Buy and Sell Stock IV</li>
<li>[x] 309    Best Time to Buy and Sell Stock with Cooldown</li>
<li>[x] 11    Container With Most Water</li>
<li>[x] 42    Trapping Rain Water</li>
<li>[x] 334    Increasing Triplet Subsequence</li>
<li>[x] 128    Longest Consecutive Sequence</li>
<li>[x] 164    Maximum Gap</li>
<li>[x] 287    Find the Duplicate Number</li>
<li>[x] 4        Median of Two Sorted Arrays</li>
<li>[x] 289    Game of Life</li>
<li>[x] 57    Insert Interval</li>
<li>[x] 56    Merge Intervals</li>
<li>[x] 252    Meeting Rooms</li>
<li>[x] 253    Meeting Rooms II</li>
<li>[x] 352    Data Stream as Disjoint Intervals</li>
<li>[x] 239    Sliding Window Maximum</li>
<li>[x] 295    Find Median from Data Stream</li>
<li>[x] 53    Maximum Subarray</li>
<li>[x] 325    Maximum Size Subarray Sum Equals k</li>
<li>[x] 209    Minimum Size Subarray Sum</li>
<li>[x] 238    Product of Array Except Self</li>
<li>[x] 152    Maximum Product Subarray</li>
<li>[x] 228    Summary Ranges</li>
<li>[x] 163    Missing Ranges</li>
<li>[x] 88    Merge Sorted Array</li>
<li>[x] 75    Sort Colors</li>
<li>[x] 283    Move Zeroes</li>
<li>[x] 376    Wiggle Subsequence</li>
<li>[x] 280    Wiggle Sort</li>
<li>[x] 324    Wiggle Sort II</li>
<li>[x] 28    Implement strStr()    </li>
<li>[x] 14    Longest Common Prefix    </li>
<li>[x] 58    Length of Last Word    </li>
<li>[x] 387    First Unique Character in a String    </li>
<li>[x] 383    Ransom Note</li>
<li>[x] 344    Reverse String    </li>
<li>[x] 151    Reverse Words in a String    </li>
<li>[x] 186    Reverse Words in a String II    </li>
<li>[x] 345    Reverse Vowels of a String    </li>
<li>[x] 205    Isomorphic Strings</li>
<li>[x] 293    Flip Game    </li>
<li>[x] 294    Flip Game II    </li>
<li>[x] 290    Word Pattern    </li>
<li>[x] 242    Valid Anagram    </li>
<li>[x] 49    Group Anagrams</li>
<li>[x] 249    Group Shifted Strings    </li>
<li>[x] 87    Scramble String</li>
<li>[x] 161    One Edit Distance    </li>
<li>[x] 38    Count and Say    </li>
<li>[x] 358    Rearrange String k Distance Apart</li>
<li>[x] 316    Remove Duplicate Letters    </li>
<li>[x] 271    Encode and Decode Strings    </li>
<li>[x] 168    Excel Sheet Column Title    </li>
<li>[x] 171    Excel Sheet Column Number    </li>
<li>[x] 13    Roman to Integer</li>
<li>[x] 12    Integer to Roman    </li>
<li>[x] 273    Integer to English Words    </li>
<li>[x] 246    Strobogrammatic Number    </li>
<li>[x] 247    Strobogrammatic Number II</li>
<li>[x] 68    Text Justification</li>
<li>[x] 65    Valid Number    </li>
<li>[x] 157    Read N Characters Given Read4    </li>
<li>[x] 158    Read N Characters Given Read4 II - Call multiple times</li>
<li>[x] 76    Minimum Window Substring    </li>
<li>[x] 30    Substring with Concatenation of All Words</li>
<li>[x] 3        Longest Substring Without Repeating Characters    </li>
<li>[x] 340    Longest Substring with At Most K Distinct Characters    </li>
<li>[x] 395    Longest Substring with At Least K Repeating Characters    </li>
<li>[x] 159    Longest Substring with At Most Two Distinct Characters    </li>
<li>[x] 125    Valid Palindrome</li>
<li>[x] 266    Palindrome Permutation    </li>
<li>[x] 5    Longest Palindromic Substring    </li>
<li>[x] 9    Palindrome Number    </li>
<li>[x] 214    Shortest Palindrome    </li>
<li>[x] 336    Palindrome Pairs</li>
<li>[x] 131    Palindrome Partitioning    </li>
<li>[x] 132    Palindrome Partitioning II    </li>
<li>[x] 267    Palindrome Permutation II</li>
<li>[x] 20    Valid Parentheses    </li>
<li>[x] 22    Generate Parentheses</li>
<li>[x] 32    Longest Valid Parentheses    </li>
<li>[x] 241    Different Ways to Add Parentheses    </li>
<li>[x] 301    Remove Invalid Parentheses        </li>
<li>[x] 392    Is Subsequence    </li>
<li>[x] 115    Distinct Subsequences</li>
<li>[x] 7        Reverse Integer    </li>
<li>[x] 165    Compare Version Numbers    </li>
<li>[x] 66    Plus One    </li>
<li>[x] 8        String to Integer (atoi)    </li>
<li>[x] 258    Add Digits</li>
<li>[x] 67    Add Binary    </li>
<li>[x] 43    Multiply Strings    </li>
<li>[x] 29    Divide Two Integers    </li>
<li>[x] 69    Sqrt(x)</li>
<li>[x] 50    Pow(x, n)    </li>
<li>[x] 367    Valid Perfect Square    </li>
<li>[x] 365    Water and Jug Problem    </li>
<li>[x] 204    Count Primes</li>
<li>[x] 1        Two Sum    </li>
<li>[x] 167    Two Sum II - Input array is sorted</li>
<li>[x] 15    3Sum</li>
<li>[x] 18    4Sum</li>
<li>[x] 144    Binary Tree Preorder Traversal    </li>
<li>[x] 94    Binary Tree Inorder Traversal    </li>
<li>[x] 145    Binary Tree Postorder Traversal</li>
<li>[x] 100    Same Tree        </li>
<li>[x] 101    Symmetric Tree    </li>
<li>[x] 226    Invert Binary Tree    </li>
<li>[x] 257    Binary Tree Paths    </li>
<li>[x] 112    Path Sum</li>
<li>[x] 113    Path Sum II    </li>
<li>[x] 129    Sum Root to Leaf Numbers    </li>
<li>[x] 298    Binary Tree Longest Consecutive Sequence    </li>
<li>[x] 111    Minimum Depth of Binary Tree</li>
<li>[x] 104    Maximum Depth of Binary Tree</li>
<li>[x] 110   Balanced Binary Tree</li>
<li>[x] 235   Lowest Common Ancestor of a Binary Search Tree     </li>
<li>[x] 236   Lowest Common Ancestor of a Binary Tree    </li>
<li>[x] 108   Convert Sorted Array to Binary Search tree</li>
<li>[x] 109   Convert Sorted List to Binary Search tree</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> Leetcode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[普通人的19fall cs master DIY总结]]></title>
      <url>https://nbPeterWang.github.io/%20/2019/04/15/%E6%99%AE%E9%80%9A%E4%BA%BA%E7%9A%8419fall-cs-master-DIY%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>先对我的情况做个说明，应该是地里的普通人样本，或者可以算是少数的偏下的样本。双非（并非中外合作的双非）、低gpa（3.3/4）、普通TG（101、320+3.5）、无科研无实习，只有一段UCR交流，绩点还很低（2.7）。所以很显而易见地，本文的读者不应该是地里那些条件比我好太多的大神们。写这篇也是为了给将来的和我一样的普通人们做个参考，同时给这段历程做个记录，如果能对别人有点帮助就好了。应该会有点长。</p>
<p>先上结果，均为CS ms（按时间顺序）：<br>6AD：雪城，GWU，Buffalo，ASU，NCSU（最后决定去的学校），WPI<br>9Rej：UTD， Brandeis，Rochester，USC，CU-Boulder，WUSTL，Rutgers，BU，NEU（BU和NEU今天还没来拒信，算作默拒吧）<br><a id="more"></a><br>时间线：<br>2018.9.26 考最后一次托福 结果是101（之前最好95）<br>9.26-11.3 准备GRE的同时写文书<br>2018.11.3 考最后一次GRE 结果320+3.5 （之前最好316+3）<br>11.3-11.12 等作文成绩同时写文书<br>2018.11.12 出作文成绩，完成全部15所学校的网申填写和GT送分，然后忙推荐信。<br>2018.11.20  大概是所有推荐信搞定的日期<br>2018.11.28  UTD拒信，有点小郁闷。<br>2018.12.3    第一个ad，雪城，还给了30%小奖。<br>2019.1.17   GWU ad<br>2019.2.8    Brandeis rej<br>大年初一   Buffalo ad<br>情人节      ASU ad<br>2019.2.26 NCSU ad<br>2019 三月  Rochester， USC，CU-Boulder，WUSTL 四连拒 月底收到WPI<br>2019 四月 目前就Rutgers rej，其他就当作默拒吧。</p>
<h1 id="第一部分-心理准备与为什么DIY"><a href="#第一部分-心理准备与为什么DIY" class="headerlink" title="第一部分 心理准备与为什么DIY"></a>第一部分 心理准备与为什么DIY</h1><blockquote>
<p>“Am I wrong for saying that I’ll choose another way?”<br>&emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; –Nico &amp; Vinz《Am I Wrong》</p>
</blockquote>
<p>我觉得在开始申请之前的很重要的一件事是，坚定自己要出国的信念。如果没有坚定的信念，在申请途中遇到很多困难的时候都会动摇从而影响申请，更别提之后的留学与找工生涯。坚定信念的方法很简单，找一个足够充分的理由说服自己，对我来说这个理由应该是国内普遍的996风气。<br>关于为什么要DIY，其实一开始也动过找中介的想法。对自己有点缺乏信心，但被爸妈劝住了，差点就找了一个小中介（被地里吐槽过的王X）。中介能帮你的无非就两点，一选校，二文书。一可以通过花时间自己找资料解决，二可以通过花时间自己写解决。中介选的校、写的文书一定比你选的和写的好么？我只建议真的没有时间的人找中介，只要你有时间，DIY是完全可以的。中介剩下来的几万块，减去文书润色的几千块（自己写的好的话可以少很多）后足够多申好多所学校（每所才一百多刀）。如果你不相信靠自己能完成整个申请，那么之后的留学与找工又怎么办呢？我很感激父母在整个申请过程中给我的100%的信任。到最后，每个人都要为自己的选择负责。靠自己去想去的地方，做想做的事情是最酷的。</p>
<h1 id="第二部分-选校、文书与GT"><a href="#第二部分-选校、文书与GT" class="headerlink" title="第二部分 选校、文书与GT"></a>第二部分 选校、文书与GT</h1><blockquote>
<p>“I know what I have to do now”<br> &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; —Lenny code fiction《Make my story》</p>
</blockquote>
<p>选校方面：搜集资料然后决定。信息来源有知乎、地里的往届录取情况和院系介绍等、Quora等等。之前看地里说保底四小龙UTD，雪城，GWU，SIT都申不可能失学，除了SIT因为网站太丑没申，我中了两个，还是蛮准的。然后就是主力，我选择了ASU、NCSU这种便宜性价比高的。彩票就随便了，反正省下来的中介费可以多报几个。现在回过头看看，感觉没有很大的失误，以我的条件，这样的选校和结果应该可以接受。<br>文书的话，重要的一点是整体逻辑要完整有说服力，同时又不落俗套。我的话主要就是讲述去UCR的经历，然后加上了Why School部分。在写十五个学校的why school部分的时候，写到后面确实有点晕了，开始复制粘贴，被文书润色的编辑批评了。后面重新查资料写过。总之why school要自己查资料（官网、维基百科等），高度“私人定制”。文书润色机构我选的是最便宜的papersoxxx，还行，对得起价格。前后大概花了2k左右，改了7次。比几万的中介费便宜太多。<br>GT这方面真的讲不来，太菜了，两个都是三战。最后都是背水一战侥幸过关。反正就多练TPO机经，gre也得多练。</p>
<h1 id="第三部分-提交后的漫长等待与最后感想"><a href="#第三部分-提交后的漫长等待与最后感想" class="headerlink" title="第三部分 提交后的漫长等待与最后感想"></a>第三部分 提交后的漫长等待与最后感想</h1><blockquote>
<p>“真爱并非不来 它只是被无预警的恶意的延迟”<br> &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; &emsp; —纵贯线《亡命之徒》</p>
</blockquote>
<p>其实比起大多数人来说我应该是结果出的比较早的人，不过最后也是等到2019.4.10才做了决定。等到了3月份的一波拒信，然后一直没有等到BU的拒信，下定决心去了NCSU。我知道很多人可能一直在等待的过程中饱受煎熬，这是每个申请者都会遇到的事情，但请相信最后的最后会有好的结果。申请季就这样结束了，接下来要更努力啊。愿我们在到达路的末端的时候，都不会后悔。</p>
]]></content>
      
        <categories>
            
            <category> 留学 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 申请总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W22repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/12/23/W22repo/</url>
      <content type="html"><![CDATA[<p>之前漏了一周，有点罪恶。这周回家了。回家后大概就刷cs61b、毕设和leetcode了。加油，2019<br>冲冲冲！</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W20repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/12/10/W20repo/</url>
      <content type="html"><![CDATA[<p>本周学习Go三十六讲到9.</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W19repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/12/02/W19repo/</url>
      <content type="html"><![CDATA[<p>本周学习了Go的http包相关</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W18repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/11/25/W18repo/</url>
      <content type="html"><![CDATA[<p>Go的sturct，面向对象，interface， 学习完成。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W17repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/11/18/W17repo/</url>
      <content type="html"><![CDATA[<p>新的生活，新的苦练</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W16repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/11/11/W16repo/</url>
      <content type="html"><![CDATA[<p>万事俱备，只差送分。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W15repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/11/05/W15repo/</url>
      <content type="html"><![CDATA[<p>全力投入申请，11月必须完成。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W14repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/10/29/W14repo/</url>
      <content type="html"><![CDATA[<p>最后一周，加油！</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W13repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/10/22/W13repo/</url>
      <content type="html"><![CDATA[<p>单词差不多背完，开始刷题。<br>加油。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W12repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/10/14/W12repo/</url>
      <content type="html"><![CDATA[<p>暂时全力准备GRE，等考完再PS。<br>加油。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W11repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/10/07/W11repo/</url>
      <content type="html"><![CDATA[<p>DL已确认，接下来搞定PS和CV。<br>GRE加油！！</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W10repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/10/01/W10repo/</url>
      <content type="html"><![CDATA[<p>国庆： 推荐信 PS CV 送分<br>然后跳进GRE<br>继续加油。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W9repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/09/24/W9repo/</url>
      <content type="html"><![CDATA[<p>离国庆一周，收心。<br>接下来主要是改PS，CV，送分GRE和申请了。<br>然后就努力coding。<br>加油。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W8repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/09/19/W8repo/</url>
      <content type="html"><![CDATA[<p>托福考完，竟有些“圆满”的感觉。<br>又感冒了。<br>继续努力，负重前行。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W7repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/09/09/W7repo/</url>
      <content type="html"><![CDATA[<p>下周托福。<br>快筋疲力尽的时候撑一撑，希望就在前方。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W6repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/09/03/W6repo/</url>
      <content type="html"><![CDATA[<p>回学校啦，图像处理的内容看起来不轻松，同时还要准备托福GRE和成绩单推荐信，很累。<br>在这几年种下的种子，希望过几个月能收获。<br>加油。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W5repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/08/27/W5repo/</url>
      <content type="html"><![CDATA[<p>这周学了一些github lab 的小课。<br>文书目前v1.1.<br>删去了一些学校。<br>继续努力。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W4repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/08/19/W4repo/</url>
      <content type="html"><![CDATA[<p>本周重感冒，希望之后好好补上本周拉下的。上午文书，下午英语，晚上编程。<br>加油。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W3repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/08/12/W3repo/</url>
      <content type="html"><![CDATA[<p>这周买了极客时间上的几门课，希望以后能好好利用。<br>同时银河帝国读到第十本，感悟颇多。谢顿代表的英雄史观，最后仍是机器人在幕后推动的结果，而<br>究其原因，仍是人类自己种下的善果。人类研发出比自己更完美的存在，就这一点而言，人与神一样<br>高贵。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W2repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/08/06/W2repo/</url>
      <content type="html"><![CDATA[<p>这周结束了实习，也算有点收获。<br>对jsp的认识更深入了。<br>正式准备申请了。<br>希望之后也要努力。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W1repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/07/30/W1repo/</url>
      <content type="html"><![CDATA[<p>这周看过的Medium：<br>1、后端路线图，已Mark。<br>2、OOP的缺点，不无道理，但还未在生产中体会到。</p>
<p>这周开始进入工作，逐渐熟悉业务。Mybaits还是很不错的，同时也用到了CVS。要记得，MyEclipse如果打开多个项目，<br>同名函数可能会产生干扰。还有就是对js和jsp的修改不用重启服务器，直接刷新页面即可。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[W0repo]]></title>
      <url>https://nbPeterWang.github.io/%20/2018/07/22/W0repo/</url>
      <content type="html"><![CDATA[<p>从今天开始写第一篇周记,主要是记录一周内的技术类的感悟和Medium读后感，如无意外不会附带任<br>何生活的内容。<br>这周看过的Medium印象深刻的有：<br>1、Pascal的那句名言：“All of humanity’s problems stem from man’s inability to<br>sit quietly in a room alone.” 确实击中了现代人的痛点，孤独是一个永恒的无法排解的伟大<br>话题。要学会利用独处，而不仅仅是慎独。对抗的思维会让孤独侵蚀并毁了你。<br>2、最重要的是解决问题的能力而不是语法。说到底还是逻辑能力。<br>3、根据<a href="https://hackernoon.com/learn-blockchains-by-building-one-117428612f46" target="_blank" rel="noopener">这篇</a>“Learn Blockchains by Building One”搞了一个简易的区块链，还是蛮有意思的。<br>明天开始实习了，希望能有所收获。</p>
]]></content>
      
        <categories>
            
            <category> Coding </category>
            
        </categories>
        
        
        <tags>
            
            <tag> weekly repo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[一战总结]]></title>
      <url>https://nbPeterWang.github.io/%20/2017/05/07/%E4%B8%80%E6%88%98%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>虽然没有人品爆发，不过也算还不错。 R26L28S18W21 93<br>还是要努力，口写一定要稳啊，下次。<br><a id="more"></a><br>首先要感谢听力的陆宁龙老师，教学认真负责，并且富有趣味。他把我从一个完全不知道怎么记笔记的人锻练成了稍微会记一点笔记的人，我已经很满意了。其实记笔记并不是要把听到的全部记下来，而是要理清整篇文章的脉络。换句话说如果你听懂了整篇文章的脉络，不记笔记也是可以的。记笔记也是一种让你强制集中注意力的方法，但不可为了记笔记而错过重要内容。这些都是陆老师告诉我的宝贵经验。当然，听力离不开苦练，只能说练了二三十套tpo是不会白练的。我懒得做精听，所以每一遍都当考试来认真对待。然后也很感谢阅读的袁翔老师，讲的很仔细，对题型的细致分析帮到了我很多。当然自己的阅读还有进步的空间。最后是口语和写作，我发挥得不好，但这不能怪王老师和竺老师，她们的教学都很认真负责，特别是王老师，在课后平时也给了我很多指导，不厌其烦地解答我的问题，真的很谢谢王老师。希望下次我的口语和写作能有进步。</p>
]]></content>
      
        
        <tags>
            
            <tag> English </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[3月总结]]></title>
      <url>https://nbPeterWang.github.io/%20/2017/03/26/3%E6%9C%88%E6%80%BB%E7%BB%93/</url>
      <content type="html"><![CDATA[<p>终于在3月26号这一天看见了太阳，赶紧进黑魂赞美了一下太阳，Long may the sunshine.<br>阴沉的天气，容易让人的心情变得沉郁起来。这也是为什么，太阳不管在农业意义上还是在心理意义上，对人类都是如此的重要。<br>如果太久地过一种模式化的生活，人便会渐渐失去生命力。生命里的变数，不管是好的坏的，给你带来冲击的那一刻，至少证明你还活着。<br>这个月总体来说效率让我很不满意，因为每次想好的计划，总是因为心里上的惰性完不成。比起拖延，更可怕的是一点点小小的付出便足以说服自己休息，失去战斗的勇气和决心。想到这里，对自己的厌恶程度陡然上升。<br>可是又有什么办法呢？生活是如此无聊，如此没有意义。<br>有时想想自己不过是这具身体，这个世界的过客。如果真是如此，如果我们其实只是以第一人称在“体验”一个如小说或电影世界中的人物一般，看似有选择的机会，实则命运操于作者之手，如果是这样，怎么办？<br>很快我就记起了，就算是这样，有时候作者也控制不了笔下人物和剧情的走向。如果说我不屈服于这种意志也是作者的设定的话，那真是再好不过。因为如果和其他人一样，我这个人物就太没意思了。<br>最近很喜欢Oasis，最好的音乐一定是能让你沉浸的音乐，尽管只有几分钟，也是无上的幸福。<br>  Am I cracking up？<br>  Or just getting older?<br>  We’re just getting older.</p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[Words-Success & Work]]></title>
      <url>https://nbPeterWang.github.io/%20/2017/03/04/Words-Success-Work/</url>
      <content type="html"><![CDATA[<p>#TOEFL Words-Success &amp; Work<br>a household name 家喻户晓的名字<br>tenacity/perseverance n 毅力<br>commitment/undertaking/endeavor n 努力去做的事情<br>highly-sought-after  adj 很多人都希望得到的<br>upward mobility 阶级上升可能性<br>setback 挫折<br>rugged adj.坚韧不拔的<br>insumountable adj 不可逾越的<br>obscure adj 不知名的<br>well-thought-out adj 深思熟虑的<br>peccadillo n.可以原谅的过错<br>blunder n.重大的过错<br>charismatic adj 万人迷的<br>industrious adj 工作勤奋的<br>feasible adj 可行的<br>contentment n 很知足的状态<br>work ethic 敬业精神<br>entrepreneur n 白手起家的<br>zeal n 狂热<br>gratification n 满足感<br>exert oneself= do one’s best<br>interpersonal skills 人际交往能力<br>freelancer 自由职业者<br>demanding adj 苛刻的<br>solidarity n 团结<br>workaholic n 工作狂<br>competent adj 有竞争力的<br>flawless adj 完美的<br>etiquette n 礼仪</p>
]]></content>
      
        <categories>
            
            <category> English </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Words </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Words-Technology & Media]]></title>
      <url>https://nbPeterWang.github.io/%20/2017/03/02/Words-Technology/</url>
      <content type="html"><![CDATA[<p>#TOEFL Words-Technology &amp; Media<br>state-of-the-art adj.非常先进的<br>cutting-edge  adj.尖端的<br>revolutionize v 彻底变革<br>automated adj.自动化的 n. automation<br>mechanized adj.机械化的 n. mechanization<br>computer-generated adj.电脑生成的<br>mass-production 大规模生产<br>be detached from reality 脱离现实<br>inconceivable adj. 不可想象的<br>webcam n.摄像头<br>productive adj.高生产率的<br>novel  adj.新颖的<br>user-friendly adj.对用户友好的<br>conventional adj. 常规的<br>enhance=boost v 提高<br>manufacture v 生产<br>standardized adj.标准化的<br>telecommuting n.在家远程上班<br>labor-saving/replacing machinery 减少/取代人力的机器<br>ingenious adj.有独创性的 精巧的<br>at a staggering rate 以惊人的速度<br>ultra-thin adj.超薄的<br>portable adj.便携的<br>anteena n.天线<br>organ transplant 器官移植<br>transactions n.交易<br>manned spacecraft 载人航天器<br>the proliferation of the Internet/the extensive use of the Internet 互联网的广泛使用<br>newsworthy adj.有新闻价值的<br>informative adj.信息量大的<br>entertaining adj.娱乐性强的<br>commodity n. 商品<br>commercialized adj. 商业化的<br>go viral 某种事物在互联网、媒体或公众中快速传开<br>icon 象征<br>censorship n 审查<br>make a splash 演员突然成功<br>blow things out of proportion 夸大事实<br>entirely cut off from the outside world  完全与世隔绝<br>sitcom n.情景喜剧<br>variety show 综艺节目<br>current affairs 时事<br>excessive/ gratuitous violent and pornographic contents 过多的暴力与色情内容<br>fraudulent adj.诈骗性的<br>report sth. in graphic detail 报道非常详尽的细节<br>exaggerate things/sensationalize things 夸大事件<br>objective and balanced 公正客观的<br>tarnish one’s reputation<br>violate /intrude on /infringe on   someone’s privacy 毁坏某人声誉<br>fatucal accounts 如实的描述<br>cover up / gloss over /whitewash v 掩盖<br>biased /skewed/unobjective adj.不客观的<br>reliable/trustworthy /dependable adj.可信的<br>code of ethics/code of conduct 道德准则<br>scrutinize v 监督<br>ubiquitous/prevalent adj 无处不在的<br>high-profile /low-profile adj.高调的/低调的<br>exclusive news 独家新闻<br>the glitz and glamor 明星光环<br>glamorous adj 魅力四射的<br>in the spotlight / in the limelight 处在焦点<br>media hype 媒体炒作<br>fabricated adj 捏造的</p>
]]></content>
      
        <categories>
            
            <category> English </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Words </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Words]]></title>
      <url>https://nbPeterWang.github.io/%20/2017/03/01/Words/</url>
      <content type="html"><![CDATA[<h1 id="TOEFL-Words"><a href="#TOEFL-Words" class="headerlink" title="TOEFL Words"></a>TOEFL Words</h1><p>adolescent  n.青少年 ;adj. 青春期的<br>segregate students 把学生分开教育<br>students  appraise/evaluate their teachers’ performance 学生评价老师的教学<br>generalist n.通才<br>well-rounded/versatile adj.全面发展的<br>humanities 社会科学<br>discipline n.学科；纪律 vt. 管教<br>self-discipline n.自制力<br>primary-level secondary-level tertitary-level education 小、中、大学教育<br>schooling n.学校给学生的教育<br>curriculum n.学校提供的课程总称<br>be proficient in 熟练掌握<br>role model 榜样</p>
<p>aaaaaaa<br>peer n.同龄人<br>peer pressure 来自其他同学的压力<br>well-acquainted (with) adj.对 … 非常熟悉<br>self-esteem n.自尊<br>dignity n.尊严<br>evaluation n.评估<br>indulge in   沉迷于<br>thought-provoking adj.发人深思的<br>illiterate n.文盲 adj.文盲的<br>go astray 误入歧途<br>uplifting adj.令人振奋的<br>minors n.未成年人<br>spoil v. 溺爱<br>juvenile delinquency /youth crime 青少年犯罪<br>truancy n. 逃学<br>formative years 成型的阶段<br>cultivate/foster/nurture v.培养<br>impart/inculcate knowledge 传授知识<br>instill high morla values 灌输高尚的价值观<br>students’ grasp /command of what has been taught 学生对老师所教知识的掌握<br>employable/marketable skills 就业技能<br>force-feed the students 填鸭式教法教学生<br>students should not be treated as passive receptacles<br>of predigested ideas 学生不应该只是被动接受知识的容器<br>memorize for memorization;s own sake 为了记忆而记忆<br>a sense of obligation/duty/resposibility 责任感<br>memorize equations,formulars,theorems and laws 记忆方程式、公式、定理、定律<br>follow sth indiscriminately 盲从<br>extinguish/ stifle /constrain creativity 限制创造力的发展<br>dampen/sap the students’ enthusiasm = frustrate the students 打击学生的积极性<br>beget undue pressure 产生不必要的压力<br>mold one’s character 塑造某人的性格<br>adverse circumstances /adversity n.逆境<br>integrity n.正直诚实且原则性强<br>individualism n.个人主义<br>egalitarian n.平权主义<br>fulfill v. 实现<br>extra-curricular activities 学校是社会的缩影<br>indiscipline /misbehavior/mischief n.不遵守纪律<br>bilingual adj.双语的<br>nagging adj.嘴碎的<br>stimulating adj.有趣的<br>valedictorian n.优秀毕业生<br>graduate summa cum laude 大学毕业成绩最顶尖<br>illuminate v 照亮/ 解释清楚<br>autonomy n. 自我管理<br>edification n.启迪</p>
]]></content>
      
        <categories>
            
            <category> English </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Words </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Let's start from here]]></title>
      <url>https://nbPeterWang.github.io/%20/2017/02/16/test1/</url>
      <content type="html"><![CDATA[<h1 id="Let’s-start-from-here"><a href="#Let’s-start-from-here" class="headerlink" title="Let’s start from here"></a>Let’s start from here</h1><p>从这里开始吧。找了好多模板，最后的结果也不负这一番周折。域名还是算了，就这样玩玩吧。</p>
]]></content>
      
        <categories>
            
            <category> life </category>
            
        </categories>
        
        
        <tags>
            
            <tag> start </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
